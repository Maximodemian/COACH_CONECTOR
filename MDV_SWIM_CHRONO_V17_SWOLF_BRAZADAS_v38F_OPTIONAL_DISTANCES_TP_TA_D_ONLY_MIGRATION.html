<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MDV SWIM CHRONO</title>
  <!-- Librerías -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
  .primary{ background:#10b981; color:white; }
  .primary:disabled{ opacity:.6; cursor:not-allowed; }

  /* Mini spinner (Coach 360) */
  .mini-spinner{
    width:14px; height:14px; display:inline-block;
    border:2px solid rgba(0,0,0,.18);
    border-top-color: rgba(0,0,0,.65);
    border-radius:50%;
    animation: mdvspin 0.9s linear infinite;
  }
  @keyframes mdvspin { to { transform: rotate(360deg); } }

    :root { --bg: #f9f9f9; --fg: #333; --primary: #0066cc; --accent: #00cc99; }
    body { margin: 0; padding: 0; font-family: Arial, sans-serif; background: var(--bg); color: var(--fg); }
    .toolbar { padding: 1rem; background: var(--primary); display: flex; gap: .5rem; overflow-x: auto; }
    
  /* Coach Connector quick toggle */
  .cc-toggle{ display:flex; align-items:center; gap:.5rem; padding:0 .5rem; border-radius:999px; background: rgba(255,255,255,.12); color:#fff; white-space:nowrap; user-select:none; }
  .cc-toggle-text{ font-size:.85rem; opacity:.95; }
  .cc-switch{ position:relative; display:inline-block; width:46px; height:24px; }
  .cc-switch input{ opacity:0; width:0; height:0; }
  .cc-slider{ position:absolute; cursor:pointer; top:0; left:0; right:0; bottom:0; background-color: rgba(255,255,255,.25); transition: .22s; border-radius:999px; }
  .cc-slider:before{ position:absolute; content:""; height:18px; width:18px; left:3px; bottom:3px; background-color:#fff; transition:.22s; border-radius:50%; }
  .cc-switch input:checked + .cc-slider{ background-color: rgba(0,255,170,.55); box-shadow: 0 0 0 2px rgba(0,255,170,.25) inset; }
  .cc-switch input:checked + .cc-slider:before{ transform: translateX(22px); }
  .cc-toggle.on{ background: rgba(0,255,170,.22); }
.toolbar button { background: #fff; border: none; border-radius: .25rem; padding: .5rem 1rem; cursor: pointer; }
    .toolbar button:disabled { opacity: .5; cursor: default; }
    #laneTable { width: 100%; border-collapse: collapse; margin: 1rem 0; }
    #laneTable th, #laneTable td { border: 1px solid #ccc; padding: .5rem; text-align: center; }
    .lane-timer { font-weight: bold; }
    #charts { display: none; padding: 1rem; }
    .charts-wrapper,
    .table-wrapper {
      overflow-x: auto;
      width: 100%;
      max-width: 100vw;
    }
    #partialsChart {
      width: 100%;
      max-width: 2000px;
      height: 500px;
      margin: 0 auto 2rem auto;
    }
    #advancedTables, #advancedCharts { display: none; padding: 1rem; }
    .adv-table { margin: 1.5rem 0; border-collapse: collapse; width: 100%; }
    .adv-table th, .adv-table td { border: 1px solid #bbb; padding: .4rem; text-align: center; }
    .adv-title { font-weight: bold; margin-top: 2rem; font-size: 1.1rem; }
    .adv-chart-canvas {
      width: 100%;
      max-width: 2000px;
      height: 400px;
      margin: 1rem auto 2rem auto;
      display: block;
    }
    
    /* Generic overlay helper (used by migration modal) */
    .overlay{
      display:none;
      position:fixed;
      inset:0;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
    }
    
#overlay, #finalOverlay, #exportOverlay, #downloadOverlay, #sessionOverlay,
    #welcomeOverlay, #readmeOverlay, #licenseOverlay, #exitOverlay, #strokesOverlay, #swolfInfoOverlay {
      display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 1000;
    }
    .modal, #configModal, #finalModal, #exportModal, #downloadModal, #sessionModal,
    #welcomeModal, #readmeModal, #licenseModal, #exitModal {
      display: none; position: fixed; left: 50%; top: 50%; transform: translate(-50%,-50%);
      background: #fff; border-radius: .5rem; padding: 1rem; box-shadow: 0 0 .5rem rgba(0,0,0,0.3);
      min-width: 340px; z-index: 1010;
    }
    #configModal {
      max-height: 90vh;
      display: none;
      position: fixed;
      left: 50%; top: 50%; transform: translate(-50%,-50%);
      background: #fff; border-radius: .5rem; padding: 1rem;
      box-shadow: 0 0 .5rem rgba(0,0,0,0.3);
      min-width: 340px; z-index: 1010;
    }
    #configModal .modal-body {
      max-height: 60vh;
      overflow-y: auto;
      margin-bottom: 1rem;
    }
    /* Migration modal: keep buttons visible with internal scroll */
    #migrationModal{
      width: min(760px, 94vw);
      max-height: 90vh;
      display: none;
      flex-direction: column;
      padding: 16px;
      overflow: hidden;
    }
    #migrationModal .modal-body{
      overflow-y: auto;
      flex: 1 1 auto;
      max-height: 68vh;
      margin-top: 10px;
      padding-right: 6px;
    }
    #migrationModal .modal-footer{
      margin-top: 12px;
      border-top: 1px solid #e5e7eb;
      padding-top: 12px;
      display:flex;
      gap:10px;
      justify-content:flex-end;
      background:#fff;
    }


    /* Session modal (Sesiones / Plantillas) */
    .session-tabs{ display:flex; gap:8px; flex-wrap:wrap; margin:.5rem 0 .25rem 0; }
    .sess-tabbtn{
      background:#f3f4f6; border:1px solid #e5e7eb; padding:.35rem .6rem;
      border-radius:999px; cursor:pointer; font-size:.9rem; line-height:1.1;
    }
    .sess-tabbtn.active{ background:#e0f2fe; border-color:#38bdf8; }
    .sess-count{ display:inline-block; margin-left:.25rem; padding:1px 8px; border-radius:999px; background:#111827; color:#fff; font-size:12px; }
    .sess-tab{ display:none; }
    .sess-tab.active{ display:block; }
    .sess-card{
      border:1px solid #e5e7eb; border-radius:.5rem; padding:.65rem;
      margin:.55rem 0; background:#fff;
    }
    .sess-top{ display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:baseline; }
    .sess-title{ font-weight:700; }
    .sess-muted{ color:#6b7280; font-size:.85rem; }
    .sess-badges{ display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
    .badge{ display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; }
    .badge.session{ background:#e7f7ef; color:#145a32; }
    .badge.template{ background:#eef; color:#334; }
    .badge.legacy{ background:#fff7ed; color:#9a3412; }
    .sess-actions-row{ display:flex; gap:8px; flex-wrap:wrap; margin-top:.55rem; }


    .modal-header { display: flex; justify-content: space-between; align-items: center; }
    .modal-header h2 { margin: 0; }
    .close-btn { background: none; border: none; font-size: 1.5rem; cursor: pointer; }
    .stepper { display: flex; margin: 1rem 0; }
    .step { flex: 1; text-align: center; padding: .5rem; border-bottom: 2px solid #ccc; cursor: pointer; }
    .step.active { border-color: var(--accent); font-weight: bold; }
    .form-step { display: none; }
    .form-step.active { display: block; }
    .form-group { margin-bottom: 1rem; }
    .form-group label { display: block; margin-bottom: .25rem; }
    .form-group input, .form-group select { width: 100%; padding: .5rem; border: 1px solid #ccc; border-radius: .25rem; }
    .form-group input[type="checkbox"] { width: auto; }
    .buttons {
      display: flex;
      justify-content: space-between;
      position: sticky;
      bottom: 0;
      background: #fff;
      padding: .5rem 0;
    }
    .buttons button { padding: .5rem 1rem; border: none; border-radius: .25rem; cursor: pointer; }
    .buttons .next { background: var(--accent); color: #fff; }
    .buttons .prev { background: #ccc; }
    .parcial-fixed {
      background: #111 !important;
      color: #fff !important;
      border-color: #111 !important;
      font-weight: bold;
      cursor: default !important;
    }
    #finalModal .final-options { display: flex; flex-direction: column; gap: 1rem; margin: 1rem 0; }
    #finalModal .final-options button { background: var(--primary); color: #fff; font-size:1.1rem; }
    #finalModal .final-options button:active { background: var(--accent); }
    #finalModal .final-options button:disabled { opacity: 0.5; }
    #finalModal .final-cancel { text-align: right; margin-top: 1rem; }
    #finalModal .final-cancel button { background: #ccc; color: #333; }
    #exportModal .export-options { display: flex; flex-direction: column; gap: .7rem; margin: 1rem 0; }
    #exportModal label { cursor: pointer; }
    #exportModal .export-actions { display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1rem;}
    #downloadModal { min-width: 320px; }
    #downloadModal .download-actions { display: flex; gap: 1rem; justify-content: center; margin-top: 1rem;}
    #resultsTables { padding: 1rem; }

    /* Result tables (end of series) — modern, low-impact, readable */
    #resultsTables .res-title{
      font-weight: 700;
      margin: 1.1rem 0 .55rem 0;
      font-size: 1.06rem;
      color: #111827;
      letter-spacing: .2px;
    }
    #resultsTables .res-wrap{
      border: 1px solid #e5e7eb;
      border-radius: 14px;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      background: #fff;
      box-shadow: 0 1px 2px rgba(0,0,0,.04);
      margin: .35rem 0 1.15rem 0;
    }
    .res-table{
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      font-size: .95rem;
      min-width: 680px; /* enables horizontal scroll on small screens without squishing */
    }
    .res-table thead th{
      background: #f9fafb;
      color: #111827;
      font-weight: 700;
      text-align: center;
      border-bottom: 1px solid #e5e7eb;
      padding: 10px 10px;
      white-space: nowrap;
    }
    .res-table td{
      padding: 10px 10px;
      border-bottom: 1px solid #f1f5f9;
      color: #111827;
      text-align: center;
      vertical-align: middle;
      background: #fff;
    }
    .res-table tbody tr:nth-child(even) td{ background: #fcfcfd; }
    .res-table tbody tr:last-child td{ border-bottom: none; }

    /* Column alignment tweaks per table */
    .res-table-main th:nth-child(2), .res-table-main td:nth-child(2){ text-align: left; }
    .res-table-bestby th:nth-child(1), .res-table-bestby td:nth-child(1){ text-align: left; }
    .res-table-bestseg th:nth-child(2), .res-table-bestseg td:nth-child(2){ text-align: left; }

    /* Slightly smaller helper text inside headers */
    .res-table thead small{ font-weight: 500; color: #6b7280; }
  
#finalModal {
  display: none;
  position: fixed;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  background: #fff;
  border-radius: .5rem;
  padding: 1rem;
  box-shadow: 0 0 .5rem rgba(0,0,0,0.3);
  min-width: 300px;
  max-width: 90vw;
  max-height: 90vh;
  overflow-y: auto;
  z-index: 1010;
}
#finalModal .final-options {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin: 1rem 0;
}
#finalModal .final-options button {
  background: #0066cc;
  color: #fff;
  font-size: 1.1rem;
  padding: 0.5rem;
  border: none;
  border-radius: .25rem;
}
#finalModal .final-options button:active {
  background: #00cc99;
}
#finalModal .final-options button:disabled {
  opacity: 0.5;
}
#finalModal .final-cancel {
  text-align: right;
  margin-top: 1rem;
}
#finalModal .final-cancel button {
  background: #ccc;
  color: #333;
  padding: 0.4rem 1rem;
  border: none;
  border-radius: .25rem;
}

.social-btn {
  background: #e1306c;
  color: white;
  padding: 0.5rem 1rem;
  border: none;
  border-radius: .25rem;
  text-decoration: none;
  font-weight: bold;
  cursor: pointer;
}
.social-btn:hover {
  background: #c72c5d;
}

.donate-btn {
  background: #ffc107;
  color: #000;
  padding: 0.5rem 1rem;
  border: none;
  border-radius: .25rem;
  text-decoration: none;
  font-weight: bold;
  cursor: pointer;
}
.donate-btn:hover {
  background: #e0a800;
}

.social-btn, .donate-btn {
  display: inline-block;
  text-align: center;
  white-space: nowrap;
  padding: 0.5rem 1rem;
  border: none;
  border-radius: .25rem;
  font-weight: bold;
  cursor: pointer;
  min-width: 130px;
  max-width: 180px;
}
.social-btn {
  background: #e1306c;
  color: white;
  text-decoration: none;
}
.social-btn:hover {
  background: #c72c5d;
}
.donate-btn {
  background: #ffc107;
  color: #000;
  text-decoration: none;
}
.donate-btn:hover {
  background: #e0a800;
}
.donate-btn:last-child {
  background: #28a745 !important;
  color: white !important;
}
.donate-btn:last-child:hover {
  background: #218838 !important;
}


/* Forzar dimensiones razonables en los gráficos avanzados para evitar alturas gigantes */
#advancedCharts {
  max-height: 500px;
  overflow-y: auto;
}

.adv-chart-canvas {
  display: block;
  width: 100% !important;
  max-width: 100%;
  height: 260px !important;
  max-height: 320px;
}


/* Indicador de carga en el botón "Ingresar al crono" */
.welcome-loading {
  position: relative;
  pointer-events: none;
  opacity: 0.7;
}

.welcome-loading::after {
  content: '';
  position: absolute;
  right: 0.75rem;
  top: 50%;
  width: 16px;
  height: 16px;
  margin-top: -8px;
  border-radius: 50%;
  border: 2px solid rgba(255, 255, 255, 0.7);
  border-top-color: transparent;
  animation: welcome-spin 0.8s linear infinite;
}

@keyframes welcome-spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.grid2{display:grid; grid-template-columns:1fr 1fr; gap:12px;}
@media(max-width:720px){.grid2{grid-template-columns:1fr;}}

    /* SWOLF / Brazadas */
    .inline-checks{ display:flex; gap:.75rem; align-items:center; flex-wrap:wrap; margin-top:.25rem; }
    .inline-checks label{ display:inline-flex; align-items:center; gap:.35rem; margin:0; }
    .info-btn{
      width:18px; height:18px; border-radius:50%;
      display:inline-flex; align-items:center; justify-content:center;
      border:1px solid #9ca3af; background:#fff; color:#111827;
      font-size:12px; line-height:1; cursor:pointer; padding:0;
    }
    .info-btn:hover{ border-color: var(--accent); }
    #strokesModal .cards{ display:grid; grid-template-columns:repeat(auto-fit,minmax(240px,1fr)); gap:12px; }
    #strokesModal .card{ border:1px solid #e5e7eb; border-radius:12px; padding:12px; background:#fff; }
    #strokesModal table{ width:100%; border-collapse:collapse; }
    #strokesModal th, #strokesModal td{ padding:6px 4px; border-bottom:1px solid #f3f4f6; font-size:.92rem; }
    #strokesModal th{ text-align:left; background:#f9fafb; font-weight:600; }
    #strokesModal input[type="number"]{ width:76px; padding:.35rem .4rem; }
    #swolfTables .swolf-wrap{ margin:12px 0; border:1px solid #e5e7eb; border-radius:12px; overflow:hidden; }
    #swolfTables table{ width:100%; border-collapse:collapse; }
    #swolfTables th, #swolfTables td{ padding:8px; border-bottom:1px solid #f3f4f6; font-size:.95rem; }
    #swolfTables th{ background:#f9fafb; text-align:left; }
    

    /* Coach Connector: pestañas + lista de migraciones */
    .cc-tabs{ display:flex; gap:8px; margin:10px 0 12px; flex-wrap:wrap; }
    .cc-tabbtn{
      border:1px solid rgba(0,0,0,.12);
      background:#f9fafb;
      padding:8px 10px;
      border-radius:999px;
      cursor:pointer;
      font-size:13px;
    }
    .cc-tabbtn.active{ background:#111827; color:#fff; border-color:#111827; }
    .cc-tabpanel{ display:none; }
    .cc-tabpanel.active{ display:block; }

    .cc-mig-list{ display:flex; flex-direction:column; gap:10px; }
    .cc-mig-item{
      border:1px solid #e5e7eb; border-radius:14px; padding:10px 12px; background:#fff;
      box-shadow: 0 1px 0 rgba(0,0,0,.03);
    }
    .cc-mig-row{ display:flex; align-items:flex-start; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .cc-mig-title{ font-weight:700; }
    .cc-badge{ display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; }
    .cc-badge.pending{ background:#ffedd5; color:#92400e; }
    .cc-badge.synced{ background:#d1fae5; color:#065f46; }
    .cc-badge.failed{ background:#fee2e2; color:#991b1b; }
    .cc-mig-meta{ margin-top:6px; color:#6b7280; font-size:12.5px; line-height:1.35; }
    .cc-mig-actions{ margin-top:10px; display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    .cc-mig-actions button{
      border:1px solid rgba(0,0,0,.14);
      background:#fff;
      padding:7px 10px;
      border-radius:10px;
      cursor:pointer;
      font-size:13px;
    }
    .cc-mig-actions button.primary{ border-color: transparent; }
    .cc-mig-actions button.danger{ border-color: transparent; }



    /* Ensure SWOLF info modal always stays on top */
    #swolfInfoOverlay{ z-index: 1100 !important; }
    #swolfInfoModal{ z-index: 1110 !important; }

    /* Scroll fixes: Coach Connector + SWOLF modals (mobile) */
    #coachConnectorModal{
      width: min(820px, 96vw);
      max-height: 90vh;
      padding: 0 !important;
      overflow: hidden;
      display: none;
      flex-direction: column;
    }
    #coachConnectorModal .modal-content{
      width: 100%;
      max-width: none !important;
      max-height: 90vh;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding: 16px;
      box-sizing: border-box;
    }

    #swolfInfoModal{
      width: min(720px, 96vw);
      max-height: 90vh;
      overflow: hidden;
      display: none;
      flex-direction: column;
    }
    #swolfInfoModal .modal-body{
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      flex: 1 1 auto;
      max-height: 76vh;
      padding-right: 6px;
      overscroll-behavior: contain;
    }

    #strokesModal{
      width: min(980px, 96vw);
      max-height: 90vh;
      overflow: hidden;
      display: none;
      flex-direction: column;
    }
    #strokesModal .modal-body{
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      flex: 1 1 auto;
      max-height: 70vh;
      padding-right: 6px;
      overscroll-behavior: contain;
    }
    /* Migration modal / editor constraints on mobile */
    #migrationModal{ width: min(760px, 96vw); }
    #migEditModal{ width: min(760px, 96vw); max-height: 90vh; overflow: hidden; display:none; flex-direction:column; }
    #migEditModal .modal-body{ overflow:auto; flex:1 1 auto; max-height: 68vh; }
    #migEditModal .modal-footer{ background:#fff; border-top:1px solid #e5e7eb; padding-top:12px; margin-top:12px; display:flex; gap:10px; justify-content:flex-end; }
    /* Prevent background scroll when modal open */
    body.modal-open{ overflow:hidden; }



    /* Fix stacked contexts after z-index scaling */
    #strokesModal{ z-index: 1015 !important; }
    #migEditModal{ z-index: 1025 !important; }


  .avg-line{display:block;font-size:.85em;opacity:.85;margin-top:2px;}
  .btn-parcial,.parcial-fixed{white-space:normal;line-height:1.05;}

/* ===== v38-A: Mobile config modal overflow fixes ===== */
@media (max-width: 520px){
  #configModal{
    width: calc(100vw - 16px) !important;
    left: 8px !important;
    top: 8px !important;
    transform: none !important;
    min-width: 0 !important;
    max-height: calc(100vh - 16px) !important;
    padding: 12px !important;
    box-sizing: border-box;
  }
  #configModal .modal-body{
    max-height: calc(100vh - 180px) !important;
    overflow-y: auto !important;
  }
  #configModal .stepper{
    flex-wrap: wrap !important;
    gap: 6px !important;
  }
  #configModal .step{
    flex: 1 1 auto;
    text-align: center;
    padding: 10px 12px;
  }
  #configModal .buttons{
    flex-wrap: wrap !important;
    gap: 8px !important;
  }
}

</style>
</head>
<body>
  <div id="welcomeOverlay"></div>
  <div id="welcomeModal" class="modal">
    <div class="modal-header">
      <h2>MDV SWIM CHRONO</h2>
      <button class="close-btn" id="closeWelcome">&times;</button>
    </div>
    
<div class="modal-body" style="text-align:center;">
  <p style="font-size:1.1rem; line-height:1.5;">
    <strong>MDV SWIM CHRONO</strong><br>
    Desarrollado por el Prof. <strong>Mauro Damián Vorraber</strong><br>
    <em>Todos los derechos reservados - 2025</em><br>
    Distribución bajo licencia privada.
  </p>
  <div style="display:flex;gap:1rem;justify-content:center;margin-top:1.5rem;flex-wrap:wrap;flex-direction:row;flex-shrink:0;">
    <button id="welcomeChrono">Ingresar al Crono</button>
    <button id="welcomeLeame">Leer Instrucciones</button>
    <a href="https://www.instagram.com/prof.mvorraber?igsh=MW81d3ZtNzd6M2lqMw==" target="_blank" class="social-btn">Instagram</a>
    <a href="https://www.mdv-integraltraining.com/" target="_blank" class="social-btn">Sitio Web</a>


<div style="display:flex;flex-direction:column;gap:0.5rem;margin-top:1.5rem;">
  <a href="https://mpago.la/1z2dRnk" target="_blank" class="donate-btn">Apoyar con 5 mil</a>
  <a href="https://mpago.la/2f7a12k" target="_blank" class="donate-btn">Apoyar con 10 mil</a>
  <a href="https://mpago.la/2gCyjhy" target="_blank" class="donate-btn">Apoyar con 20 mil</a>
  <a href="https://link.mercadopago.com.ar/mdvapps" target="_blank" class="donate-btn" style="background:#28a745;color:white;">Elegir otro monto</a>
</div>



  </div>
</div>

  </div>
  
  <div id="licenseOverlay"></div>
  <div id="licenseModal" class="modal">
    <div class="modal-header">
      <h2>Validación de licencia</h2>
      <button class="close-btn" id="licenseClose">&times;</button>
    </div>
    <div class="modal-body">
      <p style="margin-bottom:0.8rem;">
        Ingrese el número de licencia que recibió al adquirir MDV SWIM CHRONO.
      </p>
      <label for="licenseInput" style="display:block;margin-bottom:0.3rem;font-weight:bold;">
        Número de licencia:
      </label>
      <input type="text" id="licenseInput" placeholder="Ej: MDV-ADMIN-XXXX-YYYY-ZZZZ"
             style="width:100%;padding:0.4rem;margin-bottom:0.6rem;box-sizing:border-box;">
      <div id="licenseMessage" style="min-height:1.2rem;font-size:0.9rem;color:#c00;margin-bottom:0.6rem;"></div>
      <div style="display:flex;gap:0.5rem;justify-content:flex-end;flex-wrap:wrap;">
        <button id="licenseExitBtn">Salir</button>
        <button id="licenseValidateBtn">Validar licencia</button>
      </div>
    </div>
  </div>

  <div id="exitOverlay"></div>
  <div id="exitModal" class="modal">
    <div class="modal-header">
      <h2>Salir de la aplicación</h2>
    </div>
    <div class="modal-body">
      <p id="exitMessage" style="margin-bottom:0.8rem;">
        Para utilizar MDV SWIM CHRONO es necesario validar una licencia.
      </p>
      <div style="display:flex;gap:0.5rem;justify-content:flex-end;flex-wrap:wrap;">
        <button id="exitCancelBtn">Volver</button>
        <button id="exitConfirmBtn">Salir</button>
      </div>
    </div>
  </div>

<div id="readmeOverlay"></div>
  <div id="readmeModal" class="modal">
    <div class="modal-header">
      <h2>LEAME</h2>
      <button class="close-btn" id="closeReadme">&times;</button>
    </div>
    <div class="modal-body">
      <p>El cronómetro permite:</p>
      <ul>
        <li>Configurar nombre, distancia y nadadores de cada serie.</li>
        <li>Registrar tiempos parciales y finales para múltiples carriles.</li>
        <li>Mostrar tablas y gráficos con análisis de velocidades.</li>
        <li>Exportar resultados en formato XLS o PDF.</li>
        <li>Guardar y cargar sesiones previamente almacenadas.</li>
      </ul>
      <div style="text-align:right;">
        <button id="readmeBack">Volver</button>
      </div>
    </div>
  </div>
  <div class="toolbar">
    <button id="openConfig">Configurar Serie</button>
    <button id="startBtn" disabled>Iniciar Crono</button>
    <button id="stopBtn" disabled>Detener Crono</button>
    <button id="exportCsvBtn" disabled>Exportar XLS</button>
    <button id="exportPdfBtn" disabled>Exportar PDF</button>
    <button id="resetBtn">Reiniciar</button>
    <button id="helpBtn" title="Ver información e instrucciones">ℹ️</button>
    <button id="coachConnectorBtn" title="Abrir MDV COACH 360º">MDV COACH 360º</button>
    <div class="cc-toggle" title="Atajo ON/OFF del conector (usa los últimos datos guardados)">
      <span class="cc-toggle-text">CONECTOR</span>
      <label class="cc-switch">
        <input type="checkbox" id="ccQuickToggle">
        <span class="cc-slider"></span>
      </label>
    </div>
    <button id="sessionBtn">Sesión</button>
  </div>
  <div class="table-wrapper">
    <table id="laneTable">
      <thead id="laneHead"></thead>
      <tbody id="laneBody"></tbody>
    </table>
  </div>
  <div id="resultsTables" style="display:none"></div>
  <div id="advancedTables"></div>
  <div id="swolfTables" style="display:none"></div>
  <div class="charts-wrapper" style="display:none">
    <div id="charts"><canvas id="partialsChart"></canvas></div>
    <div id="advancedCharts"></div>
  </div>
  <!-- Modal configuración interactiva -->
  <div id="overlay"></div>

  <div id="configModal" class="modal">
    <div class="modal-header">
      <h2>Configurar Serie</h2>
      <button class="close-btn" id="closeConfig">&times;</button>
    </div>
    <div class="modal-body">
      <div class="stepper">
        <div class="step active" data-step="1">Datos Serie</div>
        <div class="step" data-step="2">Nadadores</div>
        <div class="step" data-step="3">Parciales</div>
      </div>
      <div class="form-step active" data-step="1">
        <div class="form-group">
          <label>Nombre de la Serie</label>
          <input type="text" id="serieName" value="Serie 1">
        </div>

        <div class="form-group">
          <label>Piscina (Course)</label>
          <select id="poolCourse">
            <option value="SCM">SCM (25m)</option>
            <option value="LCM">LCM (50m)</option>
            <option value="SCY">SCY (25yd)</option>
          </select>
        </div>

        <div class="form-group">
          <label>Distancia Total (<span id="distUnitLabel">m</span>)</label>
          <input type="number" id="totalDist" value="100">
        </div>
        <div class="form-group">
          <label>Delay Auto-Start (s)</label>
          <input type="number" id="autoDelay" value="3">
        </div>
      </div>
      <div class="form-step" data-step="2">
        <div class="form-group">
          <label>Número de Nadadores</label>
          <input type="number" id="numSwimmers" min="1" value="4">
        </div>
        <div id="swimmersContainer"></div>
      </div>
      <div class="form-step" data-step="3">
        <div class="form-group">
          <label>Cantidad de Parciales</label>
          <input type="number" id="numPartials" min="0" value="2">
        </div>
        <div id="partialsContainer"></div>
<div style="display:flex; justify-content:flex-end; gap:8px; flex-wrap:wrap; margin-top: 1rem;">
  <button id="saveTemplateBtn" style="background:#10b981;color:#fff;padding:0.4rem 1rem;border:none;border-radius:.25rem;cursor:pointer;">
    Guardar Plantilla
  </button>
  <button id="downloadConfigBtn" style="background:#0066cc;color:#fff;padding:0.4rem 1rem;border:none;border-radius:.25rem;cursor:pointer;">
    Descargar Configuración
  </button>
</div>

      </div>
    <div class="buttons">
      <button class="prev" id="prevBtn" disabled>Anterior</button>
      <button class="next" id="nextBtn">Siguiente</button>
    </div>
  </div>
</div>
  
  <!-- Modal final de opciones al concluir la serie -->
  <div id="finalOverlay"></div>

<div id="finalModal" class="modal">
  <div class="modal-header">
    <h2>¿Qué deseas hacer con los resultados?</h2>
    <button class="close-btn" id="closeFinalModal">&times;</button>
  </div>
  <div class="final-options">
    <button id="finalShowTables">Mostrar Tablas</button>
    <button id="finalShowCharts">Generar Gráficos</button>
    <button id="finalExportXLS">Exportar XLS</button>
    <button id="finalExportPDF">Exportar PDF</button>
    <button id="finalBoth">Mostrar Tablas y Gráficos</button>
  </div>
  <div class="final-cancel">
    <button id="cancelFinalModal">Cancelar</button>
  </div>
</div>
  
  
  <!-- Modal conteo de brazadas (SWOLF) -->
  <div id="strokesOverlay"></div>
  <div id="strokesModal" class="modal" style="display:none; max-width: 980px; z-index: 115;">
    <div class="modal-header">
      <h2>Conteo de brazadas (SWOLF)</h2>
      <button class="close-btn" id="closeStrokesModal">&times;</button>
    </div>
    <div class="modal-body">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap;">
        <div style="color:#6b7280; font-size:.95rem;">
          Ingresá el conteo de brazadas por tramo. Se incluye el tramo <b>FINAL</b>.
        </div>
        <button class="info-btn" data-info="swolf" title="¿Qué es SWOLF?">i</button>
      </div>
      <div id="strokesCards" class="cards" style="margin-top:12px;"></div>
      <div style="margin-top:10px; color:#6b7280; font-size:.9rem;">
        SWOLF = <i>segundos del tramo</i> (redondeados) + <i>brazadas</i>.
      </div>
    </div>
    <div class="modal-footer" style="display:flex; justify-content:flex-end; gap:10px;">
      <button class="secondary" id="omitStrokesBtn">Omitir</button>
      <button class="primary" id="saveStrokesBtn">Guardar</button>
    </div>
  </div>

  <!-- Modal info SWOLF -->
  <div id="swolfInfoOverlay"></div>
  <div id="swolfInfoModal" class="modal" style="display:none; max-width: 720px; z-index: 116;">
    <div class="modal-header">
      <h2>Índice SWOLF</h2>
      <button class="close-btn" id="closeSwolfInfo">&times;</button>
    </div>
    <div class="modal-body">
      <p style="margin-top:0;">
        <b>SWOLF</b> (Swim Golf) es un índice práctico de eficiencia en natación. Combina <b>tiempo</b> y <b>brazadas</b>
        en un mismo número para comparar tramos de forma rápida.
      </p>

      <h3 style="margin:.75rem 0 .25rem 0; font-size:1.05rem;">Cómo se calcula</h3>
      <p style="margin:.25rem 0;">
        <code>SWOLF = segundos del tramo (redondeados) + número de brazadas</code>
      </p>
      <p style="margin:.25rem 0; color:#6b7280;">
        En MDV CHRONO el SWOLF se calcula por <b>tramo</b> (P1, P2… y también <b>FINAL</b> si corresponde),
        usando el tiempo de ese tramo y el conteo de brazadas que ingresás.
      </p>

      <h3 style="margin:.9rem 0 .25rem 0; font-size:1.05rem;">Cómo interpretarlo (sin caer en trampas)</h3>
      <ul style="margin:.25rem 0 .25rem 1.1rem;">
        <li><b>Menor SWOLF suele indicar más eficiencia</b>, pero solo si mantenés el <b>ritmo objetivo</b>.</li>
        <li>No sirve “bajar SWOLF” a costa de ir más lento: miralo junto a la <b>velocidad/ritmo</b>.</li>
        <li>Es ideal para comparar <b>repeticiones similares</b> (misma distancia de tramo, misma consigna).</li>
      </ul>

      <h3 style="margin:.9rem 0 .25rem 0; font-size:1.05rem;">Reglas para comparar correctamente</h3>
      <ul style="margin:.25rem 0 .25rem 1.1rem;">
        <li>Compará siempre dentro del <b>mismo estilo</b> (crol vs pecho no son comparables).</li>
        <li>Usá la <b>misma distancia de tramo</b> (típicamente 25 m/yd) y, si es posible, <b>sin aletas</b>.</li>
        <li>Tené en cuenta los <b>virajes</b>: piscina corta/larga y número de vueltas cambian tiempo y brazadas.</li>
        <li>La <b>fatiga</b> cambia el SWOLF: compará series en condiciones similares (calentamiento, carga, descanso).</li>
      </ul>

      <h3 style="margin:.9rem 0 .25rem 0; font-size:1.05rem;">Guía orientativa</h3>
      <p style="margin:.25rem 0; color:#6b7280;">
        Referencia general para <b>25 m/yd, crol, sin aletas</b>. Puede variar mucho por edad, nivel, estilo y contexto.
        Usala como brújula, no como “nota”.
      </p>

      <div style="overflow:auto; border:1px solid #e5e7eb; border-radius:.5rem; margin:.35rem 0;">
        <table style="width:100%; border-collapse:collapse; font-size:.95rem;">
          <thead>
            <tr style="background:#f9fafb;">
              <th style="text-align:left; padding:.5rem .6rem; border-bottom:1px solid #e5e7eb;">Nivel</th>
              <th style="text-align:left; padding:.5rem .6rem; border-bottom:1px solid #e5e7eb;">SWOLF aprox.</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="padding:.5rem .6rem; border-bottom:1px solid #f1f5f9;">Inicial</td>
              <td style="padding:.5rem .6rem; border-bottom:1px solid #f1f5f9;">50+</td>
            </tr>
            <tr>
              <td style="padding:.5rem .6rem; border-bottom:1px solid #f1f5f9;">En progreso</td>
              <td style="padding:.5rem .6rem; border-bottom:1px solid #f1f5f9;">45–50</td>
            </tr>
            <tr>
              <td style="padding:.5rem .6rem; border-bottom:1px solid #f1f5f9;">Intermedio</td>
              <td style="padding:.5rem .6rem; border-bottom:1px solid #f1f5f9;">38–45</td>
            </tr>
            <tr>
              <td style="padding:.5rem .6rem; border-bottom:1px solid #f1f5f9;">Avanzado</td>
              <td style="padding:.5rem .6rem; border-bottom:1px solid #f1f5f9;">32–38</td>
            </tr>
            <tr>
              <td style="padding:.5rem .6rem;">Muy avanzado / competitivo</td>
              <td style="padding:.5rem .6rem;">&lt; 32</td>
            </tr>
          </tbody>
        </table>
      </div>

      <p style="margin:.6rem 0 0 0; color:#6b7280;">
        Tip práctico: elegí un tramo (por ejemplo P1=25 (m/yd)) y mirá cómo evoluciona tu SWOLF a lo largo de la serie.
        Si el SWOLF sube mucho, suele ser señal de fatiga o de pérdida técnica.
      </p>
    </div>
    <div class="modal-footer" style="display:flex; justify-content:flex-end;">
      <button class="primary" id="okSwolfInfo">OK</button>
    </div>
  </div>
<!-- Exportación XLS/PDF submodal -->
  <div id="exportOverlay"></div>
  <div id="exportModal" class="modal">
    <!-- ... (igual que en la V31) ... -->
  </div>
  <!-- Submodal para descarga individual/zip -->
  <div id="downloadOverlay"></div>
  <div id="downloadModal" class="modal">
    <!-- ... (igual que antes) ... -->
  </div>
  <!-- Modal de gestión de sesión/archivo -->
  <div id="sessionOverlay"></div>
  <div id="sessionModal" class="modal">
    <div class="modal-header">
      <h2>Sesión</h2>
      <button class="close-btn" id="closeSession">&times;</button>
    </div>

    <div class="session-tabs">
      <button class="sess-tabbtn active" data-tab="sessions">
        Sesiones ejecutadas <span class="sess-count" id="sessCountSessions"></span>
      </button>
      <button class="sess-tabbtn" data-tab="templates">
        Plantillas <span class="sess-count" id="sessCountTemplates"></span>
      </button>
    </div>

    <div class="session-body" style="max-height:68vh; overflow-y:auto; padding:0.5rem;">
      <div id="sessionTabSessions" class="sess-tab active">
        <div id="sessionSessionsList"></div>
      </div>

      <div id="sessionTabTemplates" class="sess-tab">
        <div style="color:#6b7280; font-size:.9rem; margin:.25rem 0 .5rem 0;">
          Las plantillas guardan <b>solo configuración</b> (no incluyen tiempos). Se guardan manualmente desde <b>Configurar serie</b>.
        </div>
        <div id="sessionTemplatesList"></div>
      </div>

      <hr style="margin:12px 0;">
      <div class="session-actions">
        <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
          <button id="saveSessionBtn">Guardar sesión actual</button>
          <button id="downloadSessionBtn">Descargar sesión actual (.json)</button>
          <button id="btnLoadSessionFile">Cargar sesión desde archivo (.json)</button>
          <input type="file" id="loadSessionFile" accept=".json" style="display:none">
          <button id="btnLoadTemplateFile">Cargar plantilla/config desde archivo (.json)</button>
          <input type="file" id="loadTemplateFile" accept=".json" style="display:none">
          <button id="clearSessionsBtn">Borrar todo (sesiones y plantillas)</button>
        </div>
        <div style="color:#6b7280; font-size:.85rem; margin-top:.35rem;">
          Nota: en la lista de <b>Sesiones</b> solo se muestran series <b>completas</b> (todos los nadadores finalizados).
          Cada sesión puede abrirse completa o cargarse como plantilla.
        </div>
      </div>
    </div>
  </div>
  <script>
document.addEventListener('DOMContentLoaded', function() {

  // ====== VARIABLES Y ESTADO PRINCIPAL ======
const DEFAULT_CONFIG = {
  name: 'Serie 1',
  total: 100,
  delay: 3,
    pool_course: 'SCM',
  partialLabels: ['', ''],
swimmers: [
    { name: 'Swimmer 1', lane: 1, order: 1, advanced: false, strokesEnabled: false, strokeCounts: [], swimmer_id: '' },
    { name: 'Swimmer 2', lane: 2, order: 1, advanced: false, strokesEnabled: false, strokeCounts: [], swimmer_id: '' },
    { name: 'Swimmer 3', lane: 3, order: 2, advanced: false, strokesEnabled: false, strokeCounts: [], swimmer_id: '' },
    { name: 'Swimmer 4', lane: 4, order: 2, advanced: false, strokesEnabled: false, strokeCounts: [], swimmer_id: '' }
  ],
  partials: [ 25, 50 ]
};

let config = JSON.parse(JSON.stringify(DEFAULT_CONFIG));

// ======= UNIDADES / COURSE (SCM / LCM / SCY) =======
const YD_TO_M = 0.9144;

function ensurePoolCourse_(){
  if (!config.pool_course) config.pool_course = 'SCM';
  if (!['SCM','LCM','SCY'].includes(config.pool_course)) config.pool_course = 'SCM';
}

function isSCY_(){
  ensurePoolCourse_();
  return config.pool_course === 'SCY';
}

function distUnitShort_(){
  return isSCY_() ? 'yd' : 'm';
}

function toMeters_(distInUnits){
  const d = Number(distInUnits) || 0;
  return isSCY_() ? d * YD_TO_M : d;
}

function fromMetersToUnits_(meters){
  const m = Number(meters) || 0;
  return isSCY_() ? (m / YD_TO_M) : m;
}

function poolLenUnits_(){
  ensurePoolCourse_();
  return (config.pool_course === 'LCM') ? 50 : 25; // SCM 25m / SCY 25yd
}

function ensurePartialLabels_(){
  if (!Array.isArray(config.partialLabels)) config.partialLabels = [];
  while (config.partialLabels.length < config.partials.length) config.partialLabels.push('');
  if (config.partialLabels.length > config.partials.length) config.partialLabels = config.partialLabels.slice(0, config.partials.length);
}

function escapeHtml_(s){
  return String(s || '').replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[ch]));
}

function syncUnitUI_(){
  const u = distUnitShort_();
  const el = document.getElementById('distUnitLabel');
  if (el) el.textContent = u;
}

function convertConfigDistancesForCourse_(fromCourse, toCourse){
  if (!fromCourse || !toCourse || fromCourse === toCourse) return;
  const wasSCY = (fromCourse === 'SCY');
  const nowSCY = (toCourse === 'SCY');
  const factor = YD_TO_M;
  // Convert keeping physical distance: if moving to SCY => meters -> yards ; if leaving SCY => yards -> meters
  const conv = (v)=>{
    if (v == null) return null;
    const s = String(v).trim();
    if (s === '') return null;
    const n = Number(s.replace(',', '.'));
    if (!Number.isFinite(n)) return null;
    if (!wasSCY && nowSCY) return Math.round((n / factor) * 100) / 100;
    if (wasSCY && !nowSCY) return Math.round((n * factor) * 100) / 100;
    return n;
  };
  config.total = conv(config.total);
  config.partials = (config.partials || []).map(conv);
}

let startTimes = {}, lapTimes = {}, finishTimes = {}, finishedCount = 0;
let masterTimer = null;
let chartInstance = null;
let advChartInstances = [];
let mainChartMaxVel = 0;
let lastExportType = null, lastExportFiles = [];
let toastTimer = null;
let spawnTimeouts = [];

function normalizeConfig(cfg) {
  try {
    cfg.total = Number(cfg.total);
    cfg.delay = Number(cfg.delay);
    if (isNaN(cfg.total) || isNaN(cfg.delay)) return false;
    if (!Array.isArray(cfg.partials)) cfg.partials = [];
    // parciales acumulados: permite null/"" para distancias opcionales
    cfg.partials = cfg.partials.map(p => {
      if (p == null) return null;
      const s = String(p).trim();
      if (s === '') return null;
      const n = Number(s.replace(',', '.'));
      return Number.isFinite(n) ? n : null;
    });
    // validar solo los definidos (estrictamente crecientes)
    let lastKnown = 0;
    for (const p of cfg.partials){
      if (p == null) continue;
      if (!(p > lastKnown && p < cfg.total)) return false;
      lastKnown = p;
    }
    if (!Array.isArray(cfg.swimmers)) cfg.swimmers = [];
    cfg.swimmers = cfg.swimmers.map(sw => {
      sw.lane = Number(sw.lane);
      sw.order = Number(sw.order);
      if (isNaN(sw.lane) || isNaN(sw.order)) throw new Error('NaN');
      sw.advanced = !!sw.advanced;
      sw.strokesEnabled = !!sw.strokesEnabled;
      if (!Array.isArray(sw.strokeCounts)) sw.strokeCounts = [];
      // normalizar valores (acepta coma decimal)
      sw.strokeCounts = sw.strokeCounts.map(v => {
        if (v==null || v==='') return null;
        const n = Number(String(v).trim().replace(',', '.'));
        return (Number.isFinite(n) && n>=0) ? Math.round(n) : null;
      });
      sw.swimmer_id = sw.swimmer_id ? String(sw.swimmer_id) : '';
      return sw;
    });
    cfg.pool_course = (cfg.pool_course || 'SCM');
    if (!['SCM','LCM','SCY'].includes(cfg.pool_course)) cfg.pool_course = 'SCM';
    if (!Array.isArray(cfg.partialLabels)) cfg.partialLabels = [];
    cfg.partialLabels = cfg.partialLabels.map(v => (v==null ? '' : String(v))).slice(0, cfg.partials.length);
    while (cfg.partialLabels.length < cfg.partials.length) cfg.partialLabels.push('');

    return true;
  } catch (e) {
    return false;
  }
}

// ======= SYNC helpers (robust swimmers rendering) =======
function syncSwimmersCount(desiredN) {
  let n = Number(desiredN);
  if (!isFinite(n) || n < 1) n = 1;
  if (n > 50) n = 50;

  if (!Array.isArray(config.swimmers)) config.swimmers = [];
  const out = [];
  for (let i = 0; i < n; i++) {
    const prev = config.swimmers[i] || {};
    out.push({
      name: (prev.name != null && String(prev.name).trim() !== '') ? String(prev.name) : `Swimmer ${i + 1}`,
      lane: isFinite(Number(prev.lane)) ? Number(prev.lane) : (i + 1),
      order: isFinite(Number(prev.order)) ? Number(prev.order) : (Math.floor(i / 2) + 1),
      advanced: !!prev.advanced,
      strokesEnabled: !!prev.strokesEnabled,
      strokeCounts: Array.isArray(prev.strokeCounts) ? prev.strokeCounts.slice() : [],
      swimmer_id: prev.swimmer_id ? String(prev.swimmer_id) : ''
    });
  }
  config.swimmers = out;
  return n;
}

function renderSwimmersSafe() {
  try {
    // Ensure container exists
    if (!swimmersContainer) {
      console.warn('swimmersContainer no existe en el DOM');
      return;
    }
    // Ensure swimmers count based on current input value if needed
    const desired = Number(numSwimmersInput && numSwimmersInput.value) || config.swimmers.length || 1;
    syncSwimmersCount(desired);
    if (numSwimmersInput) numSwimmersInput.value = config.swimmers.length;

    renderSwimmers();
  } catch (err) {
    console.error('Error al renderizar nadadores:', err);
    const msg = 'Error al renderizar la solapa Nadadores (ver consola).';
    if (typeof showToastBanner === 'function') showToastBanner(msg);
    // Fallback simple renderer (sin lista del conector)
    try {
      swimmersContainer.innerHTML = '';
      config.swimmers.forEach((sw, i) => {
        const div = document.createElement('div');
        div.classList.add('form-group');
        div.innerHTML = `
          <label>Swimmer ${i + 1} Nombre:</label>
          <input type='text' class='sw-name' data-i='${i}' value='${escapeHtml_(sw.name||"")}'>
          <label>Carril:</label>
          <input type='number' class='sw-lane' data-i='${i}' value='${sw.lane}'>
          <label>Orden:</label>
          <input type='number' class='sw-order' data-i='${i}' value='${sw.order}'>
          <div class="inline-checks">
  <div class="inline-checks">
  <label><input type="checkbox" class="sw-adv" data-i="${i}" ${sw.advanced ? "checked" : ""} /> Métricas avanzadas</label>
  <label><input type="checkbox" class="sw-strokes" data-i="${i}" ${sw.strokesEnabled ? "checked" : ""} /> Conteo brazadas</label>
</div>
  <label><input type="checkbox" class="sw-strokes" data-i="${i}" ${sw.strokesEnabled ? "checked" : ""} /> Conteo brazadas</label>
</div>
        `;
        swimmersContainer.append(div);
      });
      swimmersContainer.querySelectorAll('.sw-adv').forEach(inp => {
        inp.addEventListener('change', () => { config.swimmers[+inp.dataset.i].advanced = inp.checked; });
      });
          swimmersContainer.querySelectorAll('.sw-strokes').forEach(inp => {
        inp.addEventListener('change', () => { config.swimmers[+inp.dataset.i].strokesEnabled = inp.checked; });
      });
} catch (err2) {
      console.error('Fallback renderSwimmers también falló:', err2);
    }
  }
}


// ======= SELECTORES DE ELEMENTOS =======
const openConfig = document.getElementById('openConfig');
const startBtn = document.getElementById('startBtn');
const stopBtn  = document.getElementById('stopBtn');
const exportCsvBtn = document.getElementById('exportCsvBtn');
const exportPdfBtn = document.getElementById('exportPdfBtn');
const resetBtn = document.getElementById('resetBtn');
const laneHead = document.getElementById('laneHead');
const laneBody = document.getElementById('laneBody');
const laneTable = document.getElementById('laneTable');
const resultsTables = document.getElementById('resultsTables');
const chartsDiv = document.getElementById('charts');
const chartsWrapper = document.querySelector('.charts-wrapper');
const configModal = document.getElementById('configModal');
const overlay = document.getElementById('overlay');
const closeConfig = document.getElementById('closeConfig');
const steps = document.querySelectorAll('.step');
const formSteps = document.querySelectorAll('.form-step');
// Permitir navegación al hacer clic en cada paso
steps.forEach(step => {
  step.addEventListener('click', () => {
    currentStep = Number(step.dataset.step);
    updateSteps();
  });
});
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const swimmersContainer = document.getElementById('swimmersContainer');
const partialsContainer = document.getElementById('partialsContainer');
let partialsChartCanvas = document.getElementById('partialsChart');
    if (!partialsChartCanvas) return;
    if (!partialsChartCanvas.height || partialsChartCanvas.height < 150) partialsChartCanvas.height = 260;
const numSwimmersInput = document.getElementById('numSwimmers');
const numPartialsInput = document.getElementById('numPartials');
// Final modal
const finalOverlay = document.getElementById('finalOverlay');
const finalModal = document.getElementById('finalModal');
const closeFinalModal = document.getElementById('closeFinalModal');
const cancelFinalModal = document.getElementById('cancelFinalModal');
const finalShowTables = document.getElementById('finalShowTables');
const finalShowCharts = document.getElementById('finalShowCharts');
const finalExportXLS = document.getElementById('finalExportXLS');
const finalExportPDF = document.getElementById('finalExportPDF');
const finalBoth = document.getElementById('finalBoth');
// Submodales export
const exportOverlay = document.getElementById('exportOverlay');
const exportModal = document.getElementById('exportModal');
const exportOptions = document.getElementById('exportOptions');
const exportForm = document.getElementById('exportForm');
const exportCancel = document.getElementById('exportCancel');
const exportConfirm = document.getElementById('exportConfirm');
const closeExportModal = document.getElementById('closeExportModal');
// Submodal descarga
const downloadOverlay = document.getElementById('downloadOverlay');
const downloadModal = document.getElementById('downloadModal');
const downloadIndiv = document.getElementById('downloadIndiv');
const downloadZip = document.getElementById('downloadZip');
// Avanzados
const advancedTablesDiv = document.getElementById('advancedTables');
const advancedChartsDiv = document.getElementById('advancedCharts');
// SWOLF / Brazadas
const swolfTablesDiv = document.getElementById('swolfTables');
const strokesOverlay = document.getElementById('strokesOverlay');
const strokesModal = document.getElementById('strokesModal');
const strokesCards = document.getElementById('strokesCards');
const closeStrokesModalBtn = document.getElementById('closeStrokesModal');
const omitStrokesBtn = document.getElementById('omitStrokesBtn');
const saveStrokesBtn = document.getElementById('saveStrokesBtn');
const swolfInfoOverlay = document.getElementById('swolfInfoOverlay');
const swolfInfoModal = document.getElementById('swolfInfoModal');
const closeSwolfInfoBtn = document.getElementById('closeSwolfInfo');
const okSwolfInfoBtn = document.getElementById('okSwolfInfo');
// SESIONES
const sessionBtn = document.getElementById('sessionBtn');
const sessionOverlay = document.getElementById('sessionOverlay');
const sessionModal = document.getElementById('sessionModal');
const closeSession = document.getElementById('closeSession');
const sessCountSessions = document.getElementById('sessCountSessions');
const sessCountTemplates = document.getElementById('sessCountTemplates');
const sessionSessionsList = document.getElementById('sessionSessionsList');
const sessionTemplatesList = document.getElementById('sessionTemplatesList');
const saveSessionBtn = document.getElementById('saveSessionBtn');
const downloadSessionBtn = document.getElementById('downloadSessionBtn');
const btnLoadSessionFile = document.getElementById('btnLoadSessionFile');
const loadSessionFile = document.getElementById('loadSessionFile');
const btnLoadTemplateFile = document.getElementById('btnLoadTemplateFile');
const loadTemplateFile = document.getElementById('loadTemplateFile');
const clearSessionsBtn = document.getElementById('clearSessionsBtn');
const toastBanner = document.getElementById('toastBanner');
// Bienvenida
const welcomeOverlay = document.getElementById('welcomeOverlay');
const welcomeModal = document.getElementById('welcomeModal');
const welcomeChrono = document.getElementById('welcomeChrono');
const welcomeLeame = document.getElementById('welcomeLeame');
const closeWelcome = document.getElementById('closeWelcome');
const readmeOverlay = document.getElementById('readmeOverlay');
const readmeModal = document.getElementById('readmeModal');
const closeReadme = document.getElementById('closeReadme');
const readmeBack = document.getElementById('readmeBack');

// ====== LICENCIAS Y VALIDACIÓN REMOTA (Apps Script) ======
const LICENSE_API_URL = 'https://script.google.com/macros/s/AKfycbwjGyy6sOT0o6fYlVOkCCvA_Cp3HWxVCdsfMB9vsQJkcx-xLIxLhMXoJfpsyE2ARw8s/exec'; // TODO: reemplazar por tu URL real

function getOrCreateDeviceId() {
  try {
    let id = localStorage.getItem('mdvDeviceId');
    if (!id) {
      if (window.crypto && crypto.randomUUID) {
        id = crypto.randomUUID();
      } else {
        id = 'mdv-' + Math.random().toString(36).slice(2) + Date.now();
      }
      localStorage.setItem('mdvDeviceId', id);
    }
    return id;
  } catch (e) {
    // Como fallback devolvemos una cadena fija (no ideal, pero evita romper la app)
    return 'mdv-unknown-device';
  }
}

function isLicenseValidLocally() {
  try {
    const key = localStorage.getItem('mdvLicenseKey');
    if (!key) return false;
    const expRaw = localStorage.getItem('mdvLicenseExpiresAt');
    if (!expRaw) return true; // sin fecha asumimos vigente
    const expDate = new Date(expRaw);
    if (isNaN(expDate.getTime())) return false;
    const now = new Date();
    const ok = expDate >= now;
    if (ok) {
      let attrs = {};
      try { attrs = JSON.parse(localStorage.getItem('mdvLicenseAttrs')||'{}')||{}; } catch(e) { attrs = {}; }
      window.__mdvLicense = { key, expiresAt: expRaw||null, attrs };
    }
    return ok;
  } catch (e) {
    return false;
  }
}

function normalizeLicenseApiResponse(result){
  // Acepta respuestas {ok:true}, {status:"ok"}, {valid:true}, {success:true}
  if (!result || typeof result !== 'object') {
    return { ok:false, status:'error', error:'INVALID_RESPONSE', message:'Respuesta inválida del servidor.' };
  }
  const status = String(result.status || '').toLowerCase();
  const ok = (result.ok === true) || (status === 'ok') || (result.valid === true) || (result.success === true);
  const out = Object.assign({}, result);
  out.ok = ok;

  // Normaliza campos frecuentes
  if (!out.expiresAt && out.expires_at) out.expiresAt = out.expires_at;
  if (!out.expiresAt && out.expiration) out.expiresAt = out.expiration;
  if (!out.error && out.code) out.error = out.code;
  if (!out.message && out.msg) out.message = out.msg;

  return out;
}

function licenseErrorMsgFromResult(result){
  // 1) Mensaje explícito del servidor
  if (result && typeof result === 'object') {
    if (result.message) return String(result.message);
    if (result.msg) return String(result.msg);
  }
  // 2) Mapeo por códigos esperados
  const code = (result && typeof result === 'object') ? (result.error || result.code || '') : '';
  switch (code) {
    case 'NO_LICENSE_OR_DEVICE': return 'Faltan datos de licencia o dispositivo.';
    case 'LICENSE_NOT_FOUND': return 'Licencia no encontrada.';
    case 'LICENSE_NOT_ACTIVE': return 'Licencia inactiva.';
    case 'LICENSE_EXPIRED': return 'Licencia expirada.';
    case 'INVALID_EXPIRATION_DATE': return 'La licencia tiene una fecha de expiración inválida.';
    case 'LICENSE_ALREADY_USED_ON_ANOTHER_DEVICE': return 'Licencia ya usada en otro dispositivo.';
    case 'LICENSE_SHEET_NOT_FOUND': return 'Servidor: hoja de licencias no encontrada.';
    case 'LICENSE_SHEET_MISSING_COLUMNS': return 'Servidor: hoja de licencias sin columnas requeridas.';
    default: return 'Licencia no válida.';
  }
}

async function probeLicenseHealth(){
  try{
    const url = LICENSE_API_URL + '?action=health&_t=' + Date.now();
    const resp = await fetch(url, {method:'GET', cache:'no-store'});
    const text = await resp.text();
    if (!resp.ok) throw new Error('HTTP_'+resp.status+' '+text.slice(0,200));
    let json;
    try{ json = JSON.parse(text); }catch(e){ json = null; }
    if (json && (json.ok === true || String(json.status||'').toLowerCase()==='ok')) return json;
    return json;
  }catch(e){
    console.warn('License health failed:', e);
    if (typeof showToastBanner === 'function') showToastBanner('Servidor de licencias no disponible');
    return null;
  }
}

async function validateLicenseRemote(licenseKey) {
  const deviceId = getOrCreateDeviceId();

  // Enviamos parámetros redundantes para compatibilidad con distintos scripts
  const qp = new URLSearchParams();
  qp.set('action', 'validate');
  qp.set('license', licenseKey);
  qp.set('license_key', licenseKey);
  qp.set('key', licenseKey);
  qp.set('deviceId', deviceId);
  qp.set('device_id', deviceId);
  qp.set('_t', String(Date.now()));

  const url = LICENSE_API_URL + '?' + qp.toString();

  const resp = await fetch(url, { method: 'GET', cache: 'no-store' });
  const text = await resp.text();

  if (!resp.ok) {
    throw new Error('HTTP_' + resp.status + ' ' + text.slice(0, 200));
  }

  let json;
  try {
    json = JSON.parse(text);
  } catch (e) {
    throw new Error('INVALID_JSON ' + text.slice(0, 200));
  }

  return normalizeLicenseApiResponse(json);
}

const licenseOverlay = document.getElementById('licenseOverlay');
const licenseModal = document.getElementById('licenseModal');
const licenseInput = document.getElementById('licenseInput');
const licenseMessage = document.getElementById('licenseMessage');
const licenseValidateBtn = document.getElementById('licenseValidateBtn');
const licenseClose = document.getElementById('licenseClose');
const licenseExitBtn = document.getElementById('licenseExitBtn');
const exitOverlay = document.getElementById('exitOverlay');
const exitModal = document.getElementById('exitModal');
const exitMessage = document.getElementById('exitMessage');
const exitConfirmBtn = document.getElementById('exitConfirmBtn');
const exitCancelBtn = document.getElementById('exitCancelBtn');
const welcomeExitBtn = document.getElementById('welcomeExitBtn');

function performExit() {
  if (window.navigator && navigator.app && navigator.app.exitApp) {
    navigator.app.exitApp();
  } else if (window.close) {
    window.close();
  }
}

function showExitModal(message) {
  if (exitMessage && message) exitMessage.textContent = message;
  if (exitOverlay) exitOverlay.style.display = 'block';
  if (exitModal) exitModal.style.display = 'block';
}

function hideExitModal() {
  if (exitOverlay) exitOverlay.style.display = 'none';
  if (exitModal) exitModal.style.display = 'none';
}


function openLicenseModal() {
  if (!licenseOverlay || !licenseModal) {
    hideWelcome();
    return;
  }
  if (licenseInput) {
    const stored = localStorage.getItem('mdvLicenseKey');
    if (stored) licenseInput.value = stored;
    else licenseInput.value = '';
  }
  if (licenseMessage) licenseMessage.textContent = '';

  // Smoke test no bloqueante
  if (typeof probeLicenseHealth === 'function') {
    try { probeLicenseHealth(); } catch(e) {}
  }

  licenseOverlay.style.display = 'block';
  licenseModal.style.display = 'block';
}

function closeLicenseModal() {
  if (licenseOverlay) licenseOverlay.style.display = 'none';
  if (licenseModal) licenseModal.style.display = 'none';
}

async function handleLicenseValidation() {
  const key = (licenseInput && licenseInput.value) ? licenseInput.value.trim() : '';
  if (!key) {
    const msg = 'Por favor ingrese una licencia.';
    if (licenseMessage) licenseMessage.textContent = msg;
    if (typeof showToastBanner === 'function') showToastBanner(msg);
    return;
  }

  if (licenseValidateBtn) licenseValidateBtn.disabled = true;
  if (licenseMessage) licenseMessage.textContent = 'Validando licencia...';

  try {
    const result = await validateLicenseRemote(key);

    if (result.ok) {
      localStorage.setItem('mdvLicenseKey', key);
      if (result.expiresAt) {
        localStorage.setItem('mdvLicenseExpiresAt', result.expiresAt);
      } else {
        localStorage.removeItem('mdvLicenseExpiresAt');
      }
      try { localStorage.setItem('mdvLicenseAttrs', JSON.stringify(result.attrs || {})); } catch (e) {}

      if (licenseMessage) licenseMessage.textContent = '';
      if (typeof showToastBanner === 'function') showToastBanner('Licencia validada');
      closeLicenseModal();
      hideWelcome();
      return;
    }

    const msg = licenseErrorMsgFromResult(result);
    if (licenseMessage) licenseMessage.textContent = msg;

    const code = (result && (result.error || result.code)) ? String(result.error || result.code) : '';
    if (typeof showToastBanner === 'function') {
      showToastBanner('Licencia: ' + msg + (code ? (' [' + code + ']') : ''));
    }
    console.warn('Licencia inválida - respuesta servidor:', result);

  } catch (err) {
    console.error('Error validando licencia:', err);
    const msg = 'No se pudo conectar al servidor de licencias. Intente nuevamente.';
    if (licenseMessage) licenseMessage.textContent = msg;
    if (typeof showToastBanner === 'function') showToastBanner(msg);
  } finally {
    if (licenseValidateBtn) licenseValidateBtn.disabled = false;
  }
}

if (licenseValidateBtn) {
  licenseValidateBtn.addEventListener('click', function() {
    try {
      handleLicenseValidation();
    } catch (err) {
      console.error('Error inesperado en validación de licencia:', err);
      const msg = 'Error interno al validar. Abrí la consola (F12) para ver detalles.';
      if (licenseMessage) licenseMessage.textContent = msg;
      if (typeof showToastBanner === 'function') showToastBanner(msg);
    }
  });
}

if (licenseClose) {
  licenseClose.addEventListener('click', function() {
    showExitModal('Para utilizar MDV SWIM CHRONO es obligatorio validar una licencia.');
  });
}
if (licenseOverlay) {
  licenseOverlay.addEventListener('click', function(e) {
    // Evitamos cerrar el modal haciendo clic en el fondo
    e.stopPropagation();
  });
}

if (licenseExitBtn) {
  licenseExitBtn.addEventListener('click', function() {
    performExit();
  });
}

if (exitConfirmBtn) {
  exitConfirmBtn.addEventListener('click', function() {
    performExit();
  });
}
if (exitCancelBtn) {
  exitCancelBtn.addEventListener('click', function() {
    // Volver: simplemente cerramos el mensaje emergente y regresamos a la pantalla anterior
    hideExitModal();
  });
}
if (exitOverlay) {
  exitOverlay.addEventListener('click', function(e) {
    // Si se toca fuera del modal de salida, no hacemos nada (evita cerrar por accidente)
    e.stopPropagation();
  });
}

// ====== FIN BLOQUE LICENCIAS ======

// Escape básico para inyectar valores en HTML (atributos/innerHTML)
function escapeHtml_(value) {
  const s = String(value ?? '');
  return s.replace(/[&<>"'`]/g, ch => ({
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  }[ch] || ch));
}




function resetEnvironment() {
  clearInterval(masterTimer);
  masterTimer = null;
  clearSpawnTimeouts();

  // Restablecer config y estado interno
  config = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
  populateModal();
  init(); // reinicia estructuras internas

  // ====== LIMPIEZA VISUAL (CANVA EN BLANCO) ======
  try {
    if (laneHead) laneHead.innerHTML = '';
    if (laneBody) laneBody.innerHTML = '';
    if (laneTable) laneTable.style.display = 'none';
    if (resultsTables) resultsTables.innerHTML = '';
    if (advancedTablesDiv) advancedTablesDiv.innerHTML = '';
    if (swolfTablesDiv) { swolfTablesDiv.innerHTML = ''; swolfTablesDiv.style.display = 'none'; }
    if (chartsDiv) chartsDiv.style.display = 'none';
    const rp = document.getElementById('readyPanel');
    if (rp) { rp.innerHTML = ''; rp.style.display = 'none'; }
  } catch (err) {}

  startBtn.disabled = !validateConfig();
  stopBtn.disabled = true;
  exportCsvBtn.disabled = true;
  exportPdfBtn.disabled = true;
  showToastBanner('Reiniciado.');
}


function showToastBanner(msg) {
  toastBanner.textContent = msg;
  toastBanner.style.display = 'block';
  toastBanner.style.opacity = '1';
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => {
    toastBanner.style.opacity = '0';
    setTimeout(() => { toastBanner.style.display = 'none'; }, 300);
  }, 2000);
}

function clearSpawnTimeouts() {
  spawnTimeouts.forEach(clearTimeout);
  spawnTimeouts = [];
}

function showWelcome() {
  welcomeOverlay.style.display = 'block';
  welcomeModal.style.display = 'block';
}

function hideWelcome() {
  welcomeOverlay.style.display = 'none';
  welcomeModal.style.display = 'none';
}

function showReadme() {
  hideWelcome();
  readmeOverlay.style.display = 'block';
  readmeModal.style.display = 'block';
}

function hideReadme() {
  readmeOverlay.style.display = 'none';
  readmeModal.style.display = 'none';
  // Al cerrar el LEEME volvemos a la pantalla de bienvenida
  showWelcome();
}

// =========== PERSISTENCIA LOCAL: SESIONES (RESULTADOS) y PLANTILLAS ===========
const LS_LAST_SESSION_KEY = 'mdv_chrono_last_session_key_v2'; // última sesión completa guardada
const LS_LAST_CONFIG_KEY  = 'mdv_chrono_last_config_v1';      // última config confirmada (para reabrir la app)
const LS_SESSION_UI_TAB   = 'mdv_chrono_session_ui_tab_v1';

function safeJsonParse_(s, fallback = null){
  try { return JSON.parse(s); } catch(e){ return fallback; }
}

function sessionHasAnyResults_(d){
  if (!d) return false;
  const ft = d.finishTimes || {};
  for (const k in ft){
    const n = (typeof ft[k] === 'number') ? ft[k] : Number(ft[k]);
    if (Number.isFinite(n) && n > 0) return true;
  }
  const lt = d.lapTimes || {};
  for (const k in lt){
    const arr = lt[k];
    if (Array.isArray(arr) && arr.some(v => {
      const n = (typeof v === 'number') ? v : Number(v);
      return Number.isFinite(n) && n > 0;
    })) return true;
  }
  return false;
}

function isCompleteSession_(d){
  if (!d || !d.config) return false;
  const n = Array.isArray(d.config.swimmers) ? d.config.swimmers.length : 0;
  if (!n) return false;
  const ft = d.finishTimes || {};
  for (let i = 0; i < n; i++){
    const v = ft[i];
    const ms = (typeof v === 'number') ? v : Number(v);
    if (!Number.isFinite(ms) || ms <= 0) return false;
  }
  return true;
}

function isCurrentResultsComplete_(){
  const n = Array.isArray(config.swimmers) ? config.swimmers.length : 0;
  if (!n) return false;
  for (let i = 0; i < n; i++){
    const ms = finishTimes ? finishTimes[i] : null;
    if (!(typeof ms === 'number' && Number.isFinite(ms) && ms > 0)) return false;
  }
  return true;
}

function anySwolfInConfig_(cfg){
  try {
    const sws = (cfg && Array.isArray(cfg.swimmers)) ? cfg.swimmers : [];
    return sws.some(sw => {
      if (!sw) return false;
      if (sw.strokesEnabled) return true;
      if (Array.isArray(sw.strokeCounts) && sw.strokeCounts.some(v => v != null && v !== '' && Number.isFinite(Number(v)))) return true;
      return false;
    });
  } catch(e){ return false; }
}

function formatDateTime_(iso){
  try {
    const d = new Date(iso);
    if (isNaN(d.getTime())) return '';
    const pad = (n)=> String(n).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  } catch(e){ return ''; }
}

function buildConfigSummary_(cfg){
  if (!cfg) return '';
  const total = Number(cfg.total);
  const nSw = Array.isArray(cfg.swimmers) ? cfg.swimmers.length : 0;
  const nP = Array.isArray(cfg.partials) ? cfg.partials.length : 0;
  const tramos = nP + 1;
  const swolf = anySwolfInConfig_(cfg) ? 'SWOLF: Sí' : 'SWOLF: No';
  const dist = Number.isFinite(total) ? `${total}m` : '';
  return [dist, `${nSw} nad.`, `${tramos} tramos`, swolf].filter(Boolean).join(' • ');
}

function prepareLapTimesForSave() {
  const sanitized = {};
  const expected = config.partials.length;
  for (let i = 0; i < config.swimmers.length; i++) {
    let laps = Array.isArray(lapTimes[i]) ? lapTimes[i].slice(0, expected) : [];
    if (finishTimes[i] != null && laps.length === expected - 1) {
      laps.push(finishTimes[i]);
    }
    while (laps.length < expected) laps.push(null);
    sanitized[i] = laps;
  }
  return sanitized;
}

function trimLapTimes(obj) {
  const trimmed = {};
  const expected = config.partials.length;
  Object.keys(obj || {}).forEach(i => {
    trimmed[i] = Array.isArray(obj[i]) ? obj[i].slice(0, expected) : [];
  });
  return trimmed;
}

function storeLastConfig_(){
  try { localStorage.setItem(LS_LAST_CONFIG_KEY, JSON.stringify(config)); } catch(e) {}
}

function saveExecutedSessionToLocal_(label = null, forceKey = null) {
  const key = forceKey || ('Sesion_' + Date.now());
  const nowIso = new Date().toISOString();
  const d = {
    kind: 'session',
    stage: 'results',
    label: (label != null && String(label).trim() !== '') ? String(label).trim() : null,
    config: JSON.parse(JSON.stringify(config)),
    startTimes: JSON.parse(JSON.stringify(startTimes || {})),
    lapTimes: prepareLapTimesForSave(),
    finishTimes: JSON.parse(JSON.stringify(finishTimes || {})),
    createdAt: nowIso,
    updatedAt: nowIso
  };
  localStorage.setItem(key, JSON.stringify(d));
  try { localStorage.setItem(LS_LAST_SESSION_KEY, key); } catch(e) {}
  renderSessionUI_();
  return key;
}

function saveTemplateToLocal_(cfg, label = null, legacy = false) {
  const key = 'Plantilla_' + Date.now();
  const nowIso = new Date().toISOString();
  const d = {
    kind: 'template',
    stage: 'template',
    legacy: !!legacy,
    label: (label != null && String(label).trim() !== '') ? String(label).trim() : null,
    config: JSON.parse(JSON.stringify(cfg || config)),
    createdAt: nowIso,
    updatedAt: nowIso
  };
  localStorage.setItem(key, JSON.stringify(d));
  renderSessionUI_('templates');
  return key;
}

function loadSessionFromLocal(key, mode = 'full') {
  const d = safeJsonParse_(localStorage.getItem(key) || 'null', null);
  if (!d) return;

  // Backward compatibility / schema fixups
  if (typeof d.config === 'string') {
    try { d.config = JSON.parse(d.config); } catch (e) {}
  }
  d.startTimes = d.startTimes || d.start_times || d.starts || {};
  d.finishTimes = d.finishTimes || d.finish_times || d.finishes || {};
  d.lapTimes = d.lapTimes || d.lap_times || d.laps || {};

  // If stored as arrays (older versions), convert to {index: []}
  if (Array.isArray(d.startTimes)) {
    const o = {}; d.startTimes.forEach((v,i)=>o[i]=v); d.startTimes = o;
  }
  if (Array.isArray(d.finishTimes)) {
    const o = {}; d.finishTimes.forEach((v,i)=>o[i]=v); d.finishTimes = o;
  }
  if (Array.isArray(d.lapTimes)) {
    const o = {}; d.lapTimes.forEach((v,i)=>o[i]=v); d.lapTimes = o;
  }

  const toMs = (v) => {
    if (typeof v === 'number' && Number.isFinite(v)) return v;
    if (typeof v === 'string') {
      const trimmed = v.trim();
      const n = Number(trimmed);
      if (Number.isFinite(n)) return n;
      if (trimmed.includes(':')) {
        const ms = parseTimeToMs_(trimmed);
        if (Number.isFinite(ms) && ms >= 0) return ms;
      }
    }
    return null;
  };

  // Normalize lap arrays to numbers (preservando huecos)
  if (d.lapTimes && typeof d.lapTimes === 'object') {
    Object.keys(d.lapTimes).forEach(k => {
      const arr = d.lapTimes[k];
      if (!Array.isArray(arr)) { d.lapTimes[k] = []; return; }
      d.lapTimes[k] = arr.map(toMs);
    });
  }
  if (d.finishTimes && typeof d.finishTimes === 'object') {
    Object.keys(d.finishTimes).forEach(k => {
      const ms = toMs(d.finishTimes[k]);
      d.finishTimes[k] = (typeof ms === 'number') ? ms : null;
    });
  }

  // Cargar configuración
  const nextCfg = d.config || d;
  if (!normalizeConfig(nextCfg)) {
    showToastBanner('Configuración inválida');
    return;
  }
  config = nextCfg;

  // Forzar modo plantilla (solo config)
  if (mode === 'template') {
    startTimes = {};
    lapTimes = {};
    finishTimes = {};
    finishedCount = 0;
    init();
    populateModal();
    clearChartsForNewConfig_();
    prepareReadyAfterConfig_();
    storeLastConfig_();
    showToastBanner('Configuración cargada. Listo para iniciar.');
    startBtn.disabled = !validateConfig();
    return;
  }

  // Modo FULL: cargar tiempos si existen
  startTimes = d.startTimes || {};
  lapTimes = trimLapTimes(d.lapTimes || {});
  finishTimes = d.finishTimes || {};
  finishedCount = Object.keys(finishTimes).filter(i => finishTimes[i] != null).length;

  const hasResults = sessionHasAnyResults_(d);
  const stage = (String(d.stage || '')).toLowerCase();

  if (!hasResults || stage === 'config') {
    // configuración sin resultados
    startTimes = {};
    lapTimes = {};
    finishTimes = {};
    finishedCount = 0;

    init();
    populateModal();
    clearChartsForNewConfig_();
    prepareReadyAfterConfig_();
    storeLastConfig_();
    showToastBanner('Configuración cargada. Listo para iniciar.');
    startBtn.disabled = !validateConfig();
    return;
  }

  try { renderAll(); } catch (err) {
    console.error('renderAll failed:', err);
    try { init(); populateModal(); renderResultsTables(); } catch(e) {}
  }
  storeLastConfig_();
  showToastBanner('Sesión cargada correctamente');
  startBtn.disabled = !validateConfig();
}
window.loadSessionFromLocal = loadSessionFromLocal;

function loadTemplateFromLocal_(key){
  loadSessionFromLocal(key, 'template');
}

function downloadJson_(obj, filename){
  const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename || 'mdv.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function downloadStoredKey_(key){
  const d = safeJsonParse_(localStorage.getItem(key) || 'null', null);
  if (!d) return;
  const name = (d.label || (d.config && d.config.name) || key || 'registro').toString().trim().replace(/[^\w\-]+/g,'_');
  const suffix = (String(d.kind||'') === 'template' || String(d.stage||'') === 'template') ? '_plantilla' : '_sesion';
  downloadJson_(d, `${name}${suffix}.json`);
}

function downloadCurrentSessionFile_() {
  const data = {
    kind: 'session',
    stage: sessionHasAnyResults_({finishTimes, lapTimes}) ? 'results' : 'config',
    config,
    startTimes,
    lapTimes: prepareLapTimesForSave(),
    finishTimes,
    date: new Date().toISOString()
  };
  const fname = ((config && config.name) ? config.name : 'sesion').toString().trim().replace(/[^\w\-]+/g,'_') + '.json';
  downloadJson_(data, fname);
}

function downloadCurrentConfigFile_(){
  // Captura config actual (sin resultados)
  const data = { kind:'template', stage:'template', config: JSON.parse(JSON.stringify(config)), date: new Date().toISOString() };
  const fname = ((config && config.name) ? config.name : 'config').toString().trim().replace(/[^\w\-]+/g,'_') + '_config.json';
  downloadJson_(data, fname);
}

function clearAllSessionsAndTemplates_() {
  const keys = Object.keys(localStorage);
  keys.forEach(k => {
    if (k.startsWith('Sesion_') || k.startsWith('Plantilla_')) localStorage.removeItem(k);
  });
  renderSessionUI_();
}

function setActiveSessionTab_(tab){
  const t = (tab === 'templates') ? 'templates' : 'sessions';
  try { localStorage.setItem(LS_SESSION_UI_TAB, t); } catch(e) {}
  const btns = Array.from(sessionModal.querySelectorAll('.sess-tabbtn') || []);
  btns.forEach(b => b.classList.toggle('active', b.dataset.tab === t));

  const a = document.getElementById('sessionTabSessions');
  const b = document.getElementById('sessionTabTemplates');
  if (a) a.classList.toggle('active', t === 'sessions');
  if (b) b.classList.toggle('active', t === 'templates');
}

function renderSessionUI_(forceTab = null) {
  if (!sessionModal) return;

  const tab = forceTab || (safeJsonParse_(localStorage.getItem(LS_SESSION_UI_TAB) || 'null', 'sessions') || 'sessions');
  setActiveSessionTab_(tab);

  if (sessionSessionsList) sessionSessionsList.innerHTML = '';
  if (sessionTemplatesList) sessionTemplatesList.innerHTML = '';

  // Collect keys
  const allKeys = Object.keys(localStorage);
  const sessionKeys = allKeys.filter(k => k.startsWith('Sesion_'));
  const templateKeys = allKeys.filter(k => k.startsWith('Plantilla_'));

  // Parse records
  const sessions = [];
  const templates = [];

  // Sessions (solo completas)
  sessionKeys.forEach(k => {
    const d = safeJsonParse_(localStorage.getItem(k) || 'null', null);
    if (!d) return;

    // Backward: si era plantilla antigua, lo movemos a templates (se mostrará como legacy)
    const stage = (String(d.stage||'')).toLowerCase();
    const isTemplateLike = (d.asTemplate === true) || stage === 'template' || stage === 'config' || !sessionHasAnyResults_(d);
    if (isTemplateLike && !isCompleteSession_(d)) {
      templates.push({ key: k, d: Object.assign({ legacy:true, kind:'template', stage:'template' }, d) });
      return;
    }

    if (!isCompleteSession_(d)) return; // solo completas
    sessions.push({ key: k, d });
  });

  // Templates reales
  templateKeys.forEach(k => {
    const d = safeJsonParse_(localStorage.getItem(k) || 'null', null);
    if (!d) return;
    templates.push({ key: k, d: Object.assign({ kind:'template', stage:'template' }, d) });
  });

  // Sort by updatedAt/createdAt desc (más reciente arriba)
  const byRecency = (a,b) => {
    const ad = a.d.updatedAt || a.d.createdAt || a.d.date || '';
    const bd = b.d.updatedAt || b.d.createdAt || b.d.date || '';
    return new Date(bd) - new Date(ad);
  };
  sessions.sort(byRecency);
  templates.sort(byRecency);

  // Counts
  if (sessCountSessions) sessCountSessions.textContent = sessions.length ? String(sessions.length) : '0';
  if (sessCountTemplates) sessCountTemplates.textContent = templates.length ? String(templates.length) : '0';

  // Render sessions
  if (sessionSessionsList) {
    if (!sessions.length) {
      sessionSessionsList.innerHTML = '<em>No hay sesiones completas guardadas</em>';
    } else {
      sessions.forEach(({key, d}) => {
        const cfg = d.config || {};
        const title = (d.label || cfg.name || key).toString();
        const when = formatDateTime_(d.createdAt || d.date || '');
        const sum = buildConfigSummary_(cfg);

        const card = document.createElement('div');
        card.className = 'sess-card';
        card.innerHTML = `
          <div class="sess-top">
            <div class="sess-title">${escapeHtml_(title)}</div>
            <div class="sess-badges">
              <span class="badge session">Resultados</span>
              <span class="sess-muted">${escapeHtml_(when)}</span>
            </div>
          </div>
          <div class="sess-muted" style="margin-top:.2rem;">${escapeHtml_(sum)}</div>
          <div class="sess-actions-row">
            <button data-action="open" data-key="${escapeHtml_(key)}">Abrir sesión</button>
            <button data-action="asTemplate" data-key="${escapeHtml_(key)}">Usar configuración</button>
            <button data-action="download" data-key="${escapeHtml_(key)}">Descargar</button>
            <button data-action="delete" data-key="${escapeHtml_(key)}">Eliminar</button>
          </div>
        `;
        sessionSessionsList.appendChild(card);
      });
    }
  }

  // Render templates
  if (sessionTemplatesList) {
    if (!templates.length) {
      sessionTemplatesList.innerHTML = '<em>No hay plantillas guardadas</em>';
    } else {
      templates.forEach(({key, d}) => {
        const cfg = d.config || {};
        const title = (d.label || cfg.name || key).toString();
        const when = formatDateTime_(d.createdAt || d.date || '');
        const sum = buildConfigSummary_(cfg);

        const card = document.createElement('div');
        card.className = 'sess-card';
        const legacy = (key.startsWith('Sesion_') && !key.startsWith('Plantilla_')) || d.legacy;
        const badge = legacy ? '<span class="badge legacy">Legacy</span>' : '<span class="badge template">Plantilla</span>';
        card.innerHTML = `
          <div class="sess-top">
            <div class="sess-title">${escapeHtml_(title)}</div>
            <div class="sess-badges">
              ${badge}
              <span class="sess-muted">${escapeHtml_(when)}</span>
            </div>
          </div>
          <div class="sess-muted" style="margin-top:.2rem;">${escapeHtml_(sum)}</div>
          <div class="sess-actions-row">
            <button data-action="loadTemplate" data-key="${escapeHtml_(key)}">Cargar plantilla</button>
            <button data-action="download" data-key="${escapeHtml_(key)}">Descargar</button>
            <button data-action="delete" data-key="${escapeHtml_(key)}">Eliminar</button>
          </div>
        `;
        sessionTemplatesList.appendChild(card);
      });
    }
  }

  // Delegación de eventos dentro del modal
  const handler = (ev) => {
    const btn = ev.target && ev.target.closest ? ev.target.closest('button[data-action]') : null;
    if (!btn) return;
    const action = btn.dataset.action;
    const key = btn.dataset.key;
    if (!key) return;

    if (action === 'open') {
      loadSessionFromLocal(key, 'full');
      closeSessionModal_();
    } else if (action === 'asTemplate') {
      loadSessionFromLocal(key, 'template');
      closeSessionModal_();
    } else if (action === 'loadTemplate') {
      loadTemplateFromLocal_(key);
      closeSessionModal_();
    } else if (action === 'download') {
      downloadStoredKey_(key);
    } else if (action === 'delete') {
      if (confirm('¿Eliminar este registro?')) {
        localStorage.removeItem(key);
        renderSessionUI_();
      }
    }
  };

  if (sessionSessionsList) {
    sessionSessionsList.onclick = handler;
  }
  if (sessionTemplatesList) {
    sessionTemplatesList.onclick = handler;
  }
}
window.renderSessionUI_ = renderSessionUI_;

function openSessionModal_(){
  try {
    renderSessionUI_();
  } catch (err) {
    console.error('openSessionModal_ failed:', err);
    showToastBanner('Error al abrir Sesión (ver consola).');
    return;
  }
  if (sessionOverlay) sessionOverlay.style.display = 'block';
  if (sessionModal) sessionModal.style.display = 'block';
}

function closeSessionModal_(){
  sessionOverlay.style.display = 'none';
  sessionModal.style.display = 'none';
}

// Modal de sesión: open/close y tabs
if (sessionBtn) sessionBtn.onclick = openSessionModal_;
if (closeSession) closeSession.onclick = closeSessionModal_;
if (sessionOverlay) sessionOverlay.onclick = closeSessionModal_;

if (sessionModal) {
  sessionModal.addEventListener('click', (e) => {
    const tb = e.target && e.target.closest ? e.target.closest('.sess-tabbtn[data-tab]') : null;
    if (!tb) return;
    setActiveSessionTab_(tb.dataset.tab);
  });
}

if (clearSessionsBtn) clearSessionsBtn.onclick = () => {
  if (confirm('¿Borrar TODAS las sesiones y plantillas guardadas?')) clearAllSessionsAndTemplates_();
};

if (saveSessionBtn) saveSessionBtn.onclick = () => {
  if (!isCurrentResultsComplete_()) {
    showToastBanner('Para guardar una sesión debe estar completa (todos finalizados).');
    return;
  }
  const label = prompt('Nombre para la sesión (opcional):', (config && config.name) ? config.name : '');
  saveExecutedSessionToLocal_(label);
  showToastBanner('Sesión guardada');
};

if (downloadSessionBtn) downloadSessionBtn.onclick = downloadCurrentSessionFile_;

if (btnLoadSessionFile && loadSessionFile) btnLoadSessionFile.onclick = () => loadSessionFile.click();
if (btnLoadTemplateFile && loadTemplateFile) btnLoadTemplateFile.onclick = () => loadTemplateFile.click();

if (loadSessionFile) loadSessionFile.onchange = function(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(ev) {
    try {
      const obj = JSON.parse(ev.target.result);
      // Si no tiene resultados completos, lo tratamos como plantilla (pero avisamos).
      if (obj && obj.config) {
        const tmp = { config: obj.config, finishTimes: obj.finishTimes || {}, lapTimes: obj.lapTimes || {} };
        if (!isCompleteSession_(Object.assign({config: obj.config}, obj))) {
          config = obj.config || obj;
          if (!normalizeConfig(config)) { showToastBanner('Configuración inválida'); return; }
          init();
          populateModal();
          clearChartsForNewConfig_();
          prepareReadyAfterConfig_();
          storeLastConfig_();
          showToastBanner('Archivo sin sesión completa: cargado como plantilla.');
          startBtn.disabled = !validateConfig();
          return;
        }
      }
      // Cargar full
      config = obj.config || obj;
      if (!normalizeConfig(config)) { showToastBanner('Configuración inválida'); return; }
      startTimes = obj.startTimes || {};
      lapTimes = trimLapTimes(obj.lapTimes || {});
      finishTimes = obj.finishTimes || {};
      try { renderAll(); } catch (err) {
        console.error('renderAll failed:', err);
        try { init(); populateModal(); renderResultsTables(); } catch(e) {}
      }
      storeLastConfig_();
      showToastBanner('Sesión cargada desde archivo');
      startBtn.disabled = !validateConfig();
    } catch (err) {
      alert('Error al cargar el archivo');
    }
  };
  reader.readAsText(file);
  e.target.value = '';
};

if (loadTemplateFile) loadTemplateFile.onchange = function(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(ev) {
    try {
      const obj = JSON.parse(ev.target.result);
      config = obj.config || obj;
      if (!normalizeConfig(config)) { showToastBanner('Configuración inválida'); return; }
      init();
      populateModal();
      clearChartsForNewConfig_();
      prepareReadyAfterConfig_();
      storeLastConfig_();
      showToastBanner('Plantilla cargada desde archivo');
      startBtn.disabled = !validateConfig();
    } catch (err) {
      alert('Error al cargar la plantilla');
    }
  };
  reader.readAsText(file);
  e.target.value = '';
};

// Intentar recuperar la última configuración confirmada (si existe)
try {
  const lastCfg = safeJsonParse_(localStorage.getItem(LS_LAST_CONFIG_KEY) || 'null', null);
  if (lastCfg && normalizeConfig(lastCfg)) {
    config = lastCfg;
    ensurePoolCourse_();
    ensurePartialLabels_();

  }
} catch(e) {}

// ========== FORMATO DE TIEMPO ==========

function format(ms) {
  const cs = Math.floor(ms / 10) % 100,
        s = Math.floor(ms / 1000) % 60,
        m = Math.floor(ms / 60000);
  return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${cs.toString().padStart(2, '0')}`;
}// ========== MODAL DE CONFIGURACIÓN DE SERIE ==========
let currentStep = 1;
function showModal() {
  currentStep = 1;
  overlay.style.display = 'block';
  configModal.style.display = 'block';
  populateModal();
  updateSteps();
}
function hideModal() { overlay.style.display = 'none'; configModal.style.display = 'none'; }
openConfig.addEventListener('click', showModal);

// pool course change => update units + keep physical distances
document.addEventListener('change', (e) => {
  const t = e && e.target;
  if (!t) return;
  if (t.id === 'poolCourse') {
    const prev = (config.pool_course || 'SCM');
    const next = (t.value || 'SCM');
    if (prev !== next) {
      convertConfigDistancesForCourse_(prev, next);
      config.pool_course = next;
      // reflect in UI
      const totalEl = document.getElementById('totalDist');
      if (totalEl) totalEl.value = config.total;
      ensurePartialLabels_();
      renderPartials();
      // update suggested partials max? keep existing
      syncUnitUI_();
    }
  }
});


closeConfig.addEventListener('click', hideModal);
overlay.addEventListener('click', hideModal);
document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && configModal.style.display === 'block') hideModal(); });
function updateSteps() {
  steps.forEach(s => s.classList.toggle('active', +s.dataset.step === currentStep));
  formSteps.forEach(f => f.classList.toggle('active', +f.dataset.step === currentStep));
  prevBtn.disabled = currentStep === 1;
  nextBtn.textContent = currentStep === steps.length ? 'Guardar' : 'Siguiente';

  if (currentStep === 2) { renderSwimmersSafe(); }

  // Al entrar al paso de parciales, refrescar UI (mobile-friendly)
  if (currentStep === 3 && numPartialsInput) {
    handleNumPartialsChange({ target: numPartialsInput });
  }
}
prevBtn.addEventListener('click', () => { if (currentStep > 1) currentStep--; updateSteps(); });
nextBtn.addEventListener('click', () => {
  if (currentStep < steps.length) { currentStep++; updateSteps(); }
  else {
    let ok = false;
    try { ok = saveConfig(); }
    finally { hideModal(); startBtn.disabled = !ok; }
  }
});
function populateModal() {
  try {
    document.getElementById('serieName').value = config.name;
    document.getElementById('totalDist').value = config.total;
    document.getElementById('autoDelay').value = config.delay;

    

    ensurePoolCourse_();
    ensurePartialLabels_();
    const pcSel = document.getElementById('poolCourse');
    if (pcSel) pcSel.value = config.pool_course;
    syncUnitUI_();
// swimmers (robust)
    // if config.swimmers viene vacío por localStorage/config vieja, usamos el valor del input o default
    const desired = Number(numSwimmersInput && numSwimmersInput.value) || (Array.isArray(config.swimmers) ? config.swimmers.length : 0) || 4;
    syncSwimmersCount(desired);
    if (numSwimmersInput) numSwimmersInput.value = config.swimmers.length;
    renderSwimmersSafe();

    // partials
    numPartialsInput.value = config.partials.length;
    renderPartials();
    updateSteps();
  } catch (err) {
    console.error('populateModal error:', err);
    if (typeof showToastBanner === 'function') showToastBanner('Error al cargar configuración (ver consola).');
  }
}

function renderSwimmers() {
  swimmersContainer.innerHTML = '';

  const cc = (window.__mdvCoachConnector && window.__mdvCoachConnector.enabled) ? window.__mdvCoachConnector : null;
  const hasList = !!(cc && Array.isArray(cc.swimmers) && cc.swimmers.length);

  config.swimmers.forEach((sw, i) => {
    const div = document.createElement('div');
    div.classList.add('form-group');

    // build name field
    let nameField = '';
    if (hasList) {
      const options = cc.swimmers
        .map(s => ({
          id: String(s.swimmer_id || s.id || '').trim(),
          name: String(s.name || s.nombre || s.swimmer_name || s.full_name || s.display_name || '').trim()
        }))
        .filter(o => o.id && o.name)
        .sort((a, b) => a.name.localeCompare(b.name, 'es'));

      const currentId = String(sw.swimmer_id || '').trim();
      const currentName = String(sw.name || '').trim();

      // Try to preserve a previous selection: prefer swimmer_id, otherwise match by name
      const selectedId = (currentId && options.some(o => o.id === currentId))
        ? currentId
        : ((!currentId && currentName) ? ((options.find(o => o.name === currentName) || {}).id || '') : '');

      const manualVisible = !selectedId && !!currentName;

      nameField = `
        <label>Swimmer ${i + 1} Nombre:</label>
        <select class="sw-name-select" data-i="${i}">
          <option value="">(Elegir nadador)</option>
          ${options.map(o => `<option value="${escapeHtml_(o.id)}" ${o.id===selectedId?'selected':''}>${escapeHtml_(o.name)}</option>`).join('')}
          <option value="__manual__" ${manualVisible?'selected':''}>— Manual —</option>
        </select>
        <input type="text" class="sw-name sw-name-manual" data-i="${i}" value="${escapeHtml_(currentName)}" style="margin-top:.4rem;display:${manualVisible?'block':'none'}" placeholder="Nombre manual">
        <div class="sw-id-row" style="font-size:12px; opacity:.75; margin-top:.25rem; display:${(selectedId||currentId)?'block':'none'};">ID: <span class="sw-id" data-i="${i}">${escapeHtml_(selectedId||currentId||'')}</span></div>
      `;
    } else {
      nameField = `
        <label>Swimmer ${i + 1} Nombre:</label>
        <input type='text' class='sw-name' data-i='${i}' value='${escapeHtml_(sw.name||"")}'>
      `;
    }

    div.innerHTML = `
      ${nameField}
      <label>Carril:</label>
      <input type='number' class='sw-lane' data-i='${i}' value='${sw.lane}'>
      <label>Orden:</label>
      <input type='number' class='sw-order' data-i='${i}' value='${sw.order}'>
      <div class="inline-checks">
  <label><input type="checkbox" class="sw-adv" data-i="${i}" ${sw.advanced ? "checked" : ""} /> Métricas avanzadas</label>
  <label><input type="checkbox" class="sw-strokes" data-i="${i}" ${sw.strokesEnabled ? "checked" : ""} /> Conteo brazadas</label>
</div>
    `;
    swimmersContainer.append(div);
  });


  // helper: evita duplicados en selects del conector (mismo nadador en 2 posiciones)
  function updateSwimmerSelectDisabled() {
    const selects = Array.from(swimmersContainer.querySelectorAll('.sw-name-select'));
    const selected = new Set();
    selects.forEach(s => {
      const v = (s.value || '').trim();
      if (v && v !== '__manual__') selected.add(v);
      // inicializa prevValue si no existe
      if (typeof s.dataset.prevValue === 'undefined' || s.dataset.prevValue === null) {
        s.dataset.prevValue = v || '';
      }
    });

    selects.forEach(s => {
      const current = (s.value || '').trim();
      Array.from(s.options).forEach(opt => {
        const v = (opt.value || '').trim();
        if (!v || v === '__manual__') { opt.disabled = false; return; }
        opt.disabled = selected.has(v) && v !== current;
      });
    });
  }


  // listeners
  swimmersContainer.querySelectorAll('.sw-adv').forEach(inp => {
    inp.addEventListener('change', e => { config.swimmers[+inp.dataset.i].advanced = inp.checked; });
  });
  swimmersContainer.querySelectorAll('.sw-strokes').forEach(inp => {
    inp.addEventListener('change', e => { config.swimmers[+inp.dataset.i].strokesEnabled = inp.checked; });
  });
  swimmersContainer.querySelectorAll('.sw-name').forEach(inp => {
    inp.addEventListener('input', e => {
      const i = +inp.dataset.i;
      config.swimmers[i].name = inp.value;
      if (inp.classList.contains('sw-name-manual')) {
        config.swimmers[i].swimmer_id = '';
        const idRow = swimmersContainer.querySelector(`.sw-id-row .sw-id[data-i="${i}"]`);
        if (idRow && idRow.parentElement) idRow.parentElement.style.display = 'none';
      }
    });
  });
  swimmersContainer.querySelectorAll('.sw-lane').forEach(inp => {
    inp.addEventListener('input', e => { config.swimmers[+inp.dataset.i].lane = +inp.value || 1; });
  });
  swimmersContainer.querySelectorAll('.sw-order').forEach(inp => {
    inp.addEventListener('input', e => { config.swimmers[+inp.dataset.i].order = +inp.value || 1; });
  });

  // connector-select behavior
  swimmersContainer.querySelectorAll('.sw-name-select').forEach(sel => {
    sel.addEventListener('change', e => {
      const i = +sel.dataset.i;
      const v = (sel.value || '').trim();
      const prev = (sel.dataset.prevValue || '').trim();
      const manualInp = swimmersContainer.querySelector(`.sw-name-manual[data-i="${i}"]`);
      const idSpan = swimmersContainer.querySelector(`.sw-id[data-i="${i}"]`);
      const idRow = idSpan ? idSpan.parentElement : null;

      // evita elegir el mismo nadador en dos posiciones distintas
      if (v && v !== '__manual__') {
        const dup = Array.from(swimmersContainer.querySelectorAll('.sw-name-select'))
          .some(other => other !== sel && ((other.value || '').trim() === v));
        if (dup) {
          const msg = 'Ese nadador ya está asignado en otra posición. Elegí otro o usá “— Manual —”.';
          console.warn('[CoachConnector] Duplicado swimmer_id:', v);
          if (typeof showToastBanner === 'function') showToastBanner(msg);
          // restaura el valor anterior
          sel.value = prev || '';
          updateSwimmerSelectDisabled();
          return;
        }
      }

      if (v === '__manual__') {
        config.swimmers[i].swimmer_id = '';
        if (idRow) idRow.style.display = 'none';
        if (manualInp) {
          manualInp.style.display = 'block';
          manualInp.focus();
        }
        // el nombre se toma del campo manual (listener .sw-name)
      } else if (!v) {
        // sin selección
        config.swimmers[i].swimmer_id = '';
        if (idRow) idRow.style.display = 'none';
        if (manualInp) manualInp.style.display = 'none';
      } else {
        const selectedName = (sel.options[sel.selectedIndex] && sel.options[sel.selectedIndex].textContent) ? sel.options[sel.selectedIndex].textContent.trim() : '';
        config.swimmers[i].swimmer_id = v;
        config.swimmers[i].name = selectedName;

        if (manualInp) {
          manualInp.style.display = 'none';
          manualInp.value = selectedName;
        }
        if (idSpan) {
          idSpan.textContent = v;
          if (idRow) idRow.style.display = 'block';
        }
      }

      // guarda para poder revertir en caso de duplicado
      sel.dataset.prevValue = (sel.value || '').trim();
      updateSwimmerSelectDisabled();
    });
  });

  // aplica al render inicial
  updateSwimmerSelectDisabled();
}
function renderPartials()
{
  partialsContainer.innerHTML = '';
  ensurePoolCourse_();
  ensurePartialLabels_();
  const unit = distUnitShort_();
  const totalEl = document.getElementById('totalDist');
  const total = +((totalEl && totalEl.value) || config.total || 0);
  const maxAttr = (isFinite(total) && total > 0) ? ` max="${total}"` : '';

  config.partials.forEach((acc, i) =>
  {
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.gap = '8px';
    row.style.alignItems = 'center';
    row.style.flexWrap = 'wrap';
    row.style.rowGap = '6px';
    row.style.margin = '8px 0';

    row.innerHTML = `
      <div style="width:80px; font-weight:700">P${i+1}</div>
      <input type='number' step='0.1' min='0'${maxAttr} class='pt-dist' data-i='${i}' value='${acc}' style='width:96px; padding:6px; border:1px solid #d1d5db; border-radius:10px;'>
      <span style="opacity:.8">${unit}</span>
      <input type='text' class='pt-label' data-i='${i}' value='${config.partialLabels[i] || ""}' placeholder='Etiqueta opcional (ej: Salida)' style='flex:1; min-width:140px; padding:6px; border:1px solid #d1d5db; border-radius:10px;'>
    `;
    partialsContainer.appendChild(row);
  });
}

function handleNumSwimmersChange(e) {
  const n = Number(e && e.target ? e.target.value : 0);
  syncSwimmersCount(n);
  renderSwimmersSafe();
}

function handleNumPartialsChange(e) {
  const requestedRaw = +((e && e.target && e.target.value) || 0);
  const requested = Math.max(0, Math.min(50, Math.round(requestedRaw)));

  ensurePoolCourse_();
  const totalEl = document.getElementById('totalDist');
  const total = +((totalEl && totalEl.value) || config.total || 0);
  const step = poolLenUnits_();

  // cantidad de "bordes de largo" disponibles antes del final (ej: 50m en SCM => [25] => 1)
  const maxLengthBoundaries = Math.max(0, Math.floor((total - 1e-9) / step));
  const underwaterMode = requested > maxLengthBoundaries;

  // si cambia el modo (largos vs subacuáticos), regeneramos defaults
  const prevMode = config._partialsMode || null;
  const nextMode = underwaterMode ? 'under' : 'length';
  const modeChanged = (prevMode && prevMode !== nextMode);
  config._partialsMode = nextMode;

  // preservar valores existentes solo si no cambiamos de modo
  let current = [];
  if (!modeChanged) {
    try {
      const domVals = [];
      document.querySelectorAll('.pt-dist').forEach(inp => {
        const i = +inp.dataset.i;
        const v = +inp.value;
        if (isFinite(i) && i >= 0) domVals[i] = v;
      });
      if (domVals.some(v => v != null && v !== '')) current = domVals;
    } catch (err) {}
    if (!current.length) current = (config.partials || []).slice();
  }

  // sanitizar
  current = (current || [])
    .map(v => +v)
    .filter(v => isFinite(v) && v > 0 && v < total)
    .sort((a, b) => a - b);

  // construir candidatos por modo
  const candidates = [];
  if (!underwaterMode) {
    for (let k = 1; k <= requested; k++) {
      const acc = step * k;
      if (acc >= total) break;
      candidates.push(+acc.toFixed(2));
    }
  } else {
    // defaults para subacuáticos: 12.5 (si cabe) + fin de largo
    let under = 12.5;
    if (!isFinite(under) || under <= 0) under = step / 2;
    if (under >= step) under = step / 2;

    for (let pos = 0; pos < total; pos += step) {
      const a = pos + under;
      const b = pos + step;
      if (a < total) candidates.push(+a.toFixed(2));
      if (b < total) candidates.push(+b.toFixed(2));
    }
  }

  // generar nueva lista de parciales acumulados (SIEMPRE respetando la cantidad pedida)
  let partials = [];
  if (!modeChanged && current.length) {
    if (requested <= current.length) {
      partials = current.slice(0, requested);
    } else {
      partials = current.slice();
      let prev = partials.length ? partials[partials.length - 1] : 0;

      // completar con candidatos > prev
      for (let i = 0; i < candidates.length && partials.length < requested; i++) {
        const c = +candidates[i];
        if (isFinite(c) && c > prev + 1e-6 && c < total) {
          partials.push(c);
          prev = c;
        }
      }

      // si aún faltan, repartir equiespaciado entre prev y total
      if (partials.length < requested && total > prev) {
        const remain = requested - partials.length;
        for (let k = 1; k <= remain; k++) {
          const v = prev + (total - prev) * (k / (remain + 1));
          if (v > prev + 1e-6 && v < total) partials.push(+v.toFixed(2));
        }
      }
    }
  } else {
    // modo nuevo o sin datos: usar defaults desde cero
    partials = candidates.slice(0, requested);

    // completar si los candidatos no alcanzan
    if (partials.length < requested && total > 0) {
      let prev = partials.length ? partials[partials.length - 1] : 0;
      const remain = requested - partials.length;
      for (let k = 1; k <= remain; k++) {
        const v = prev + (total - prev) * (k / (remain + 1));
        if (v > prev + 1e-6 && v < total) partials.push(+v.toFixed(2));
      }
    }
  }

  // normalizar: estrictamente crecientes y < total
  partials = (partials || [])
    .map(v => +v)
    .filter(v => isFinite(v) && v > 0 && v < total)
    .sort((a, b) => a - b)
    .filter((v, i, arr) => i === 0 || v > arr[i - 1] + 1e-6)
    .slice(0, requested);

  // si por algún motivo aún faltan (total muy chico), completar con spacing global
  while (partials.length < requested && total > 0) {
    const n = partials.length + 1;
    const v = total * (n / (requested + 1));
    if (v > 0 && v < total) partials.push(+v.toFixed(2));
    partials = partials
      .sort((a, b) => a - b)
      .filter((x, i, arr) => i === 0 || x > arr[i - 1] + 1e-6)
      .slice(0, requested);
    if (partials.length >= requested) break;
    // evitar loops infinitos por total minúsculo
    if (requested > 0 && total < 0.5) break;
  }

  config.partials = partials;
  ensurePartialLabels_();
  renderPartials();
}

// Validación básica de configuración
function validateConfig() {
  const total = Number(config.total || 0);
  if (!Number.isFinite(total) || total <= 0) return false;

  const parts = Array.isArray(config.partials) ? config.partials : [];
  let lastKnown = 0;
  for (let i = 0; i < parts.length; i++) {
    const p = parts[i];
    if (p == null || String(p).trim() === '') continue; // distancia opcional
    const n = Number(String(p).trim().replace(',', '.'));
    if (!Number.isFinite(n)) return false;
    if (!(n > lastKnown && n < total)) return false;
    lastKnown = n;
  }
  return true;
}
function saveConfig() {
  try {
    config.name = document.getElementById('serieName').value;
    config.total = +document.getElementById('totalDist').value;
    config.delay = +document.getElementById('autoDelay').value;
    const pcSel = document.getElementById('poolCourse');
    if (pcSel) config.pool_course = (pcSel.value || 'SCM');
    ensurePoolCourse_();
    document.querySelectorAll('.sw-name').forEach(inp => config.swimmers[+inp.dataset.i].name = inp.value);
    document.querySelectorAll('.sw-lane').forEach(inp => config.swimmers[+inp.dataset.i].lane = +inp.value);
    document.querySelectorAll('.sw-order').forEach(inp => config.swimmers[+inp.dataset.i].order = +inp.value);
    document.querySelectorAll('.sw-adv').forEach(inp => config.swimmers[+inp.dataset.i].advanced = inp.checked);
    document.querySelectorAll('.sw-strokes').forEach(inp => config.swimmers[+inp.dataset.i].strokesEnabled = inp.checked);
    document.querySelectorAll('.pt-dist').forEach(inp => {
      const i = +inp.dataset.i;
      const raw = (inp.value==null ? '' : String(inp.value)).trim();
      if (raw === '') { config.partials[i] = null; return; }
      const n = Number(raw.replace(',', '.'));
      config.partials[i] = Number.isFinite(n) ? n : null;
    });
    ensurePartialLabels_();
    document.querySelectorAll('.pt-label').forEach(inp => config.partialLabels[+inp.dataset.i] = (inp.value || '').trim());
    ensurePartialLabels_();
    if (!validateConfig()) {
      if (typeof showToastBanner === 'function') showToastBanner('Parciales inválidos');
      startBtn.disabled = true;
      return false;
    }
    // No renderizar tabla de parciales todavía: mostrar panel 'listo'
    clearChartsForNewConfig_();
    prepareReadyAfterConfig_();
    storeLastConfig_();;
    return true;
  } catch(err) {
    console.error('saveConfig error:', err && err.message ? err.message : err, err);
    let msg = 'Error al guardar configuraci\u00f3n';
    if (err && err.message && err.message.toLowerCase().includes('chart')) {
      msg = 'Error al inicializar los gr\u00e1ficos';
    } else if (err && err.name && err.name.toLowerCase().includes('quota')) {
      msg = 'Error guardando en almacenamiento local';
    }
    if (typeof showToastBanner === 'function') showToastBanner(msg);
    return false;
  }
}

function captureConfigFromModal_(){
  const cfg = JSON.parse(JSON.stringify(config || {}));

  const nameEl  = document.getElementById('serieName');
  const totalEl = document.getElementById('totalDist');
  const delayEl = document.getElementById('autoDelay');
  const pcSel   = document.getElementById('poolCourse');

  cfg.name  = (nameEl ? nameEl.value : (cfg.name || 'Serie')).toString().trim() || (cfg.name || 'Serie');
  cfg.total = totalEl ? +totalEl.value : (+cfg.total || 0);
  cfg.delay = delayEl ? +delayEl.value : (+cfg.delay || 0);

  cfg.pool_course = (pcSel ? (pcSel.value || 'SCM') : (cfg.pool_course || 'SCM'));
  if (!['SCM','LCM','SCY'].includes(cfg.pool_course)) cfg.pool_course = 'SCM';

  const nSw = numSwimmersInput ? (+numSwimmersInput.value || 0) : (Array.isArray(cfg.swimmers) ? cfg.swimmers.length : 0);
  if (!Array.isArray(cfg.swimmers)) cfg.swimmers = [];
  while (cfg.swimmers.length < nSw){
    cfg.swimmers.push({ name:'', lane:1, order:1, advanced:false, strokesEnabled:false, strokeCounts: [], swimmer_id: '' });
  }
  cfg.swimmers = cfg.swimmers.slice(0, nSw);

  document.querySelectorAll('.sw-name').forEach(inp => {
    const i = +inp.dataset.i;
    if (!cfg.swimmers[i]) cfg.swimmers[i] = { name:'', lane:1, order:1, advanced:false, strokesEnabled:false, strokeCounts: [], swimmer_id: '' };
    cfg.swimmers[i].name = inp.value;
  });
  document.querySelectorAll('.sw-lane').forEach(inp => {
    const i = +inp.dataset.i;
    if (!cfg.swimmers[i]) cfg.swimmers[i] = { name:'', lane:1, order:1, advanced:false, strokesEnabled:false, strokeCounts: [], swimmer_id: '' };
    cfg.swimmers[i].lane = +inp.value;
  });
  document.querySelectorAll('.sw-order').forEach(inp => {
    const i = +inp.dataset.i;
    if (!cfg.swimmers[i]) cfg.swimmers[i] = { name:'', lane:1, order:1, advanced:false, strokesEnabled:false, strokeCounts: [], swimmer_id: '' };
    cfg.swimmers[i].order = +inp.value;
  });
  document.querySelectorAll('.sw-adv').forEach(inp => {
    const i = +inp.dataset.i;
    if (!cfg.swimmers[i]) cfg.swimmers[i] = { name:'', lane:1, order:1, advanced:false, strokesEnabled:false, strokeCounts: [], swimmer_id: '' };
    cfg.swimmers[i].advanced = !!inp.checked;
  });
  document.querySelectorAll('.sw-strokes').forEach(inp => {
    const i = +inp.dataset.i;
    if (!cfg.swimmers[i]) cfg.swimmers[i] = { name:'', lane:1, order:1, advanced:false, strokesEnabled:false, strokeCounts: [], swimmer_id: '' };
    cfg.swimmers[i].strokesEnabled = !!inp.checked;
  });

  const nP = numPartialsInput ? (+numPartialsInput.value || 0) : (Array.isArray(cfg.partials) ? cfg.partials.length : 0);
  if (!Array.isArray(cfg.partials)) cfg.partials = [];
  while (cfg.partials.length < nP) cfg.partials.push(0);
  cfg.partials = cfg.partials.slice(0, nP);

  document.querySelectorAll('.pt-dist').forEach(inp => {
    const i = +inp.dataset.i;
    if (i >= 0 && i < cfg.partials.length) cfg.partials[i] = +inp.value;
  });

  if (!Array.isArray(cfg.partialLabels)) cfg.partialLabels = [];
  document.querySelectorAll('.pt-label').forEach(inp => {
    const i = +inp.dataset.i;
    cfg.partialLabels[i] = (inp.value || '').trim();
  });
  cfg.partialLabels = cfg.partialLabels.map(v => (v==null ? '' : String(v))).slice(0, cfg.partials.length);
  while (cfg.partialLabels.length < cfg.partials.length) cfg.partialLabels.push('');

  return cfg;
}


function getAllPartialsArr() {
  const parts = Array.isArray(config.partials) ? config.partials : [];
  const total = Number(config.total || 0);
  if (!parts.length) return [];

  const isNum = (v) => (v != null && String(v).trim() !== '' && Number.isFinite(Number(String(v).trim().replace(',', '.'))));
  const toNum = (v) => Number(String(v).trim().replace(',', '.'));

  const arr = [];

  // Distancia de tramo (D) por "última distancia conocida" (ignora parciales sin A definida)
  for (let j = 0; j < parts.length; j++){
    const curr = isNum(parts[j]) ? toNum(parts[j]) : null;
    if (curr == null) { arr.push(null); continue; }

    let prevKnown = 0;
    for (let k = j - 1; k >= 0; k--){
      if (isNum(parts[k])) { prevKnown = toNum(parts[k]); break; }
    }
    const d = curr - prevKnown;
    arr.push(Number.isFinite(d) ? d : null);
  }

  // FINAL: desde última distancia conocida hasta total
  let lastKnown = 0;
  for (let k = parts.length - 1; k >= 0; k--){
    if (isNum(parts[k])) { lastKnown = toNum(parts[k]); break; }
  }
  if (Number.isFinite(total) && total > 0){
    const dFinal = total - lastKnown;
    arr.push(Number.isFinite(dFinal) ? dFinal : null);
  } else {
    arr.push(null);
  }
  return arr;
}

function init() {
  mainChartMaxVel = 0; // reset before any early exit
  clearInterval(masterTimer);
  masterTimer = null;
  clearSpawnTimeouts();
  // Encabezado: Distancia de cada parcial + el final
  const parcialesArr = getAllPartialsArr();
  const hdrs = ['Nombre', 'Carril', 'Orden', 'Timer'];
  const parts = Array.isArray(config.partials) ? config.partials : [];
  const isNumP = (v)=> (v!=null && String(v).trim()!=='' && Number.isFinite(Number(String(v).trim().replace(',', '.'))));
  const toNumP = (v)=> Number(String(v).trim().replace(',', '.'));

  for (let i=0;i<parts.length;i++){
    const curr = isNumP(parts[i]) ? toNumP(parts[i]) : null;

    let prevKnown = 0;
    for (let k=i-1;k>=0;k--){
      if (isNumP(parts[k])) { prevKnown = toNumP(parts[k]); break; }
    }

    const dist = (curr!=null) ? (curr - prevKnown) : null;
    hdrs.push(partialLabelHtml_(i+1, dist, curr));
  }

  const total = Number(config.total||0);
  let lastKnown = 0;
  for (let k=parts.length-1;k>=0;k--){
    if (isNumP(parts[k])) { lastKnown = toNumP(parts[k]); break; }
  }
  const finalDist = (Number.isFinite(total) && total>0) ? Math.max(0, total - lastKnown) : null;
  hdrs.push(finalLabelHtml_(finalDist, total));
  laneHead.innerHTML = '<tr>' + hdrs.map(h => `<th>${h}</th>`).join('') + '</tr>';
  laneBody.innerHTML = '';
  startTimes = {};
  lapTimes = {};
  finishTimes = {};
  finishedCount = 0;
  chartsWrapper.style.display = 'none';
  chartsDiv.style.display = 'none';
  advancedTablesDiv.style.display = 'none';
  advancedTablesDiv.innerHTML = '';
  advancedChartsDiv.style.display = 'none';
  advancedChartsDiv.innerHTML = '';
  resultsTables.style.display = 'none';
  resultsTables.innerHTML = '';
  if (swolfTablesDiv){ swolfTablesDiv.style.display='none'; swolfTablesDiv.innerHTML=''; }
  exportCsvBtn.disabled = true;
  exportPdfBtn.disabled = true;
  stopBtn.disabled = true;
  if (chartInstance) {
    try {
      chartInstance.destroy();
    } catch (err) {
      console.error('Chart destroy failed', err);
      const newCanvas = partialsChartCanvas.cloneNode(false);
      partialsChartCanvas.parentNode.replaceChild(newCanvas, partialsChartCanvas);
      partialsChartCanvas = newCanvas;
    }
    chartInstance = null;
  }
  advChartInstances.forEach(inst => {
    try { inst.destroy(); } catch (err) { console.error('Adv chart destroy failed', err); }
  });
  advChartInstances = [];
  mainChartMaxVel = 0;
}

// ====== READY PANEL (post-config) ======
function ensureReadyPanel_(){
  let rp = document.getElementById('readyPanel');
  if (!rp) {
    rp = document.createElement('div');
    rp.id = 'readyPanel';
    rp.style.display = 'none';
    rp.style.margin = '12px 0';
    rp.style.padding = '12px';
    rp.style.border = '1px solid #e5e7eb';
    rp.style.borderRadius = '14px';
    rp.style.background = 'rgba(255,255,255,.92)';
    rp.style.backdropFilter = 'blur(6px)';
    rp.style.boxShadow = '0 8px 28px rgba(0,0,0,.08)';
    // Insertar antes de la tabla principal
    if (laneTable && laneTable.parentNode) laneTable.parentNode.insertBefore(rp, laneTable);
  }
  return rp;
}

function buildReadySummaryHtml_(){
  const partsHtml = (config.partials||[]).map((acc,i)=>{
    const prev = i>0 ? (+config.partials[i-1]||0) : 0;
    const dist = Math.max(0, (+acc||0) - prev);
    return `<div style="min-width:92px; padding:6px 8px; border:1px solid #eef2f7; border-radius:12px; background:#fff;">${partialLabelHtml_(i+1, dist, acc)}</div>`;
  }).join('');
  const name = escapeHtml_(config.name || 'Serie');
  return `
    <div style="display:flex; gap:10px; align-items:flex-start;">
      <div style="font-size:20px; line-height:1;">✅</div>
      <div style="flex:1;">
        <div style="font-weight:800; font-size:16px;">CHRONO listo para comenzar la serie</div>
        <div style="color:#6b7280; font-size:12px; margin-top:2px;">
          Configuración cargada. Presioná <b>Iniciar</b> para comenzar.
        </div>
      </div>
    </div>

    <div style="display:flex; flex-wrap:wrap; gap:10px; margin-top:10px; font-size:13px;">
      <div><b>Serie:</b> ${name}</div>
      <div><b>Total:</b> ${(config.total||0)} ${distUnitShort_()}</div>
      <div><b>Nadadores:</b> ${(config.swimmers||[]).length}</div>
      <div><b>Parciales:</b> ${(config.partials||[]).length}</div>
    </div>

    ${(config.partials||[]).length ? `
      <div style="margin-top:10px;">
        <div style="font-weight:800; font-size:13px; margin-bottom:6px;">Parciales</div>
        <div style="display:flex; flex-wrap:wrap; gap:8px;">${partsHtml}</div>
      </div>
    ` : ``}
  `;
}


function clearChartsForNewConfig_(){
  // Al configurar una nueva serie (especialmente luego de cargar una sesión desde archivo),
  // limpiamos TODOS los outputs (tablas + gráficos + instancias) para evitar mezcla visual.
  try {
    // 1) Ocultar y vaciar contenedores de tablas/resultados anteriores
    try {
      if (resultsTables) {
        resultsTables.innerHTML = '';
        resultsTables.style.display = 'none';
      }
    } catch (err) { console.error('resultsTables clear failed', err); }

    try {
      if (advancedTablesDiv) {
        advancedTablesDiv.innerHTML = '';
        advancedTablesDiv.style.display = 'none';
      }
    } catch (err) { console.error('advancedTables clear failed', err); }

    try {
      if (advancedChartsDiv) {
        advancedChartsDiv.innerHTML = '';
        advancedChartsDiv.style.display = 'none';
      }
    } catch (err) { console.error('advancedCharts clear failed', err); }

    try {
      if (chartsWrapper) chartsWrapper.style.display = 'none';
      if (chartsDiv) chartsDiv.style.display = 'none';
    } catch (err) { console.error('charts wrapper hide failed', err); }

    // 2) Destruir instancia del gráfico principal
    try {
      if (chartInstance) {
        try { chartInstance.destroy(); } catch (err) { console.error('Main chart destroy failed', err); }
        chartInstance = null;
      }
    } catch (err) { console.error('Main chart destroy outer failed', err); }

    // 3) Limpiar canvas principal (sin borrarlo del DOM)
    try {
      if (partialsChartCanvas) {
        const ctx = partialsChartCanvas.getContext && partialsChartCanvas.getContext('2d');
        if (ctx) ctx.clearRect(0, 0, partialsChartCanvas.width, partialsChartCanvas.height);
      }
    } catch (err) { console.error('Main canvas clear failed', err); }

    // 4) Destruir instancias avanzadas
    try {
      if (Array.isArray(advChartInstances) && advChartInstances.length) {
        advChartInstances.forEach(ci => {
          if (!ci) return;
          try { ci.destroy(); } catch (err) { console.error('Adv chart destroy failed', err); }
        });
      }
      advChartInstances = [];
    } catch (err) { console.error('Adv chart destroy outer failed', err); }

    // 5) Reset de máximos usados por escalas
    mainChartMaxVel = 0;

  } catch (err) {
    console.error('clearChartsForNewConfig_ failed', err);
  }
}



function prepareReadyAfterConfig_(){
  // limpiar runtime (sin renderizar tabla todavía)
  clearInterval(masterTimer);
  masterTimer = null;
  clearSpawnTimeouts();

  startTimes = {};
  lapTimes = {};
  finishTimes = {};
  finishedCount = 0;

  // reset brazadas de la serie (solo resultados, no afecta sesiones guardadas)
  if (swolfTablesDiv){ swolfTablesDiv.style.display='none'; swolfTablesDiv.innerHTML=''; }
  try { (config.swimmers||[]).forEach(sw=>{ if (sw) sw.strokeCounts = []; }); } catch(e){}

  // ocultar tabla + resultados hasta iniciar
  if (laneHead) laneHead.innerHTML = '';
  if (laneBody) laneBody.innerHTML = '';
  if (laneTable) laneTable.style.display = 'none';
  if (resultsTables) resultsTables.innerHTML = '';
  if (chartsDiv) {
    chartsDiv.style.display = 'none';
    // NO limpiar innerHTML: si se borra, se pierde el canvas del gráfico principal.
    // Si por alguna razón ya se borró (versiones anteriores), lo recreamos.
    if (!document.getElementById('partialsChart')) {
      chartsDiv.innerHTML = '<canvas id="partialsChart"></canvas>';
      partialsChartCanvas = document.getElementById('partialsChart');
    }
  }

  // panel listo
  const rp = ensureReadyPanel_();
  rp.innerHTML = buildReadySummaryHtml_();
  rp.style.display = 'block';

  // botones
  if (startBtn) startBtn.disabled = false;
  if (stopBtn) stopBtn.disabled = true;
  if (exportCsvBtn) exportCsvBtn.disabled = true;
  if (exportPdfBtn) exportPdfBtn.disabled = true;
}

function hideReadyPanel_(){
  const rp = document.getElementById('readyPanel');
  if (rp) rp.style.display = 'none';
  if (laneTable) laneTable.style.display = '';
  if (chartsDiv) chartsDiv.style.display = '';
}



startBtn.addEventListener('click', () => {
  if (!validateConfig()) {
    if (typeof showToastBanner === 'function') showToastBanner('Parciales inválidos');
    startBtn.disabled = true;
    return;
  }
  
  // Oculta panel 'listo' y muestra tabla al iniciar
  hideReadyPanel_();
init();
  startBtn.disabled = true;
  stopBtn.disabled = false;
  const swimmersByOrder = {};
  config.swimmers.forEach((sw, idx) => {
    if (!swimmersByOrder[sw.order]) swimmersByOrder[sw.order] = [];
    swimmersByOrder[sw.order].push({sw, idx});
  });
  const ordenes = Object.keys(swimmersByOrder).map(Number).sort((a, b) => a - b);
  clearSpawnTimeouts();
  ordenes.forEach((orden, groupIdx) => {
    const t = setTimeout(() => {
      swimmersByOrder[orden].forEach(({sw, idx}) => spawn(sw, idx));
    }, groupIdx * config.delay * 1000);
    spawnTimeouts.push(t);
  });
  masterTimer = setInterval(() => {
    Object.keys(startTimes).forEach(i => {
      const td = document.querySelector(`#row${i} .lane-timer`);
      if (td) td.textContent = format(Date.now() - startTimes[i]);
    });
  }, 50);
});

stopBtn.addEventListener('click', () => {
  clearInterval(masterTimer);
  clearSpawnTimeouts();
  stopBtn.disabled = true;
});

function spawn(sw, i) {
  startTimes[i] = Date.now();
  lapTimes[i] = [];
  finishTimes[i] = null;

  const unit = distUnitShort_();

  const tr = document.createElement('tr');
  tr.id = `row${i}`;

  const buttons = config.partials.map((p, j) =>
    `<td><button data-i='${i}' data-j='${j}' class="btn-parcial">${p} ${unit}</button></td>`
  ).join('');

  tr.innerHTML = `<td>${sw.name}</td><td>${sw.lane}</td><td>${sw.order}</td><td class='lane-timer'>00:00.00</td>` +
    buttons +
    `<td><button data-i='${i}' class='fin'>Fin</button></td>`;

  laneBody.appendChild(tr);
  tr.querySelectorAll('button[data-j]').forEach(b => b.addEventListener('click', lap));
  tr.querySelector('.fin').addEventListener('click', fin);
}

function lap(e) {
  const i = +e.target.dataset.i, j = +e.target.dataset.j;
  const now = Date.now();
  lapTimes[i] = lapTimes[i] || [];

  let tAcumulado;
  if (j === 0) {
    tAcumulado = now - startTimes[i];
  } else {
    const prevCum = lapTimes[i][j - 1];
    tAcumulado = prevCum + (now - (startTimes[i] + prevCum));
  }

  const tParcial = (j === 0)
    ? (now - startTimes[i])
    : (now - (startTimes[i] + lapTimes[i][j - 1]));

  const parcialesArr = getAllPartialsArr();           // split distances (units)
  const splitDist_units = parcialesArr[j] || 0;

  lapTimes[i][j] = tAcumulado;

  const splitDist_m = toMeters_(splitDist_units);
  const vSplit = (splitDist_m / (tParcial / 1000)).toFixed(2);

  const cumDist_units = (config.partials && config.partials[j] != null)
    ? config.partials[j]
    : parcialesArr.slice(0, j + 1).reduce((a, b) => a + b, 0);

  const cumDist_m = toMeters_(cumDist_units);
  const vAvg = (cumDist_m / (tAcumulado / 1000)).toFixed(2);

  e.target.innerHTML = `${format(tAcumulado)} (${vSplit} m/s)<span class="avg-line">AVG ${vAvg} m/s</span>`;
  e.target.disabled = true;
  e.target.classList.add('parcial-fixed');
}

function fin(e) {
  const i = +e.target.dataset.i;
  const now = Date.now();
  const totalTime = now - startTimes[i];
  finishTimes[i] = totalTime;

  const parcialesArr = getAllPartialsArr(); // split distances (units)
  const laps = (lapTimes[i] || []);
  const lastMarkedIdx = laps.length ? (laps.length - 1) : -1;

  // Distancia acumulada al último parcial realmente marcado (units)
  const lastCum_units = (lastMarkedIdx >= 0 && config.partials && config.partials[lastMarkedIdx] != null)
    ? config.partials[lastMarkedIdx]
    : 0;

  const remaining_units = (+config.total || 0) - lastCum_units;
  const remaining_m = toMeters_(remaining_units);

  const lastCumTime = (lastMarkedIdx >= 0) ? laps[lastMarkedIdx] : 0;
  const remainingTime = totalTime - lastCumTime;

  const vSplitFinal = remainingTime > 0 ? (remaining_m / (remainingTime / 1000)).toFixed(2) : '0.00';

  const total_m = toMeters_(+config.total || 0);
  const vAvgTotal = totalTime > 0 ? (total_m / (totalTime / 1000)).toFixed(2) : '0.00';

  e.target.innerHTML = `${format(totalTime)} (${vSplitFinal} m/s)<span class="avg-line">AVG ${vAvgTotal} m/s</span>`;
  e.target.disabled = true;
  e.target.classList.add('parcial-fixed');

  finishedCount++;
  if (finishedCount === config.swimmers.length) {
    clearInterval(masterTimer);
    clearSpawnTimeouts();
    stopBtn.disabled = true;
    (window.onSeriesAllFinishedUnified_ ? window.onSeriesAllFinishedUnified_()
      : (window.onSeriesAllFinished_ ? window.onSeriesAllFinished_() : showFinalModal()));
  }
}// ========== MOSTRAR TABLAS Y GRÁFICOS ==========

// Helper: etiqueta de parcial (P1 + D/A en texto chico)
function partialMeta_(i){
  const acc = (+config.partials[i] || 0);
  const prev = (i>0 ? (+config.partials[i-1] || 0) : 0);
  const dist = Math.max(0, acc - prev);
  return { n: i+1, dist, acc };
}
function partialLabelHtml_(iOrN, distMaybe, accMaybe){
  // Permite llamadas legacy: (n, acc) o nuevas: (n, dist, acc)
  const toNumOrNull = (v) => {
    if (v == null) return null;
    const s = String(v).trim();
    if (s === '') return null;
    const n = Number(s.replace(',', '.'));
    return Number.isFinite(n) ? n : null;
  };

  let n = +iOrN;
  let dist = null, acc = null;

  if (accMaybe == null && distMaybe != null) {
    // legacy: (n, acc)
    acc = toNumOrNull(distMaybe);
    const prevAccRaw = (n>1 && config.partials && config.partials[n-2]!=null) ? config.partials[n-2] : 0;
    const prevAcc = toNumOrNull(prevAccRaw);
    dist = (acc!=null && prevAcc!=null) ? Math.max(0, (acc - prevAcc)) : null;
  } else {
    dist = toNumOrNull(distMaybe);
    acc = toNumOrNull(accMaybe);
  }

  const esc = (s)=>String(s||"").replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[ch]));
  ensurePartialLabels_();
  const unit = distUnitShort_();

  // FINAL nunca debe verse como P(n+1)
  const isFinal = (n === ((config.partials||[]).length + 1));
  if (isFinal) return finalLabelHtml_(dist, acc);

  const rawLbl = (config.partialLabels && config.partialLabels[n-1]) ? config.partialLabels[n-1] : '';
  const lbl = rawLbl ? ` (${esc(rawLbl)})` : '';

  const meta = (dist!=null || acc!=null)
    ? `<div style="font-size:12px; opacity:.75">` +
        (dist!=null ? `D:${esc(dist)}${unit}` : `D:—`) +
        ` · ` +
        (acc!=null ? `A:${esc(acc)}${unit}` : `A:—`) +
      `</div>`
    : ``;

  return `<div style="font-weight:700; line-height:1.1">P${n}${lbl}</div>${meta}`;
}

function finalLabelHtml_(dist, acc){
  const esc = (s)=>String(s||"").replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[ch]));
  const unit = distUnitShort_();
  const small = (Number.isFinite(dist) && Number.isFinite(acc) && acc>0)
    ? `<br><small style="color:#6b7280;">D:${esc(dist)} ${unit} · A:${esc(acc)} ${unit}</small>`
    : "";
  return `<div style="line-height:1.1;"><b>FINAL</b>${small}</div>`;
}

function renderResultsTables() {
  const segDists_units = getAllPartialsArr(); // split distances (units)
  const unit = distUnitShort_();
  const total_units = +config.total || 0;
  const total_m = toMeters_(total_units);

  let swimmersOrd = config.swimmers
    .map((sw, i) => ({...sw, i, t: finishTimes[i]}))
    .sort((a, b) => (a.t ?? Infinity) - (b.t ?? Infinity));

  const finalDist_units = total_units - (+config.partials[config.partials.length-1] || 0);

  let html = `<div class="res-title">Resultados principales (orden de llegada)</div>
  <div class="res-wrap"><table class="res-table res-table-main">
  <thead><tr>
    <th>Puesto</th>
    <th>Nombre</th>
    <th>Carril</th>
    <th>Orden</th>
    ${config.partials.map((p, i) => {
      const prev = i===0 ? 0 : (+config.partials[i-1]||0);
      const split = p - prev;
      return `<th>${partialLabelHtml_(i+1, split, p)}</th>`;
    }).join('')}
    <th>${finalLabelHtml_(finalDist_units, total_units)}</th>
  </tr></thead>
  <tbody>`;

  swimmersOrd.forEach((sw, pos) => {
    html += `<tr>
      <td>${pos+1}</td>
      <td>${sw.name}</td>
      <td>${sw.lane}</td>
      <td>${sw.order}</td>`;

    // parciales configurados
    for (let j=0; j<config.partials.length; j++){
      let val = '-';
      if (lapTimes[sw.i] && lapTimes[sw.i][j]!=null){
        const tAcum = lapTimes[sw.i][j];
        const tPrev = (j>0 && lapTimes[sw.i][j-1]!=null) ? lapTimes[sw.i][j-1] : 0;
        const tSplit = tAcum - tPrev;

        const split_units = segDists_units[j] || ((j===0)?config.partials[0]:(config.partials[j]-config.partials[j-1]));
        const split_m = toMeters_(split_units);
        const vSplit = (tSplit>0) ? (split_m/(tSplit/1000)) : 0;

        const cum_units = config.partials[j];
        const cum_m = toMeters_(cum_units);
        const vAvg = (tAcum>0) ? (cum_m/(tAcum/1000)) : 0;

        val = `${format(tAcum)} (${vSplit.toFixed(2)} m/s)<span class="avg-line">AVG ${vAvg.toFixed(2)} m/s</span>`;
      }
      html += `<td>${val}</td>`;
    }

    // FINAL (restante)
    let finalVal = '-';
    if (sw.t!=null) {
      const laps = lapTimes[sw.i] || [];
      const lastIdx = laps.length ? (laps.length-1) : -1;

      const lastCumTime = lastIdx>=0 ? laps[lastIdx] : 0;
      const lastCumUnits = lastIdx>=0 ? (+config.partials[lastIdx]||0) : 0;

      const remain_units = total_units - lastCumUnits;
      const remain_m = toMeters_(remain_units);

      const tSplit = sw.t - lastCumTime;
      const vSplit = (tSplit>0) ? (remain_m/(tSplit/1000)) : 0;
      const vAvg = (sw.t>0) ? (total_m/(sw.t/1000)) : 0;

      finalVal = `${format(sw.t)} (${vSplit.toFixed(2)} m/s)<span class="avg-line">AVG ${vAvg.toFixed(2)} m/s</span>`;
    }
    html += `<td>${finalVal}</td></tr>`;
  });

  html += '</tbody></table></div>';

  // Tabla de mejor tramo por nadador
  html += `<div class="res-title">Mejor tramo por nadador</div>
  <div class="res-wrap"><table class="res-table res-table-bestby">
  <thead><tr>
    <th>Nombre</th>
    <th>Tramo más rápido</th>
    <th>Distancia (${unit})</th>
    <th>Tiempo</th>
    <th>Velocidad (m/s)</th>
  </tr></thead><tbody>`;

  config.swimmers.forEach((sw, i) => {
    const metrics = getAdvancedMetrics(i, true);
    const best = metrics.mejorParcial;
    const vel = best && best.tiempo>0 ? (toMeters_(best.dist)/(best.tiempo/1000)).toFixed(2) : '-';
    html += `<tr>
      <td>${sw.name}</td>
      <td>${best ? partialLabelHtml_(best.n, best.dist, best.cum_units!=null ? best.cum_units : (+config.total||0)) : '-'}</td>
      <td>${best ? best.dist : '-'}</td>
      <td>${best ? format(best.tiempo) : '-'}</td>
      <td>${vel}</td>
    </tr>`;
  });
  html += '</tbody></table></div>';

  // Tabla de mejores parciales por tramo
  html += `<div class="res-title">Mejores parciales por tramo</div>
  <div class="res-wrap"><table class="res-table res-table-bestseg">
  <thead><tr>
    <th>Tramo</th>
    <th>Nadador</th>
    <th>Distancia (${unit})</th>
    <th>Tiempo</th>
    <th>Velocidad (m/s)</th>
  </tr></thead><tbody>`;

  segDists_units.forEach((dist, j) => {
    let best = null, bestIndex = null;
    config.swimmers.forEach((sw, i) => {
      const laps = lapTimes[i] || [];
      let tAcum = laps[j] != null ? laps[j] : (finishTimes[i]!=null && j===segDists_units.length-1 ? finishTimes[i] : null);
      if (tAcum != null) {
        const tPrev = j>0 ? (laps[j-1] != null ? laps[j-1] : null) : 0;
        if (tPrev == null) return;
        const tSplit = tAcum - tPrev;
        if (tSplit>0 && (best==null || tSplit < best)) { best = tSplit; bestIndex = i; }
      }
    });
    const vel = (best!=null && best>0) ? (toMeters_(dist)/(best/1000)).toFixed(2) : '-';
    const accUnits = (j < config.partials.length) ? config.partials[j] : total_units;
    html += `<tr>
      <td>${partialLabelHtml_(j+1, dist, accUnits)}</td>
      <td>${bestIndex!=null ? config.swimmers[bestIndex].name : '-'}</td>
      <td>${dist}</td>
      <td>${best!=null ? format(best) : '-'}</td>
      <td>${vel}</td>
    </tr>`;
  });
  html += '</tbody></table></div>';

  resultsTables.innerHTML = html;
  resultsTables.style.display = '';
}

function showFinalModal() { finalOverlay.style.display = 'block'; finalModal.style.display = 'block'; }
function hideFinalModal() {
  finalOverlay.style.display = 'none';
  finalModal.style.display = 'none';
  startBtn.disabled = !validateConfig(); // permitir nueva serie solo si es válida
}
finalOverlay.addEventListener('click', hideFinalModal);
closeFinalModal.addEventListener('click', hideFinalModal);
cancelFinalModal.addEventListener('click', hideFinalModal);
document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && finalModal.style.display === 'block') hideFinalModal(); });

finalShowTables.addEventListener('click', () => { hideFinalModal(); showResults(true, false); });
finalShowCharts.addEventListener('click', () => { hideFinalModal(); showResults(false, true); });
finalExportXLS.addEventListener('click', () => { hideFinalModal(); exportToXLS(); });
finalExportPDF.addEventListener('click', () => { hideFinalModal(); exportToPDF(); });
finalBoth.addEventListener('click', () => { hideFinalModal(); showResults(true, true); });


// ======== SWOLF / BRAZADAS ========
function calcSwolf_(splitMs, strokes){
  const s = Number(strokes);
  const ms = Number(splitMs);
  if (!isFinite(s) || s < 0) return null;
  if (!isFinite(ms) || ms <= 0) return null;
  const sec = Math.round(ms/1000);
  return sec + Math.round(s);
}

function getSegmentsForSwimmer_(i){
  const segDists = getAllPartialsArr();
  const cumArr = (lapTimes && lapTimes[i]) ? lapTimes[i] : [];
  const totalMs = (finishTimes && finishTimes[i]!=null) ? Number(finishTimes[i]) : null;
  const segs = [];
  let prevCum = 0;
  let cumDist = 0;
  for (let s=0; s<segDists.length; s++){
    cumDist += Number(segDists[s]||0);
    let cumMs = null;
    if (s < cumArr.length) cumMs = Number(cumArr[s]);
    else if (s === segDists.length-1 && totalMs!=null) cumMs = totalMs;
    const splitMs = (cumMs!=null && isFinite(cumMs)) ? (cumMs - prevCum) : null;
    if (cumMs!=null && isFinite(cumMs)) prevCum = cumMs;
    const label = (s === segDists.length-1 && (cumDist >= Number(config.total||0))) ? "FINAL" : ("P"+(s+1));
    segs.push({
      idx: s+1,
      label,
      distance: cumDist,
      split_distance: Number(segDists[s]||0),
      t_acum_ms: (cumMs!=null && isFinite(cumMs)) ? cumMs : null,
      t_acum_str: (cumMs!=null && isFinite(cumMs) && typeof format==="function") ? format(cumMs) : (cumMs!=null ? String(cumMs) : ""),
      t_split_ms: (splitMs!=null && isFinite(splitMs)) ? splitMs : null
    });
  }
  // Si no hubo parciales configurados, pero sí total, creamos un único tramo FINAL
  if (segs.length===0 && totalMs!=null){
    segs.push({ idx:1, label:"FINAL", distance:Number(config.total||0), split_distance:Number(config.total||0), t_acum_ms: totalMs, t_acum_str:(typeof format==="function")?format(totalMs):String(totalMs), t_split_ms: totalMs });
  }
  return segs;
}

function renderSwolfTables_(){
  if (!swolfTablesDiv) return;
  const anyEnabled = Array.isArray(config.swimmers) && config.swimmers.some(sw => !!(sw && (sw.strokesEnabled || (Array.isArray(sw.strokeCounts) && sw.strokeCounts.some(v => v!=null && isFinite(Number(v)))))));
  if (!anyEnabled) { swolfTablesDiv.style.display = 'none'; swolfTablesDiv.innerHTML=''; return; }

  const segDists = getAllPartialsArr();
  const segCount = (segDists.length || 0) || 1;
  const cols = [];
  for (let s=0; s<segCount; s++){
    const isFinal = (s===segCount-1);
    cols.push(isFinal ? "FINAL" : ("P"+(s+1)));
  }
  // Determine if there is any swolf computable
  let anyData = false;
  const rows = [];
  (config.swimmers||[]).forEach((sw, i) => {
    const include = !!(sw && (sw.strokesEnabled || (Array.isArray(sw.strokeCounts) && sw.strokeCounts.some(v => v!=null && isFinite(Number(v))))));
    if (!include) return;
    const segs = getSegmentsForSwimmer_(i);
    const counts = Array.isArray(sw.strokeCounts) ? sw.strokeCounts : [];
    const swolfs = [];
    for (let s=0; s<cols.length; s++){
      const seg = segs[s] || {};
      const strokes = (counts[s]!=null && isFinite(Number(counts[s]))) ? Number(counts[s]) : null;
      const val = calcSwolf_(seg.t_split_ms, strokes);
      if (val!=null) { anyData = true; swolfs.push(val); } else { swolfs.push(null); }
    }
    const valid = swolfs.filter(v => v!=null);
    const best = valid.length ? Math.min(...valid) : null;
    const avg = valid.length ? Math.round(valid.reduce((a,b)=>a+b,0)/valid.length) : null;
    rows.push({ name: sw.name || ("Nadador "+(i+1)), lane: sw.lane, order: sw.order, swolfs, best, avg });
  });

  if (!anyData) { swolfTablesDiv.style.display='none'; swolfTablesDiv.innerHTML=''; return; }

  let thead = `<tr><th>Nombre</th>${cols.map(c=>`<th>${c}</th>`).join('')}<th>Mejor</th><th>Prom</th></tr>`;
  let tbody = rows.map(r => {
    const cells = r.swolfs.map(v => `<td>${v!=null ? v : '-'}</td>`).join('');
    return `<tr><td><b>${escapeHtml_(r.name)}</b></td>${cells}<td>${r.best!=null ? r.best : '-'}</td><td>${r.avg!=null ? r.avg : '-'}</td></tr>`;
  }).join('');
  swolfTablesDiv.innerHTML = `
    <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
      <h3 style="margin:8px 0;">SWOLF <button class="info-btn" data-info="swolf" title="¿Qué es SWOLF?">i</button></h3>
      <small style="color:#6b7280;">Solo se muestra si se registraron brazadas.</small>
    </div>
    <div class="swolf-wrap">
      <table>
        <thead>${thead}</thead>
        <tbody>${tbody}</tbody>
      </table>
    </div>`;
  swolfTablesDiv.style.display = '';
}

function openStrokesModalIfNeeded_(done){
  try{
    const enabledIdx = (config.swimmers||[]).map((sw,i)=> (sw && sw.strokesEnabled) ? i : null).filter(v=>v!=null);
    if (!enabledIdx.length || !strokesOverlay || !strokesModal || !strokesCards){
      if (typeof done === 'function') done();
      return;
    }

    const segDists = getAllPartialsArr();
    const segCount = segDists.length || 0;
    strokesCards.innerHTML = "";
    enabledIdx.forEach(i=>{
      const sw = config.swimmers[i] || {};
      const segs = getSegmentsForSwimmer_(i);
      const counts = Array.isArray(sw.strokeCounts) ? sw.strokeCounts : [];
      let rows = "";
      for (let s=0; s<segs.length; s++){
        const seg = segs[s];
        const strokes = (counts[s]!=null && isFinite(Number(counts[s]))) ? Number(counts[s]) : "";
        const swolf = calcSwolf_(seg.t_split_ms, strokes);
        rows += `
          <tr>
            <td><b>${escapeHtml_(seg.label)}</b></td>
            <td>${seg.t_split_ms!=null ? format(seg.t_split_ms) : '-'}</td>
            <td><input class="stroke-input" type="number" min="0" step="1" data-i="${i}" data-s="${s}" value="${escapeHtml_(strokes)}"></td>
            <td><span class="swolf-val" data-i="${i}" data-s="${s}">${swolf!=null ? swolf : '-'}</span></td>
          </tr>`;
      }
      const card = document.createElement('div');
      card.className = "card";
      card.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
          <div><b>${escapeHtml_(sw.name || ("Nadador "+(i+1)))}</b></div>
          <small style="color:#6b7280;">Carril ${escapeHtml_(sw.lane)} · Orden ${escapeHtml_(sw.order)}</small>
        </div>
        <div style="margin-top:8px; border:1px solid #e5e7eb; border-radius:10px; overflow:auto; -webkit-overflow-scrolling:touch;">
          <table>
            <thead>
              <tr><th>Tramo</th><th>Tiempo</th><th>Brazadas</th><th>SWOLF</th></tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        </div>
      `;
      strokesCards.appendChild(card);
    });

    function close_(omit){
      strokesOverlay.style.display = 'none';
      strokesModal.style.display = 'none';
      if (!omit){
        // nothing (saved already)
      }
      if (typeof done === 'function') done();
    }

    function save_(){
      enabledIdx.forEach(i=>{
        const sw = config.swimmers[i] || (config.swimmers[i] = {});
        const inputs = Array.from(strokesModal.querySelectorAll(`input.stroke-input[data-i="${i}"]`));
        const maxS = inputs.reduce((mx, inp)=> Math.max(mx, Number(inp.dataset.s||0)), -1);
        const arr = new Array(maxS+1).fill(null);
        inputs.forEach(inp=>{
          const s = Number(inp.dataset.s||0);
          const v = Number(String(inp.value||'').replace(',', '.'));
          arr[s] = (isFinite(v) && v>=0) ? Math.round(v) : null;
        });
        sw.strokeCounts = arr;
      });
      // update swolf table in case user opens tablas/gráficos
      renderSwolfTables_();
      close_(false);
    }

    // live update swolf display on input
    strokesModal.oninput = (ev) => {
      const t = ev.target;
      if (!t || !t.classList || !t.classList.contains('stroke-input')) return;
      const i = Number(t.dataset.i||0);
      const s = Number(t.dataset.s||0);
      const segs = getSegmentsForSwimmer_(i);
      const seg = segs[s] || {};
      const strokes = Number(String(t.value||'').replace(',', '.'));
      const val = calcSwolf_(seg.t_split_ms, strokes);
      const span = strokesModal.querySelector(`.swolf-val[data-i="${i}"][data-s="${s}"]`);
      if (span) span.textContent = (val!=null ? String(val) : '-');
    };

    // attach buttons
    strokesOverlay.onclick = () => close_(true);
    if (closeStrokesModalBtn) closeStrokesModalBtn.onclick = () => close_(true);
    if (omitStrokesBtn) omitStrokesBtn.onclick = () => close_(true);
    if (saveStrokesBtn) saveStrokesBtn.onclick = save_;

    strokesOverlay.style.display = 'block';
    strokesModal.style.display = 'block';
  } catch(e){
    console.error('openStrokesModalIfNeeded_ error', e);
    if (typeof done === 'function') done();
  }
}

// Unified hook: se usa al finalizar serie para disparar brazadas antes del modal final/conector
// Unified hook: se usa al finalizar serie para disparar brazadas antes del modal final/conector
window.onSeriesAllFinishedUnified_ = function(){
  openStrokesModalIfNeeded_(() => {
    // Auto-save: guardar sesión completa al finalizar
    try {
      saveExecutedSessionToLocal_(null);
    } catch(e){ console.error('autosave results error', e); }

if (window.onSeriesAllFinished_) window.onSeriesAllFinished_();
    else if (typeof showFinalModal === 'function') showFinalModal();
  });
};

// Info modal events (delegación)
document.addEventListener('click', (e) => {
  const btn = e.target && e.target.closest ? e.target.closest('.info-btn[data-info="swolf"]') : null;
  if (!btn) return;
  if (swolfInfoOverlay && swolfInfoModal){
    swolfInfoOverlay.style.display = 'block';
    swolfInfoModal.style.display = 'block';
  }
});
if (swolfInfoOverlay && swolfInfoModal){
  swolfInfoOverlay.addEventListener('click', () => { swolfInfoOverlay.style.display='none'; swolfInfoModal.style.display='none'; });
}
if (closeSwolfInfoBtn) closeSwolfInfoBtn.addEventListener('click', () => { if (swolfInfoOverlay) swolfInfoOverlay.style.display='none'; if (swolfInfoModal) swolfInfoModal.style.display='none'; });
if (okSwolfInfoBtn) okSwolfInfoBtn.addEventListener('click', () => { if (swolfInfoOverlay) swolfInfoOverlay.style.display='none'; if (swolfInfoModal) swolfInfoModal.style.display='none'; });

function showResults(showTables = true, showCharts = true) {
  try {
    if (typeof recalcAllAccOverridesFromSplits_ === 'function') recalcAllAccOverridesFromSplits_();
  } catch (e) { console.error(e); }
  exportCsvBtn.disabled = false;
  exportPdfBtn.disabled = false;
  // SWOLF (si corresponde)
  try { if (showTables || showCharts) renderSwolfTables_(); else if (swolfTablesDiv){ swolfTablesDiv.style.display='none'; swolfTablesDiv.innerHTML=''; } } catch(e){ console.error(e); }
  // Tablas
  if (showTables) {
    laneTable.style.display = '';
    renderResultsTables();
    showAdvancedTables();
  } else {
    laneTable.style.display = 'none';
    resultsTables.style.display = 'none';
    advancedTablesDiv.style.display = 'none';
  }
  // Gráficos
  if (showCharts) {
    chartsWrapper.style.display = 'block';
    chartsDiv.style.display = 'block';
    showMainChart();
    showAdvancedCharts();
  } else {
    chartsWrapper.style.display = 'none';
    chartsDiv.style.display = 'none';
    advancedChartsDiv.style.display = 'none';
  }
}

// ======== GRÁFICO PRINCIPAL ==========

function showMainChart() {
  
  // Guard: el canvas del gráfico principal puede haber sido removido por resets previos.
  if (!partialsChartCanvas || !document.body.contains(partialsChartCanvas)) {
    const cd = document.getElementById('charts');
    if (cd) {
      cd.innerHTML = '<canvas id="partialsChart"></canvas>';
      partialsChartCanvas = document.getElementById('partialsChart');
    }
  }
  if (!partialsChartCanvas) {
    // Sin canvas, no podemos renderizar el gráfico principal
    return;
  }
if (typeof Chart === 'undefined') {
    console.error('Chart.js not loaded');
    if (typeof showToastBanner === 'function') {
      showToastBanner('Error: Chart.js no cargado');
    }
    return;
  }
  const parcialesArr = getAllPartialsArr();
  const cumulPoints = parcialesArr.reduce((acc, d) => {
    acc.push((acc[acc.length - 1] || 0) + d);
    return acc;
  }, []);
  const ticksVals = [0, ...config.partials, config.total];
  const tickLabels = ['', ...config.partials.map((d, i) => `P${i + 1} (${d}${distUnitShort_()})`), 'FINAL'];
  const datasets = [];
  const palette = ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#a65628','#f781bf','#999999'];
  mainChartMaxVel = 0;

  config.swimmers.forEach((sw, idx) => {
    const points = [{ x: 0, y: 0 }];
    let tPrev = 0;
    const lastLapTimes = lapTimes[idx] || [];
    const finish = finishTimes[idx];

    for (let j = 0; j < parcialesArr.length; j++) {
      let tParcialAcum = (lastLapTimes[j] != null)
        ? lastLapTimes[j]
        : (finish != null && j === parcialesArr.length - 1 ? finish : null);
      if (tParcialAcum == null) break;
      const tParcial = tParcialAcum - tPrev;
      let vel = 0;
      if (tParcial > 0) {
        vel = toMeters_(parcialesArr[j]) / (tParcial / 1000);
        if (vel > mainChartMaxVel) mainChartMaxVel = vel;
      }
      points.push({ x: cumulPoints[j], y: vel });
      tPrev = tParcialAcum;
    }

    if(points.length > 1) datasets.push({
      label: sw.name,
      data: points,
      borderColor: palette[idx % palette.length],
      backgroundColor: palette[idx % palette.length] + '33',
      tension: 0.15,
      fill: false,
      spanGaps: true
    });
  });

  if (chartInstance) chartInstance.destroy();
  chartInstance = new Chart(partialsChartCanvas.getContext('2d'), {
    type: 'line',
    data: { datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { position: 'bottom' },
        title: { display: true, text: 'Velocidad (m/s) por tramo' }
      },
      interaction: { mode: 'nearest', axis: 'xy', intersect: false },
      scales: {
        x: {
          type: 'linear',
          title: { display: true, text: 'Distancia (' + distUnitShort_() + ')' },
          ticks: { callback: (v, idx) => tickLabels[idx] },
          afterBuildTicks: scale => {
            scale.ticks = ticksVals.map((v, i) => ({ value: v, label: tickLabels[i] }));
          }
        },
        y: {
          beginAtZero: true,
          max: Math.max(0.5, (Number.isFinite(mainChartMaxVel) ? Math.ceil(mainChartMaxVel / 0.5) * 0.5 : 0.5)),
          title: { display: true, text: 'Velocidad (m/s)' },
          ticks: { stepSize: 0.5 }
        }
      }
    }
  });
}

// ======== MÉTRICAS AVANZADAS ==========

function getAdvancedMetrics(idx, includePartials = false) {
  const parcialesArr = getAllPartialsArr(); // split distances (units)
  const laps = lapTimes[idx] || [];
  const finish = finishTimes[idx];
  const res = { parciales: [], mejorParcial: null };
  let prev = 0;
  for (let j = 0; j < parcialesArr.length; j++) {
    let acumulado = laps[j] != null ? laps[j]
      : (finish != null && j === parcialesArr.length - 1 ? finish : null);
    if (acumulado == null) break;

    const tiempo = acumulado - prev;
    const dist_units = parcialesArr[j];
    const dist_m = toMeters_(dist_units);
    const vel = tiempo > 0 ? (dist_m / (tiempo / 1000)) : 0;

    // AVG acumulada (hasta ese parcial)
    const cum_units = (j < config.partials.length ? config.partials[j] : (+config.total || 0));
    const cum_m = toMeters_(cum_units);
    const velAvg = acumulado > 0 ? (cum_m / (acumulado / 1000)) : 0;

    const obj = { n: j + 1, dist: dist_units, dist_m, tiempo, vel, velAvg, cum_units };

    if (tiempo > 0 && (!res.mejorParcial || tiempo < res.mejorParcial.tiempo)) {
      res.mejorParcial = { ...obj };
    }
    if (includePartials) res.parciales.push(obj);
    prev = acumulado;
  }
  return res;
}

function showAdvancedTables() {
  advancedTablesDiv.innerHTML = '';
  const swAdv = config.swimmers.map((sw, i) => ({ sw, i })).filter(o => o.sw.advanced);
  if (!swAdv.length) { advancedTablesDiv.style.display = 'none'; return; }

  const unit = distUnitShort_();

  swAdv.forEach(({ sw, i }) => {
    const _palette = ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#a65628','#f781bf','#999999'];
    const _color = _palette[i % _palette.length];
    const metrics = getAdvancedMetrics(i, true);
    if (!metrics.parciales.length) return;

    let html = `<div class="adv-title">${sw.name}</div>`;
    html += `<table class="adv-table"><thead><tr>
      <th>Parcial</th>
      <th>Distancia (${unit})</th>
      <th>Tiempo</th>
      <th>Velocidad (m/s)</th>
      <th>AVG (m/s)</th>
    </tr></thead><tbody>`;

    metrics.parciales.forEach(p => {
      const cumUnits = (p && p.cum_units!=null) ? p.cum_units : ((p.n<=config.partials.length) ? config.partials[p.n-1] : (+config.total||0));
      html += `<tr>
        <td>${partialLabelHtml_(p.n, p.dist, cumUnits)}</td>
        <td>${p.dist}</td>
        <td>${format(p.tiempo)}</td>
        <td>${isFinite(p.vel) ? p.vel.toFixed(2) : '-'}</td>
        <td>${isFinite(p.velAvg) ? p.velAvg.toFixed(2) : '-'}</td>
      </tr>`;
    });

    html += '</tbody></table>';
    advancedTablesDiv.insertAdjacentHTML('beforeend', html);
  });

  advancedTablesDiv.style.display = 'block';
}

function showAdvancedCharts() {
  // Ensure container is visible before rendering so Chart.js measures correctly
  advancedChartsDiv.innerHTML = '';
  advChartInstances.forEach(c => c.destroy && c.destroy());
  advChartInstances = [];
  const swAdv = config.swimmers.map((sw, i) => ({ sw, i })).filter(o => o.sw.advanced);
  if (!swAdv.length) { advancedChartsDiv.style.display = 'none'; return; }
  // Show container early to avoid zero-size canvas issues
  advancedChartsDiv.style.display = 'block';
  swAdv.forEach(({ sw, i }) => {
    const _palette = ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#a65628','#f781bf','#999999'];
    const _color = _palette[i % _palette.length];
    const metrics = getAdvancedMetrics(i, true);
    if (!metrics.parciales.length || typeof Chart === 'undefined') return;
    const maxVel = Math.max(...metrics.parciales.map(p => p.vel));
    let yMax;
    if (mainChartMaxVel <= 0 || mainChartMaxVel < maxVel) {
      yMax = Math.ceil(maxVel / 0.5) * 0.5;
    } else {
      yMax = Math.ceil(mainChartMaxVel / 0.5) * 0.5;
    }
    const canvas = document.createElement('canvas');
    canvas.className = 'adv-chart-canvas';
    advancedChartsDiv.appendChild(canvas);

    let acc = 0;
    const points = [{ x: 0, y: 0 }];
    metrics.parciales.forEach(p => {
      acc += p.dist;
      points.push({ x: acc, y: p.vel });
    });
    const tickVals = [0, ...config.partials, config.total];
    const tickLabels = ['', ...config.partials.map((_, i) => `P${i + 1}`), 'FINAL'];

    const data = {
      datasets: [{
        label: sw.name,
        data: points,
        borderColor: _color,
        backgroundColor: _color + '33',
        tension: 0.15,
        fill: false
      }]
    };
    const opts = {
      responsive: true,
      maintainAspectRatio: false,
      plugins: { title: { display: true, text: 'Velocidad por parcial - ' + sw.name } },
      scales: {
        x: {
          type: 'linear',
          title: { display: true, text: 'Distancia (' + distUnitShort_() + ')' },
          ticks: { callback: (v, idx) => tickLabels[idx] },
          afterBuildTicks: scale => {
            scale.ticks = tickVals.map((v, i) => ({ value: v, label: tickLabels[i] }));
          }
        },
        y: { beginAtZero: true, max: yMax, title: { display: true, text: 'Velocidad (m/s)' }, ticks: { stepSize: 0.5 } }
      }
    };
    const inst = new Chart(canvas.getContext('2d'), { type: 'line', data, options: opts });
    advChartInstances.push(inst);
  });
  advancedChartsDiv.style.display = advChartInstances.length ? 'block' : 'none';
}

function renderAll() {
  const savedStart = JSON.parse(JSON.stringify(startTimes));
  const savedLaps = JSON.parse(JSON.stringify(lapTimes));
  const savedFinish = JSON.parse(JSON.stringify(finishTimes));
  const savedCount = finishedCount;

  init();

  startTimes = savedStart;
  lapTimes = savedLaps;
  finishTimes = savedFinish;
  finishedCount = savedCount;

  populateModal();
  renderResultsTables();
  chartsWrapper.style.display = 'block';
  chartsDiv.style.display = 'block';
  showMainChart();
  showAdvancedTables();
  showAdvancedCharts();

  exportCsvBtn.disabled = false;
  exportPdfBtn.disabled = false;
  resultsTables.style.display = '';
  chartsDiv.style.display = 'block';
  startBtn.disabled = !validateConfig();
}

// ======== EXPORTAR RESULTADOS ==========
function exportToXLS() {
  const generalTables = resultsTables.querySelectorAll('table');
  const advTables = (typeof advancedTablesDiv !== 'undefined' && advancedTablesDiv)
    ? advancedTablesDiv.querySelectorAll('table')
    : [];

  if (!generalTables.length && (!advTables || !advTables.length)) {
    alert('No hay resultados para exportar');
    return;
  }

  const wb = XLSX.utils.book_new();
  const usedNames = {};

  function makeSheetName(base, fallback) {
    let name = (base || fallback || 'Hoja').trim();
    // Quitar caracteres no permitidos en nombres de hoja de Excel
    name = name.replace(/[:\\\/\?\*\[\]]/g, ' ');
    if (name.length > 25) name = name.slice(0, 25);
    if (!name) name = fallback || 'Hoja';

    let finalName = name;
    let suffix = 1;
    while (usedNames[finalName]) {
      suffix += 1;
      finalName = name.slice(0, 22) + '_' + suffix;
    }
    usedNames[finalName] = true;
    return finalName;
  }

  // 1) Hoja con resultados generales (todas las tablas colectivas)
  if (generalTables.length) {
    const aoa = [];
    generalTables.forEach((tbl, idx) => {
      const wsTmp = XLSX.utils.table_to_sheet(tbl);
      const range = XLSX.utils.decode_range(wsTmp['!ref']);

      if (idx > 0 && aoa.length) {
        // Fila en blanco como separador entre tablas
        aoa.push([]);
      }

      for (let R = range.s.r; R <= range.e.r; ++R) {
        const row = [];
        for (let C = range.s.c; C <= range.e.c; ++C) {
          const addr = XLSX.utils.encode_cell({ r: R, c: C });
          const cell = wsTmp[addr];
          row.push(cell ? cell.v : null);
        }
        aoa.push(row);
      }
    });

    const wsGeneral = XLSX.utils.aoa_to_sheet(aoa);
    const sheetName = makeSheetName('Resultados', 'Resultados');
    XLSX.utils.book_append_sheet(wb, wsGeneral, sheetName);
  }

  // 2) Hojas individuales por métrica avanzada / nadador
  if (advTables && advTables.length) {
    advTables.forEach((tbl, idx) => {
      const ws = XLSX.utils.table_to_sheet(tbl);

      // Buscar el título asociado (div.adv-title justo antes de la tabla)
      let title = '';
      let node = tbl.previousElementSibling;
      if (node && node.classList && node.classList.contains('adv-title')) {
        title = (node.textContent || '').trim();
      }

      const sheetName = makeSheetName(
        title ? 'Adv ' + title : 'Metrica ' + (idx + 1),
        'Metrica ' + (idx + 1)
      );

      XLSX.utils.book_append_sheet(wb, ws, sheetName);
    });
  }

  XLSX.writeFile(wb, (config.name || 'resultados') + '.xlsx');
}

function exportToPDF() {
  const generalTables = resultsTables.querySelectorAll('table');
  const advTables = (typeof advancedTablesDiv !== 'undefined' && advancedTablesDiv)
    ? advancedTablesDiv.querySelectorAll('table')
    : [];
  const advCanvases = (typeof advancedChartsDiv !== 'undefined' && advancedChartsDiv)
    ? advancedChartsDiv.querySelectorAll('canvas')
    : [];
  const { jsPDF } = window.jspdf;

  if (!generalTables.length && (!advTables || !advTables.length)) {
    alert('No hay resultados para exportar');
    return;
  }

  const doc = new jsPDF();
  let y = 10;
  const margin = 10;
  const pageWidth = doc.internal.pageSize.getWidth();
  const maxHeight = doc.internal.pageSize.getHeight() - 20;

  // 1) Tablas generales primero
  if (generalTables.length) {
    generalTables.forEach(tbl => {
      if (y > maxHeight - 40) {
        doc.addPage();
        y = 10;
      }
      doc.autoTable({ html: tbl, startY: y });
      y = doc.lastAutoTable.finalY + 10;
    });
  }

  // 2) Gráfico principal de parciales
  try {
    const chartCanvas = document.getElementById('partialsChart');
    if (chartCanvas) {
      if (y > maxHeight - 60) {
        doc.addPage();
        y = 10;
      }
      const imgData = chartCanvas.toDataURL('image/png', 1.0);
      const imgWidth = pageWidth - margin * 2;
      const ratio = chartCanvas.height && chartCanvas.width ? (chartCanvas.height / chartCanvas.width) : 0.5;
      const imgHeight = imgWidth * (ratio || 0.5);
      const finalHeight = Math.min(imgHeight, maxHeight - y - 10);
      doc.addImage(imgData, 'PNG', margin, y, imgWidth, finalHeight);
      y += finalHeight + 10;
    }
  } catch (e) {
    console.error('No se pudo agregar el gráfico principal al PDF:', e);
  }

  // 3) Para cada nadador avanzado: gráfico individual + tabla individual
  try {
    if (advTables && advTables.length) {
      for (let i = 0; i < advTables.length; i++) {
        const tbl = advTables[i];
        const canvas = advCanvases && advCanvases[i] ? advCanvases[i] : null;

        if (y > maxHeight - 80) {
          doc.addPage();
          y = 10;
        }

        // Título si existe .adv-title correspondiente
        const titleElem = tbl.previousElementSibling;
        if (titleElem && titleElem.classList && titleElem.classList.contains('adv-title')) {
          doc.setFontSize(14);
          doc.text(String(titleElem.textContent || '').trim(), margin, y + 5);
          y += 12;
        }

        // Gráfico individual
        if (canvas) {
          try {
            const imgData = canvas.toDataURL('image/png', 1.0);
            const imgWidth = pageWidth - margin * 2;
            const ratio = canvas.height && canvas.width ? (canvas.height / canvas.width) : 0.5;
            const imgHeight = imgWidth * (ratio || 0.5);
            const finalHeight = Math.min(imgHeight, maxHeight - y - 10);
            doc.addImage(imgData, 'PNG', margin, y, imgWidth, finalHeight);
            y += finalHeight + 10;
          } catch (eImg) {
            console.error('No se pudo agregar gráfico avanzado al PDF:', eImg);
          }
        }

        // Tabla individual del nadador
        if (y > maxHeight - 40) {
          doc.addPage();
          y = 10;
        }
        doc.autoTable({ html: tbl, startY: y });
        y = doc.lastAutoTable.finalY + 10;
      }
    }
  } catch (e) {
    console.error('Error al agregar gráficos/tablas avanzadas al PDF:', e);
  }

  doc.save((config.name || 'resultados') + '.pdf');
}


// Intento de ingreso desde la pantalla de bienvenida con revalidación remota
async function attemptEnterChronoFromWelcome() {
  const storedKey = localStorage.getItem('mdvLicenseKey');
  const btn = (typeof welcomeChrono !== 'undefined') ? welcomeChrono : null;
  let originalText = '';
  let intervalId = null;

  if (btn) {
    btn.classList.add('welcome-loading');
    btn.disabled = true;
    originalText = btn.textContent || '';
    const baseText = 'Verificando licencia';
    let dots = 0;
    btn.textContent = baseText + '...';
    intervalId = setInterval(() => {
      dots = (dots + 1) % 4;
      btn.textContent = baseText + '.'.repeat(dots);
    }, 400);
  }

  try {
    if (!storedKey) {
      if (typeof showToastBanner === 'function') showToastBanner('Ingresá tu licencia para continuar');
      openLicenseModal();
      return;
    }

    const result = await validateLicenseRemote(storedKey);

    if (result.ok) {
      if (result.expiresAt) {
        localStorage.setItem('mdvLicenseExpiresAt', result.expiresAt);
      } else {
        localStorage.removeItem('mdvLicenseExpiresAt');
      }
      try { localStorage.setItem('mdvLicenseAttrs', JSON.stringify(result.attrs || {})); } catch (e) {}
      hideWelcome();
      return;
    }

    const msg = licenseErrorMsgFromResult(result);
    const code = (result && (result.error || result.code)) ? String(result.error || result.code) : '';
    if (typeof showToastBanner === 'function') {
      showToastBanner('Licencia: ' + msg + (code ? (' [' + code + ']') : ''));
    }

    localStorage.removeItem('mdvLicenseKey');
    localStorage.removeItem('mdvLicenseExpiresAt');
    openLicenseModal();

  } catch (e) {
    console.error('Error al validar licencia almacenada:', e);

    // Si hay problemas de red, usamos el chequeo local como respaldo
    if (isLicenseValidLocally()) {
      if (typeof showToastBanner === 'function') showToastBanner('Servidor inaccesible: usando licencia local');
      hideWelcome();
    } else {
      if (typeof showToastBanner === 'function') showToastBanner('No se pudo validar la licencia');
      openLicenseModal();
    }
  } finally {
    if (btn) {
      if (intervalId !== null) {
        clearInterval(intervalId);
      }
      if (originalText) {
        btn.textContent = originalText;
      }
      btn.classList.remove('welcome-loading');
      btn.disabled = false;
    }
  }
}

// Eventos de bienvenida
welcomeChrono.addEventListener('click', function() {
  // Siempre intentamos revalidar contra el servidor si existe una licencia almacenada
  attemptEnterChronoFromWelcome();
});
welcomeLeame.addEventListener('click', showReadme);

// Al presionar la X de bienvenida, mostramos el diálogo de salida.
closeWelcome.addEventListener('click', function() {
  showExitModal('Para utilizar MDV SWIM CHRONO es necesario validar una licencia.');
});

if (welcomeExitBtn) {
  welcomeExitBtn.addEventListener('click', function() {
    performExit();
  });
}

// No cerramos la bienvenida haciendo clic fuera del modal.
welcomeOverlay.addEventListener('click', function(e) {
  // Bloquear interacción por fuera sin cerrar
  e.stopPropagation();
});

closeReadme.addEventListener('click', hideReadme);
readmeBack.addEventListener('click', hideReadme);
readmeOverlay.addEventListener('click', hideReadme);
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (readmeModal.style.display === 'block') {
      hideReadme();
    } else if (welcomeModal.style.display === 'block' || (licenseModal && licenseModal.style.display === 'block')) {
      showExitModal('Para utilizar MDV SWIM CHRONO es necesario validar una licencia.');
    }
  }
});


const helpBtn = document.getElementById('helpBtn');
helpBtn.addEventListener('click', showWelcome);

showWelcome();

exportCsvBtn.addEventListener('click', exportToXLS);
exportPdfBtn.addEventListener('click', exportToPDF);

resetBtn.onclick = resetEnvironment;
const btnDownloadCfg = document.getElementById("downloadConfigBtn");
const btnSaveTemplate = document.getElementById("saveTemplateBtn");

if (btnDownloadCfg) btnDownloadCfg.onclick = () => {
  const cfg = captureConfigFromModal_();
  if (!normalizeConfig(cfg)) { showToastBanner('Configuración inválida'); return; }
  // No muta el estado de la app: descarga solo configuración
  const data = { kind:'template', stage:'template', config: cfg, date: new Date().toISOString() };
  const fname = ((cfg && cfg.name) ? cfg.name : 'config').toString().trim().replace(/[^\w\-]+/g,'_') + '_config.json';
  downloadJson_(data, fname);
};

if (btnSaveTemplate) btnSaveTemplate.onclick = () => {
  const cfg = captureConfigFromModal_();
  if (!normalizeConfig(cfg)) { showToastBanner('Configuración inválida'); return; }
  const label = prompt('Nombre de la plantilla (opcional):', (cfg && cfg.name) ? cfg.name : 'Plantilla');
  saveTemplateToLocal_(cfg, label, false);
  // Actualiza config activa para que quede persistida
  config = cfg;
  storeLastConfig_();
  showToastBanner('Plantilla guardada');
};

numSwimmersInput.addEventListener('change', handleNumSwimmersChange);
numPartialsInput.addEventListener('change', handleNumPartialsChange);
numPartialsInput.addEventListener('input', handleNumPartialsChange);
const totalDistInput_ = document.getElementById('totalDist');
if (totalDistInput_) totalDistInput_.addEventListener('input', () => handleNumPartialsChange({ target: numPartialsInput }));


// =========================================================
// MDV COACH 360º · CONECTOR (V1)
// =========================================================
(function initCoachConnector(){
  const LS_KEY = "mdv_coach_connector_v1";
  const btn = document.getElementById("coachConnectorBtn");
  const modal = document.getElementById("coachConnectorModal");
  if (!btn || !modal) return;

  const elUrl = document.getElementById("cc_url");
  const elCoach = document.getElementById("cc_coachId");
  const elInstId = document.getElementById("cc_instId");
  const elInstKey = document.getElementById("cc_instKey");
  const elStatus = document.getElementById("cc_status");
  const btnTest = document.getElementById("cc_test");
  const btnSave = document.getElementById("cc_save");
  const btnDisable = document.getElementById("cc_disable");
  const btnClose = document.getElementById("cc_close");
  const btnClose2 = document.getElementById("cc_close2");

  const tabBtns = Array.from(modal.querySelectorAll(".cc-tabbtn") || []);
  const tabConnect = document.getElementById("ccTabConnect");
  const tabMigrations = document.getElementById("ccTabMigrations");

  const elPendingList = document.getElementById("ccMigPendingList");
  const elSyncedList = document.getElementById("ccMigSyncedList");
  const btnMigRefresh = document.getElementById("ccMigRefreshBtn");
  const btnMigClearSynced = document.getElementById("ccMigClearSyncedBtn");
  const elMigBadge = document.getElementById("ccMigBadge");
  const btnMigSelectAll = document.getElementById("ccMigSelectAllBtn");
  const btnMigClearSel = document.getElementById("ccMigClearSelBtn");
  const btnMigSendSelected = document.getElementById("ccMigSendSelectedBtn");

  let __ccSelectedPending = new Set(); // guarda local_id (o idx fallback) de pendientes seleccionados


  const LS_PENDING = "mdv_chrono_pending_migrations_v1";
  const LS_SYNCED = "mdv_chrono_synced_migrations_v1";
  const LS_CC_TAB = "mdv_coach_connector_tab_v1";

  function readList_(key){
    try{
      const raw = localStorage.getItem(key);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    }catch(e){ return []; }
  }
  function writeList_(key, arr){
    try{ localStorage.setItem(key, JSON.stringify(Array.isArray(arr)?arr:[])); }catch(e){}
  }
  function getEntryKey_(item, idx){
    const id = (item && (item.local_id || item.id || item._id)) ? String(item.local_id || item.id || item._id) : "";
    return id || ("idx_" + idx);
  }

  async function postWebAppCC_(baseUrl, data){
    const url = (baseUrl||"").trim();
    if (!url) return {status:"error", ok:false, message:"URL WebApp vacía."};
    const controller = new AbortController();
    const to = setTimeout(() => controller.abort(), 35000);
    try{
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify(data||{}),
        signal: controller.signal
      });
      const txt = await res.text();
      let j = null;
      try { j = JSON.parse(txt); } catch(e) { j = {status:"error", ok:false, message:"Respuesta no-JSON", raw: txt}; }
      return j;
    }catch(err){
      return {status:"error", ok:false, message:String(err)};
    }finally{
      clearTimeout(to);
    }
  }

  async function bulkSendSelectedMigrations_(){
    try{
      load();
      const cc = window.__mdvCoachConnector || {};
      const url = (cc.url||"").trim();
      if (!cc.enabled || !url){
        if (typeof showToastBanner === "function") showToastBanner("Conector no configurado.");
        return;
      }

      const pending = readList_(LS_PENDING);
      const selected = pending.filter((it, idx) => __ccSelectedPending.has(getEntryKey_(it, idx)));

      if (!selected.length){
        if (typeof showToastBanner === "function") showToastBanner("No hay pendientes seleccionados.");
        return;
      }

      let okCount = 0, errCount = 0, skipCount = 0;
      let lastErr = "";

      for (let i=0; i<selected.length; i++){
        const entry = selected[i] || {};
        const coach_id = String(entry.coach_id || cc.coach_id || "").trim();
        if (!coach_id){
          errCount++;
          lastErr = lastErr || "MISSING_COACH_ID";
          continue;
        }
        const payloadFull = entry.payload || null;
        if (!payloadFull){
          errCount++;
          lastErr = lastErr || "MISSING_PAYLOAD";
          continue;
        }

        let payloadToSend = null;
        try{ payloadToSend = JSON.parse(JSON.stringify(payloadFull)); }catch(e){ payloadToSend = payloadFull; }

        try{
          payloadToSend.swimmers = (payloadToSend.swimmers||[]).filter(sw => {
            if (!sw) return false;
            const hasId = !!String(sw.swimmer_id||"").trim();
            const want = (sw.migrate_to_marks === true || sw.migrate_to_marks == 1 || String(sw.migrate_to_marks||"").toLowerCase()==="true");
            return hasId && want;
          });
        }catch(e){}

        if (!payloadToSend || !payloadToSend.swimmers || !payloadToSend.swimmers.length){
          skipCount++;
          continue;
        }

        if (typeof showToastBanner === "function") showToastBanner(`Migrando ${i+1}/${selected.length}…`);

        const common = { coach_id, institution_id: (cc.institution_id||""), institution_key: (cc.institution_key||"") };

                // Ensure bandeja CHRONO IMPORTS (no bloqueante: compat con scripts viejos)
        let r0 = null;
        let ensureOk = false;
        const ensureActions = ["ensure_chrono_imports_sheet", "ensure_chrono_imports", "ensure_imports_sheet", "ensure_chrono_imports_tab"];
        for (const actName of ensureActions){
          r0 = await postWebAppCC_(url, Object.assign({ action: actName }, common));
          ensureOk = !!(r0 && ((r0.status && String(r0.status).toLowerCase()==="ok") || r0.ok===true));
          if (ensureOk) break;
        }
        // Si falla, seguimos igual y dejamos que chrono_import intente crear la hoja
const r1 = await postWebAppCC_(url, Object.assign({ action:"chrono_import", series_json: JSON.stringify(payloadToSend) }, common));
        
        if (!r1 || !(((r1.status && String(r1.status).toLowerCase()==="ok")) || r1.ok===true)){

          errCount++;
          lastErr = shortErr_(r1) || lastErr;
          continue;
        }

        const import_id = (r1 && (r1.import_id || r1.importId || r1.id)) ? String(r1.import_id || r1.importId || r1.id) : "";

        // mover: pendiente -> sincronizado
        try{
          const curPending = readList_(LS_PENDING);
          const curSynced = readList_(LS_SYNCED);

          const localId = String(entry.local_id || (payloadFull && payloadFull.meta && payloadFull.meta.chrono_local_id) || "").trim();
          const syncedEntry = Object.assign({}, entry, { import_id, status:"sent_to_imports", ts: new Date().toISOString() });
          if (localId && !syncedEntry.local_id) syncedEntry.local_id = localId;

          curSynced.unshift(syncedEntry);
          const nextPending = localId
            ? curPending.filter(x => String((x && (x.local_id||""))).trim() !== localId)
            : curPending.filter(x => x !== entry);

          writeList_(LS_SYNCED, curSynced.slice(0, 80));
          writeList_(LS_PENDING, nextPending.slice(0, 60));

          if (localId) __ccSelectedPending.delete(localId);
        }catch(e){}

        okCount++;
      }

      __ccSelectedPending.clear();
      renderMigrationsPanel_();

      if (typeof showToastBanner === "function"){
        showToastBanner(`Migración: OK ${okCount} · Omitidos ${skipCount} · Errores ${errCount}` + (errCount>0 && lastErr ? ` · Último: ${lastErr}` : ""));
      }
    }catch(err){
      if (typeof showToastBanner === "function") showToastBanner("Error en migración masiva.");
      console.error(err);
    }
  }

  function fmtTs_(iso){
    try{
      const d = iso ? new Date(iso) : new Date();
      if (isNaN(d.getTime())) return String(iso||"");
      const pad = (n)=> String(n).padStart(2,"0");
      return `${pad(d.getDate())}/${pad(d.getMonth()+1)} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
    }catch(e){
      return String(iso||"");
    }
  }

  function escCC_(s){
    return String(s==null? "" : s).replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[ch]));
  }

  function shortErr_(obj){
    try{
      if (!obj) return "";
      const parts = [];
      const msg = (obj.message || obj.msg || obj.error || obj.err || "").toString().trim();
      if (msg) parts.push(msg);
      const st = (obj.status || "").toString().trim();
      if (st && st !== "ok" && st !== msg) parts.push("status=" + st);
      const code = (obj.code || "").toString().trim();
      if (code) parts.push("code=" + code);
      const sheet = (obj.sheet || obj.sheetName || obj.sheet_name || "").toString().trim();
      if (sheet) parts.push("sheet=" + sheet);
      const raw = (obj.raw || obj.details || obj.reason || "").toString().trim();
      if (raw && raw !== msg) parts.push(raw);

      let s = parts.filter(Boolean).join(" · ").replace(/\s+/g," ").trim();
      if (!s) return "";
      if (s.length > 160) s = s.slice(0,157) + "…";
      return s;
    }catch(e){
      return "";
    }
  }

  function summarizeEntry_(entry){
    const p = entry && entry.payload ? entry.payload : null;
    const meta = p && p.meta ? p.meta : {};
    const serie = meta.series_name || meta.name || meta.serie_name || "Serie";
    const dist = meta.distance_total || meta.distance_m || meta.distance || "";
    const tipo = entry.tipo_toma || meta.type || "";
    const coach = entry.coach_id || meta.coach_id || "";
    const swimmers = (p && Array.isArray(p.swimmers)) ? p.swimmers : [];
    const linked = swimmers.filter(sw => sw && String(sw.swimmer_id||"").trim()).length;
    return { serie, dist, tipo, coach, swimmersCount: swimmers.length, linkedCount: linked, ts: entry.ts || meta.ts || meta.date || "" };
  }

  function setTab_(name){
    const tab = (name === "migrations") ? "migrations" : "connect";
    tabBtns.forEach(b => b.classList.toggle("active", (b.getAttribute("data-cc-tab")||"") === tab));
    if (tabConnect) tabConnect.classList.toggle("active", tab === "connect");
    if (tabMigrations) tabMigrations.classList.toggle("active", tab === "migrations");
    try{ localStorage.setItem(LS_CC_TAB, tab); }catch(e){}
    if (tab === "migrations") renderMigrationsPanel_();
  }

  function renderMigrationsPanel_(){
    if (!elPendingList || !elSyncedList) return;

    const pending = readList_(LS_PENDING);
    const synced = readList_(LS_SYNCED);

    // Badge con cantidad pendientes
    try{
      const n = pending.length;
      if (elMigBadge){
        elMigBadge.style.display = n ? "inline-block" : "none";
        elMigBadge.textContent = String(n);
      }
    }catch(e){}

    function renderListInto_(el, arr, kind){
      if (!arr || !arr.length){
        el.innerHTML = `<div style="color:#6b7280; font-size:13px; padding:6px 2px;"><i>Sin registros</i></div>`;
        return;
      }
      el.innerHTML = arr.map((item, idx) => {
        const id = (item && (item.local_id || item.id || item._id)) ? String(item.local_id || item.id || item._id) : "";
        const key = id || ("idx_" + idx);
        const isChecked = (kind === "pending") && __ccSelectedPending && __ccSelectedPending.has(key);
        const chkHtml = (kind === "pending") ? `<input type="checkbox" class="cc-mig-chk" data-key="${escCC_(key)}" ${isChecked ? "checked" : ""}>` : "";
        const s = summarizeEntry_(item);
        const badgeClass = (kind === "pending") ? "pending" : "synced";
        const badgeText = (kind === "pending") ? "Pendiente" : "Sincronizado";
        const imp = (item && item.import_id) ? String(item.import_id) : "";
        const line2 = [
          s.dist ? `${s.dist}m` : "",
          s.tipo ? s.tipo : "",
          (s.swimmersCount!=null ? `Nadadores: ${s.swimmersCount}` : ""),
          (s.linkedCount!=null ? `Vinculados: ${s.linkedCount}` : "")
        ].filter(Boolean).join(" · ");
        const line3 = [
          s.coach ? `Coach: ${s.coach}` : "",
          imp ? `import_id: ${imp}` : ""
        ].filter(Boolean).join(" · ");

        return `
          <div class="cc-mig-item" data-kind="${kind}" data-idx="${idx}">
            <div class="cc-mig-row">
              <div style="display:flex; align-items:center; gap:10px;">${chkHtml}<div class="cc-mig-title">${escCC_(fmtTs_(item.ts))} · ${escCC_(s.serie)}</div></div>
              <span class="cc-badge ${badgeClass}">${badgeText}</span>
            </div>
            <div class="cc-mig-meta">${escCC_(line2)}${line3?`<br>${escCC_(line3)}`:""}</div>
            <div class="cc-mig-actions">
              <button type="button" class="cc-open-mig primary" data-kind="${kind}" data-idx="${idx}">Abrir / Editar</button>
              <button type="button" class="cc-del-mig danger" data-kind="${kind}" data-idx="${idx}">Eliminar</button>
            </div>
          </div>
        `;
      }).join("");
    }

    renderListInto_(elPendingList, pending, "pending");
    renderListInto_(elSyncedList, synced, "synced");

    // Selección (checkbox) y click en item
    try{
      Array.from(modal.querySelectorAll("input.cc-mig-chk")).forEach(chk => {
        chk.onclick = (ev)=>{ try{ ev.stopPropagation(); }catch(e){} };
        chk.onchange = ()=> {
          const key = (chk.getAttribute("data-key")||"").trim();
          if (!key) return;
          if (chk.checked) __ccSelectedPending.add(key);
          else __ccSelectedPending.delete(key);
        };
      });

      Array.from(modal.querySelectorAll(".cc-mig-item")).forEach(div => {
        div.onclick = (ev)=>{
          try{
            if (ev && ev.target && (ev.target.closest("button") || ev.target.closest("input"))) return;
          }catch(e){}
          const btn = div.querySelector("button.cc-open-mig");
          if (btn) btn.click();
        };
      });
    }catch(e){}

    // listeners Abrir/Eliminar
    Array.from(modal.querySelectorAll("button.cc-open-mig")).forEach(b => {
      b.addEventListener("click", () => {
        const kind = b.getAttribute("data-kind");
        const idx = parseInt(b.getAttribute("data-idx")||"-1",10);
        const arr = readList_(kind === "pending" ? LS_PENDING : LS_SYNCED);
                const entry = (idx>=0 && idx < arr.length) ? arr[idx] : null;
        if (!entry){
          if (typeof showToastBanner === "function") showToastBanner("No se encontró el registro.");
          renderMigrationsPanel_();
          return;
        }
        if (window.__mdvOpenMigrationFromSaved){
          close(); // cierra el modal del conector
          window.__mdvOpenMigrationFromSaved(entry, kind);
        } else {
          if (typeof showToastBanner === "function") showToastBanner("El modal de migración aún no está listo.");
        }
      });
    });
    Array.from(modal.querySelectorAll("button.cc-del-mig")).forEach(b => {
      b.addEventListener("click", () => {
        const kind = b.getAttribute("data-kind");
        const idx = parseInt(b.getAttribute("data-idx")||"-1",10);
        const key = (kind === "pending") ? LS_PENDING : LS_SYNCED;
                const arr = readList_(key);
        if (idx>=0 && idx < arr.length) arr.splice(idx, 1);
        writeList_(key, arr);
        renderMigrationsPanel_();
      });
    });
  }


  function load(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      const cfg = raw ? JSON.parse(raw) : null;
      if (cfg && cfg.enabled){
        window.__mdvCoachConnector = window.__mdvCoachConnector || {};
        Object.assign(window.__mdvCoachConnector, cfg);
      } else {
        window.__mdvCoachConnector = window.__mdvCoachConnector || {enabled:false, swimmers:[]};
      }
    } catch(err){
      window.__mdvCoachConnector = {enabled:false, swimmers:[]};
    }
  }
  function save(cfg){
    localStorage.setItem(LS_KEY, JSON.stringify(cfg));
    window.__mdvCoachConnector = cfg;
  }
  function open(){
    load();
    const cfg = window.__mdvCoachConnector || {};
    elUrl.value = cfg.url || "";
    elCoach.value = cfg.coach_id || "";
    elInstId.value = cfg.institution_id || "";
    elInstKey.value = cfg.institution_key || "";
    elStatus.textContent = cfg.enabled ? ("Activo · Nadadores: " + ((cfg.swimmers||[]).length||0)) : "Sin probar";
    try{
      const t = document.getElementById("ccQuickToggle");
      const w = document.querySelector(".cc-toggle");
      if (t) t.checked = !!cfg.enabled;
      if (w) w.classList.toggle("on", !!cfg.enabled);
    } catch(e) {}
modal.style.display = "block";

    // actualizar badge + listas de migración (si existen)
    try{ renderMigrationsPanel_(); }catch(e){}

    // restaurar última pestaña usada
    try{
      const lastTab = (localStorage.getItem(LS_CC_TAB)||"").trim() || "connect";
      setTab_(lastTab === "migrations" ? "migrations" : "connect");
    }catch(e){
      setTab_("connect");
    }
  }
  function close(){ modal.style.display = "none"; }

  async function testConnection(){
    const url = (elUrl.value||"").trim();
    const coach_id = (elCoach.value||"").trim();
    if (!url || !coach_id){
      elStatus.textContent = "Faltan datos: URL y Coach ID.";
      return;
    }
    elStatus.textContent = "Probando conexión…";
    try{
      const qs = new URLSearchParams({ action:"get_swimmers", coach_id });
      // institution params are ignored by the coach script today; kept for future
      if (elInstId.value.trim()) qs.set("institution_id", elInstId.value.trim());
      if (elInstKey.value.trim()) qs.set("institution_key", elInstKey.value.trim());

      const res = await fetch(url + (url.includes("?") ? "&" : "?") + qs.toString(), { method:"GET" });
      const data = await res.json();
      if (!data || data.status !== "ok"){
        elStatus.textContent = "Error: respuesta inválida del script.";
        return;
      }
      const swimmers = Array.isArray(data.swimmers) ? data.swimmers : [];
      elStatus.textContent = "OK · Nadadores: " + swimmers.length;
      // keep in memory for renderSwimmers()
      window.__mdvCoachConnector = window.__mdvCoachConnector || {};
      window.__mdvCoachConnector.swimmers = swimmers;
      // Persist cache para uso offline / reconexión rápida
      try{
        const prev = window.__mdvCoachConnector || {};
        const next = Object.assign({}, prev, {
          url:(elUrl.value||"").trim(),
          coach_id:(elCoach.value||"").trim(),
          institution_id:(elInstId.value||"").trim(),
          institution_key:(elInstKey.value||"").trim(),
          swimmers,
          last_ok_ts: Date.now()
        });
        localStorage.setItem(LS_KEY, JSON.stringify(next));
        window.__mdvCoachConnector = next;
      } catch(e) {}
    } catch(err){
      elStatus.textContent = "Error al conectar (CORS / URL / permisos).";
      console.error(err);
    }
  }

  btn.addEventListener("click", () => {
    // check license attrs if available
    const attrs = (window.__mdvLicense && window.__mdvLicense.attrs) ? window.__mdvLicense.attrs : null;
    if (attrs && attrs.allow_chrono_connector === false){
      alert("Tu licencia no tiene habilitado el CONECTOR de MDV COACH 360º.");
      return;
    }
    open();
  });
  btnClose.addEventListener("click", close);
  if (btnClose2) btnClose2.addEventListener("click", close);

  // pestañas
  tabBtns.forEach(b => {
    b.addEventListener("click", () => {
      const t = (b.getAttribute("data-cc-tab")||"").trim();
      setTab_(t);
    });
  });

  // acciones migración
  if (btnMigRefresh) btnMigRefresh.addEventListener("click", () => renderMigrationsPanel_());
  if (btnMigClearSynced) btnMigClearSynced.addEventListener("click", () => {
    const ok = confirm("¿Borrar el historial de sincronizados en este dispositivo?");
    if (!ok) return;
    try{ localStorage.removeItem(LS_SYNCED); }catch(e){}
    renderMigrationsPanel_();
  });

  if (btnMigSelectAll) btnMigSelectAll.addEventListener("click", () => {
    const pending = readList_(LS_PENDING);
    __ccSelectedPending = new Set(pending.map((it, idx) => getEntryKey_(it, idx)));
    renderMigrationsPanel_();
  });

  if (btnMigClearSel) btnMigClearSel.addEventListener("click", () => {
    __ccSelectedPending.clear();
    renderMigrationsPanel_();
  });

  if (btnMigSendSelected) btnMigSendSelected.addEventListener("click", async () => {
    const ok = confirm("¿Enviar a CHRONO IMPORTS los pendientes seleccionados?");
    if (!ok) return;
    await bulkSendSelectedMigrations_();
  });

  btnTest.addEventListener("click", testConnection);

  btnSave.addEventListener("click", async () => {
    await testConnection();
    const cfg = {
      enabled:true,
      url:(elUrl.value||"").trim(),
      coach_id:(elCoach.value||"").trim(),
      institution_id:(elInstId.value||"").trim(),
      institution_key:(elInstKey.value||"").trim(),
      swimmers:(window.__mdvCoachConnector && Array.isArray(window.__mdvCoachConnector.swimmers)) ? window.__mdvCoachConnector.swimmers : []
    };
    save(cfg);
    try{ setToggleUI(true); }catch(e){}
    renderSwimmers(); // refresh config UI if open
    elStatus.textContent = "Guardado · Nadadores: " + (cfg.swimmers||[]).length;
  });

  btnDisable.addEventListener("click", async () => {
    const prev = window.__mdvCoachConnector || {};
    const desired = !prev.enabled;

    if (desired){
      // Activar (si faltan datos, no permite)
      if (!(prev.url||"").trim() || !(prev.coach_id||"").trim()){
        if (typeof showToastBanner === "function") showToastBanner("Para activar: completá URL y Coach ID y presioná Guardar.");
        setToggleUI(false);
        return;
      }
      const next = Object.assign({}, prev, { enabled:true });
      save(next);
      elStatus.textContent = "Activado (datos conservados)";
      setToggleUI(true);
      if (typeof showToastBanner === "function") showToastBanner("MDV COACH 360º · CONECTOR: ON");
      // refresca cache de nadadores si está vacío
      if (!Array.isArray(next.swimmers) || next.swimmers.length===0){
        try{ await refreshFromCfg(next); }catch(e){}
      }
      renderSwimmers();
      return;
    }

    // Desactivar SIN borrar datos (persistencia local)
    const next = Object.assign({}, prev, { enabled:false });
    save(next);
    elStatus.textContent = "Desactivado (datos conservados)";
    setToggleUI(false);
    if (typeof showToastBanner === "function") showToastBanner("MDV COACH 360º · CONECTOR: OFF (se conservan URL/Coach/Institución).");
    renderSwimmers();
  });

  // close on outside click
  window.addEventListener("click", (e)=>{ if (e.target === modal) close(); });

  // Quick toggle in toolbar (ON/OFF sin abrir modal)
  const quickToggle = document.getElementById("ccQuickToggle");
  const quickWrap = document.querySelector(".cc-toggle");
  async function refreshFromCfg(cfg){
    const url = (cfg.url||"").trim();
    const coach_id = (cfg.coach_id||"").trim();
    if (!url || !coach_id) return {ok:false, message:"Faltan URL o Coach ID."};
    try{
      const qs = new URLSearchParams({ action:"get_swimmers", coach_id });
      if ((cfg.institution_id||"").trim()) qs.set("institution_id", (cfg.institution_id||"").trim());
      if ((cfg.institution_key||"").trim()) qs.set("institution_key", (cfg.institution_key||"").trim());
      const res = await fetch(url + (url.includes("?") ? "&" : "?") + qs.toString(), { method:"GET" });
      const data = await res.json();
      if (!data || data.status !== "ok") return {ok:false, message:"Respuesta inválida del script."};
      const swimmers = Array.isArray(data.swimmers) ? data.swimmers : [];
      const prev = window.__mdvCoachConnector || cfg || {};
      const next = Object.assign({}, prev, cfg, { swimmers, last_ok_ts: Date.now() });
      save(next);
      return {ok:true, swimmers};
    } catch(err){
      console.error(err);
      return {ok:false, message:"No se pudo conectar (CORS / URL / permisos)."};
    }
  }
  function setToggleUI(on){
    if (quickToggle) quickToggle.checked = !!on;
    if (quickWrap) quickWrap.classList.toggle("on", !!on);
    // sincroniza botón del modal (Activar/Desactivar)
    try{
      if (btnDisable){
        btnDisable.textContent = on ? "Desactivar" : "Activar";
        btnDisable.title = on
          ? "Desactiva el conector y vuelve a modo manual (conserva datos)"
          : "Activa el conector (usa los últimos datos guardados)";
      }
    }catch(e){}
  }
  if (quickToggle){
    // init state from stored cfg
    try{ load(); } catch(e){}
    const cfg0 = window.__mdvCoachConnector || {};
    setToggleUI(!!cfg0.enabled);

    quickToggle.addEventListener("change", async () => {
      const desired = !!quickToggle.checked;
      const prev = window.__mdvCoachConnector || {};
      if (desired){
        if (!(prev.url||"").trim() || !(prev.coach_id||"").trim()){
          setToggleUI(false);
          if (typeof showToastBanner === "function") showToastBanner("Configurar CONECTOR (MDV COACH 360º): faltan URL o Coach ID.");
          open(); // abre modal para completar datos
          return;
        }
        const next = Object.assign({}, prev, { enabled:true });
        save(next);
        setToggleUI(true);
        if (typeof showToastBanner === "function") showToastBanner("MDV COACH 360º · CONECTOR: ON");
        // Si no hay swimmers cacheados, intenta refrescar
        if (!Array.isArray(next.swimmers) || next.swimmers.length===0){
          const r = await refreshFromCfg(next);
          if (r.ok){
            if (typeof showToastBanner === "function") showToastBanner("Conectado · Nadadores: " + r.swimmers.length);
          } else {
            if (typeof showToastBanner === "function") showToastBanner("Conector ON (offline) · " + r.message);
          }
        }
        renderSwimmers();
      } else {
        const next = Object.assign({}, prev, { enabled:false });
        save(next);
        setToggleUI(false);
        if (typeof showToastBanner === "function") showToastBanner("MDV COACH 360º · CONECTOR: OFF");
        renderSwimmers();
      }
    });
  }

  load();
})();


// =========================================================
// MIGRACIÓN (CHRONO -> MDV COACH 360º) · Modal de confirmación
// =========================================================
(function initChronoMigrationToCoach(){
  const LS_CC = "mdv_coach_connector_v1";
  const LS_PENDING = "mdv_chrono_pending_migrations_v1";

  const migOverlay = document.getElementById("migOverlay");
  const migModal = document.getElementById("migrationModal");
  if (!migOverlay || !migModal) return;

  const elCoachId = document.getElementById("migCoachId");
  const elSerieName = document.getElementById("migSerieName");
  const elDate = document.getElementById("migDate");
  const elCoachUrl = document.getElementById("migCoachUrl");
  const elDistance = document.getElementById("migDistance");
  const elStyle = document.getElementById("migStyle");
  const elStyleCustomWrap = document.getElementById("migStyleCustomWrap");
  const elStyleCustom = document.getElementById("migStyleCustom");

  const elTipo = document.getElementById("migTipoToma");
  const elLugar = document.getElementById("migLugar");
  const elNota = document.getElementById("migNota");
  const elList = document.getElementById("migSwimmerList");
  const elJson = document.getElementById("migJson");
  const elStatus = document.getElementById("migStatus");

  const btnSend = document.getElementById("migSend");
  const btnPending = document.getElementById("migPending");
  const btnLater = document.getElementById("migLater");
  const btnClose = document.getElementById("closeMigration");

  let lastPayload = null;
  let currentSavedRef = null; // usado al abrir desde lista pendiente/sincronizada

  // --- Editor rápido por nadador (pre-envío) ---
  const migEditModal = document.getElementById("migEditModal");
  const migEditMsg = document.getElementById("migEditMsg");
  const migEditName = document.getElementById("migEditName");
  const migEditId = document.getElementById("migEditId");
  const migEditLane = document.getElementById("migEditLane");
  const migEditOrder = document.getElementById("migEditOrder");
  const migEditTotal = document.getElementById("migEditTotal");
  const migEditSplitsBody = document.getElementById("migEditSplitsBody");
  const btnCloseMigEdit = document.getElementById("closeMigEdit");
  const btnMigEditCancel = document.getElementById("migEditCancel");
  const btnMigEditSave = document.getElementById("migEditSave");

  let migEditingIdx = null;

  function sleep_(ms){ return new Promise(r => setTimeout(r, ms)); }

  function parseTimeToMs_(raw){
    const s0 = (raw==null? "" : String(raw)).trim();
    if (!s0) return null;
    let s = s0.replace(",", ".").replace(/\s+/g,"");
    // Si viene "13104" (legacy ms), interpretarlo como ms cuando es un entero >= 1000
    if (!s.includes(":") && !s.includes(".") && /^\d+$/.test(s)){
      const n = Number(s);
      if (!isFinite(n)) return null;
      return (n >= 1000) ? n : Math.round(n * 1000);
    }
    // permitir mm:ss(.cc) o ss(.cc)
    let mins = 0;
    let secPart = s;
    if (s.includes(":")){
      const parts = s.split(":");
      if (parts.length >= 2){
        mins = Number(parts[0]);
        secPart = parts.slice(1).join(":");
      }
    }
    if (!isFinite(mins)) mins = 0;
    let secs = Number(secPart);
    if (!isFinite(secs)) return null;
    const ms = Math.round((mins*60 + secs) * 1000);
    return ms >= 0 ? ms : null;
  }


  function fmt_(ms){
    const n = Number(ms);
    if (!isFinite(n)) return "";
    try{
      if (typeof window.format === "function") return window.format(n);
    }catch(e){}
    const cs = Math.floor(n / 10) % 100,
          s = Math.floor(n / 1000) % 60,
          m = Math.floor(n / 60000);
    return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${cs.toString().padStart(2, '0')}`;
  }


  function normalizeTimeStr_(v){
    if (v==null) return "";
    const s = String(v).trim();
    if (!s) return "";
    // Legacy: si viene en ms como entero "13104"
    if (!s.includes(":") && !s.includes(".") && /^\d+$/.test(s)){
      const n = Number(s);
      if (isFinite(n) && n >= 0){
        return fmt_(n >= 1000 ? n : Math.round(n*1000));
      }
    }
    return s;
  }

function escHtml_(v){
    const s = String(v ?? "");
    try{
      if (typeof window.escapeHtml_ === "function") return window.escHtml_(s);
    }catch(e){}
    return s.replace(/[&<>"'`]/g, ch => ({
      '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;', '`': '&#96;'
    }[ch] || ch));
  }



  function openMigEdit_(idx){
    if (!migEditModal) return;
    if (!lastPayload || !Array.isArray(lastPayload.swimmers) || !lastPayload.swimmers[idx]) return;
    const sw = lastPayload.swimmers[idx];
    migEditingIdx = idx;

    if (migEditMsg) migEditMsg.textContent = "";
    if (migEditName) migEditName.value = sw.name || "";
    if (migEditId) migEditId.value = sw.swimmer_id || "";
    if (migEditLane) migEditLane.value = sw.lane || "";
    if (migEditOrder) migEditOrder.value = sw.order || "";
    if (migEditTotal) migEditTotal.value = normalizeTimeStr_(sw.total_time_str || (sw.total_time_ms!=null ? fmt_(sw.total_time_ms) : ""));

    // render splits
    if (migEditSplitsBody){
      let rows = "";
      const parts = Array.isArray(sw.partials) ? sw.partials : [];
      for (let j=0; j<parts.length; j++){
        const p = parts[j] || {};
        const idxLabel = (p.label ? String(p.label) : ("P" + (p.idx || (j+1))));
        const A = (p.distance!=null ? String(p.distance) : "-");
        const D = (p.split_distance!=null ? String(p.split_distance) : "-");
        const acum = normalizeTimeStr_(p.t_acum_str || (p.t_acum_ms!=null ? fmt_(p.t_acum_ms) : "")); const tramo = (p.t_split_ms!=null ? fmt_(p.t_split_ms) : "-");
        const strokes = (p.strokes!=null ? String(p.strokes) : "");
        // Mostrar SWOLF aunque no haya quedado persistido: si hay brazadas + tiempo de tramo, lo recalculamos
        let swolfVal = (p.swolf!=null ? p.swolf : null);
        if (swolfVal==null && p.strokes!=null && p.t_split_ms!=null){
          try{ swolfVal = calcSwolf_(p.t_split_ms, p.strokes); p.swolf = swolfVal; }catch(e){}
        }
        const swolf = (swolfVal!=null ? String(swolfVal) : "");
        rows += `<tr style="border-top:1px solid #f3f4f6;">
          <td style="padding:8px;"><b>${idxLabel}</b></td>
          <td style="padding:8px;"><small style="color:#6b7280;">D:${D}m · A:${A}m</small></td>
          <td style="padding:8px;">
            <input class="mig-edit-acum" data-j="${j}" type="text" style="width:120px;" value="${escHtml_(acum)}">
          </td>
          <td style="padding:8px;"><small style="color:#6b7280;">${escHtml_(tramo)}</small></td>
          <td style="padding:8px;"><input class="mig-edit-strokes" data-j="${j}" type="number" min="0" step="1" style="width:90px;" value="${escHtml_(strokes)}"></td>
          <td style="padding:8px;"><small class="mig-swolf" data-j="${j}" style="color:#111827;">${escHtml_(swolf||"-")}</small></td>
        </tr>`;
      }
      migEditSplitsBody.innerHTML = rows || `<tr><td colspan="6" style="padding:10px; color:#6b7280;"><i>Sin parciales</i></td></tr>`;
    }

    migEditModal.style.display = "flex"; document.body.classList.add("modal-open");
  }

  function closeMigEdit_(){
    if (!migEditModal) return;
    migEditModal.style.display = "none"; if (!migModal || migModal.style.display==="none"){ document.body.classList.remove("modal-open"); }
    migEditingIdx = null;
  }

  function applyMigEditSave_(){
    if (migEditingIdx==null) return;
    if (!lastPayload || !Array.isArray(lastPayload.swimmers) || !lastPayload.swimmers[migEditingIdx]) return;

    const sw = lastPayload.swimmers[migEditingIdx];
    sw.name = migEditName ? String(migEditName.value||"").trim() : (sw.name||"");
    sw.lane = migEditLane ? String(migEditLane.value||"").trim() : (sw.lane||"");
    sw.order = migEditOrder ? String(migEditOrder.value||"").trim() : (sw.order||"");

    const totalMs = migEditTotal ? parseTimeToMs_(migEditTotal.value) : null;
    if (totalMs!=null){
      sw.total_time_ms = totalMs;
      sw.total_time_str = fmt_(totalMs);
    }

    const parts = Array.isArray(sw.partials) ? sw.partials : [];

    // 1) tiempos acumulados
    const acumInputs = migEditModal ? Array.from(migEditModal.querySelectorAll("input.mig-edit-acum")) : [];
    acumInputs.forEach(inp => {
      const j = Number(inp.getAttribute("data-j")||"");
      if (!isFinite(j) || !parts[j]) return;
      const ms = parseTimeToMs_(inp.value);
      if (ms==null) return;
      parts[j].t_acum_ms = ms;
      parts[j].t_acum_str = fmt_(ms);
    });

    // 2) brazadas
    const strokeInputs = migEditModal ? Array.from(migEditModal.querySelectorAll("input.mig-edit-strokes")) : [];
    strokeInputs.forEach(inp => {
      const j = Number(inp.getAttribute("data-j")||"");
      if (!isFinite(j) || !parts[j]) return;
      const v = Number(String(inp.value||'').replace(',', '.'));
      parts[j].strokes = (isFinite(v) && v>=0) ? Math.round(v) : null;
    });

    // 3) recomputar splits, velocidad y swolf
    for (let j=0; j<parts.length; j++){
      const p = parts[j] || {};
      const prev = (j===0) ? 0 : Number((parts[j-1] && parts[j-1].t_acum_ms) || 0);
      const cur = Number(p.t_acum_ms || 0);
      const tSplit = cur - prev;
      p.t_split_ms = (isFinite(tSplit) ? tSplit : null);
      const dist = Number(p.split_distance || 0);
      p.v_mps = (tSplit>0 && dist>0) ? Number((dist / (tSplit/1000)).toFixed(3)) : null;
      p.swolf = (p.strokes!=null) ? calcSwolf_(tSplit, p.strokes) : null;

      // actualizar celda SWOLF en el modal (sin reabrir)
      const cell = migEditModal ? migEditModal.querySelector(`.mig-swolf[data-j="${j}"]`) : null;
      if (cell) cell.textContent = (p.swolf!=null ? String(p.swolf) : "-");
    }

    sw.partials = parts;

    try { elJson.value = JSON.stringify(lastPayload, null, 2); } catch(e){}

    const ccState = getCCState_();
    renderList_(ccState, lastPayload);
    closeMigEdit_();
  }

  // events for edit modal
  if (btnCloseMigEdit) btnCloseMigEdit.addEventListener("click", closeMigEdit_);
  if (btnMigEditCancel) btnMigEditCancel.addEventListener("click", closeMigEdit_);
  if (btnMigEditSave) btnMigEditSave.addEventListener("click", applyMigEditSave_);

  // Persistencia liviana del modal (últimos valores)
  const LS_MIG_PREF = "mdv_chrono_migration_prefs_v1";
  function loadMigPrefs_(){
    try { return JSON.parse(localStorage.getItem(LS_MIG_PREF)||"{}")||{}; } catch(e){ return {}; }
  }
  function saveMigPrefs_(prefs){
    try { localStorage.setItem(LS_MIG_PREF, JSON.stringify(prefs||{})); } catch(e){}
  }


  function getLicenseAttrs_(){
    try { return JSON.parse(localStorage.getItem("mdvLicenseAttrs")||"{}")||{}; } catch(e){ return {}; }
  }
  function canUseConnector_(){
    const attrs = getLicenseAttrs_();
    if (attrs && Object.prototype.hasOwnProperty.call(attrs, "allow_chrono_connector")) return !!attrs.allow_chrono_connector;
    return true;
  }

  function getCCState_(){
    try { return JSON.parse(localStorage.getItem(LS_CC)||"{}")||{}; } catch(e){ return {}; }
  }

  function setStatus_(msg, ok){
    elStatus.textContent = msg || "";
    elStatus.style.color = ok ? "#065f46" : "#991b1b";
  }

  function open_(){
    migOverlay.style.display = "block";
    migModal.style.display = "flex"; document.body.classList.add("modal-open");
  }

  function close_(){
    try{ closeMigEdit_(); }catch(e){}
    migOverlay.style.display = "none";
    migModal.style.display = "none";
    document.body.classList.remove("modal-open");
    currentSavedRef = null;
  }

  function buildSeriesPayload_(){
    const now = new Date();
    ensurePoolCourse_();

    const pool_course = String(config.pool_course || "SCM");
    const pool_m = (pool_course === "LCM") ? 50 : 25;

    const distance_total_units = Number(config.total || 0);
    const distance_unit = distUnitShort_();
    const distance_m = toMeters_(distance_total_units);

    const segDists_units = (typeof getAllPartialsArr === "function") ? getAllPartialsArr() : (config.partials||[]);
    const segDists_m = (segDists_units||[]).map(d => toMeters_(d));

    const swimmers = (config.swimmers||[]).map((sw, i) => {
      const totalMs = (finishTimes && finishTimes[i]!=null) ? Number(finishTimes[i]) : null;
      const cumArr = (lapTimes && lapTimes[i]) ? lapTimes[i] : [];

      const strokesMode = !!(sw && sw.strokesEnabled);
      const strokeCounts = (sw && Array.isArray(sw.strokeCounts)) ? sw.strokeCounts : [];
      const hasCounts = Array.isArray(strokeCounts) && strokeCounts.some(v => v!=null && isFinite(Number(v)));
      const includeStrokes = strokesMode || hasCounts;

      const partials = [];
      const swolfVals = [];

      const segCount = segDists_units.length;
      let cumUnits = 0;
      let prevCumMs = 0;

      for (let j=0; j<segCount; j++){
        const splitUnits = Number(segDists_units[j]||0);
        cumUnits += splitUnits;

        const tAcum = (cumArr && cumArr[j]!=null) ? Number(cumArr[j])
          : (totalMs!=null && j===segCount-1 ? totalMs : null);

        if (tAcum == null || !isFinite(tAcum)) break;

        const tSplit = tAcum - prevCumMs;
        prevCumMs = tAcum;

        const isFinal = (j === segCount - 1) && (cumUnits >= distance_total_units);
        const tag = (!isFinal && config.partialLabels && config.partialLabels[j]) ? String(config.partialLabels[j]).trim() : "";
        const label = isFinal ? "FINAL" : (tag ? (`P${j+1} (${tag})`) : (`P${j+1}`));

        const strokes = includeStrokes && strokeCounts && strokeCounts[j]!=null && isFinite(Number(strokeCounts[j]))
          ? Number(strokeCounts[j]) : null;

        const swolf = (includeStrokes ? calcSwolf_(tSplit, strokes) : null);
        if (swolf!=null) swolfVals.push(swolf);

        const split_m = toMeters_(splitUnits);
        const cum_m = toMeters_(cumUnits);

        partials.push({
          idx: j+1,
          label,
          tag,
          distance_units: cumUnits,
          distance_m: (cum_m!=null && isFinite(cum_m)) ? Number(cum_m.toFixed(4)) : null,
          split_distance_units: splitUnits,
          split_distance_m: (split_m!=null && isFinite(split_m)) ? Number(split_m.toFixed(4)) : null,
          t_acum_ms: tAcum,
          t_split_ms: (tSplit!=null && isFinite(tSplit)) ? tSplit : null,
          v_mps: (tSplit>0 && split_m>0) ? Number((split_m / (tSplit/1000)).toFixed(3)) : null,
          v_avg_mps: (tAcum>0 && cum_m>0) ? Number((cum_m / (tAcum/1000)).toFixed(3)) : null,
          t_acum_str: (typeof fmt_==="function") ? fmt_(tAcum) : (tAcum!=null ? String(tAcum) : ""),
          strokes: includeStrokes ? strokes : null,
          swolf: swolf
        });
      }

      const swolfBest = swolfVals.length ? Math.min(...swolfVals) : null;
      const swolfAvg = swolfVals.length ? Number((swolfVals.reduce((a,b)=>a+b,0)/swolfVals.length).toFixed(1)) : null;

      return {
        lane: (sw && sw.lane!=null) ? sw.lane : "",
        order: (sw && sw.order!=null) ? sw.order : "",
        name: (sw && sw.name) ? sw.name : ("Nadador "+(i+1)),
        swimmer_id: (sw && sw.swimmer_id) ? sw.swimmer_id : "",
        migrate_to_marks: !!(sw && sw.swimmer_id),
        strokes_enabled: strokesMode,
        stroke_counts: strokeCounts,
        swolf_best: swolfBest,
        swolf_avg: swolfAvg,
        total_time_ms: totalMs,
        total_time_str: (totalMs!=null && typeof fmt_==="function") ? fmt_(totalMs) : (totalMs!=null? String(totalMs) : ""),
        partials
      };
    });

    return {
      meta: {
        series_name: config.name || "Serie",
        pool_course,
        pool_m,
        distance_unit,
        distance_total_units,
        distance_total: distance_total_units,
        distance_m: Number(distance_m.toFixed(4)),
        partials: segDists_units,
        partials_m: segDists_m.map(v => Number(v.toFixed(4))),
        date: now.toISOString().slice(0,10),
        created_at: now.toISOString(),
        source: "MDV_CHRONO"
      },
      swimmers
    };
  }

  function renderList_(ccState, payload){
    const nameById = new Map();
    (ccState && Array.isArray(ccState.swimmers) ? ccState.swimmers : []).forEach(s => {
      const sid = (s && (s.swimmer_id || s.id || "")).toString().trim();
      const nm = (s && (s.name || s.nombre || s.swimmer_name || s.full_name || s.display_name || "")).toString().trim();
      if (sid) nameById.set(sid, nm || sid);
    });

    let html = "";
    (payload.swimmers||[]).forEach((sw, idx) => {
      const hasId = !!(sw && sw.swimmer_id);
      const linked = !!(hasId && nameById.has(sw.swimmer_id));
      const nm = linked ? (nameById.get(sw.swimmer_id) || sw.name) : (sw && sw.name) || ("Nadador "+(idx+1));
      const mig = linked ? !(sw.migrate_to_marks===false || sw.migrate_to_marks===0 || String(sw.migrate_to_marks).toLowerCase()==="false") : false;

      const badge = linked
        ? (mig
            ? `<span style="display:inline-block; padding:2px 8px; border-radius:999px; background:#d1fae5; color:#065f46; font-size:12px; margin-left:6px;">Vinculado</span>`
            : `<span style="display:inline-block; padding:2px 8px; border-radius:999px; background:#fee2e2; color:#991b1b; font-size:12px; margin-left:6px;">No migrar</span>`
          )
        : `<span style="display:inline-block; padding:2px 8px; border-radius:999px; background:#ffedd5; color:#92400e; font-size:12px; margin-left:6px;">Manual</span>`;

      const tt = sw.total_time_str || "-";
      // Resumen Brazadas/SWOLF (si hay datos). Se muestra en esta lista, y se edita tocando el nombre.
      let swolfSummary = "";
      try{
        const parts = Array.isArray(sw.partials) ? sw.partials : [];
        const bits = [];
        for (let j=0; j<parts.length; j++){
          const p = parts[j] || {};
          const hasSt = (p.strokes!=null && String(p.strokes).trim()!=="" && String(p.strokes).toLowerCase()!=='null');
          const hasSw = (p.swolf!=null && String(p.swolf).trim()!=="" && String(p.swolf).toLowerCase()!=='null');
          if (!hasSt && !hasSw) continue;
          let swolfVal = (p.swolf!=null ? p.swolf : null);
          if (swolfVal==null && p.strokes!=null && p.t_split_ms!=null){
            try{ swolfVal = calcSwolf_(p.t_split_ms, p.strokes); }catch(e){}
          }
          const lbl = (p.label ? String(p.label) : ("P" + (p.idx || (j+1))));
          const st = hasSt ? String(p.strokes) : "-";
          const swv = (swolfVal!=null ? String(swolfVal) : "-");
          bits.push(lbl + " " + st + "|" + swv);
          if (bits.length>=6) break; // evita que sea demasiado largo
        }
        if (bits.length){
          swolfSummary = `<div style="margin-top:4px;"><small style="color:#111827;">Braz/SWOLF: ${escHtml_(bits.join(' · '))}</small></div>`;
        }
      }catch(e){}

      const cb = linked
        ? `<input class="mig-check" type="checkbox" data-idx="${idx}" ${mig ? "checked" : ""} title="Elegir si este registro migra a Marks" style="transform:scale(1.1); margin-right:10px;">`
        : `<span style="display:inline-block; width:22px; margin-right:10px;"></span>`;

      html += `<div style="display:flex; align-items:flex-start; gap:10px; padding:8px 6px; border-bottom:1px solid #f3f4f6;">
        ${cb}
        <div style="flex:1;">
          <b>#${idx+1}</b> · <span class="mig-edit" data-idx="${idx}" style="cursor:pointer; text-decoration:underline;">${escHtml_(nm)}</span> ${badge}<br>
          <small style="color:#6b7280;">Carril ${escHtml_(String(sw.lane||""))} · Orden ${escHtml_(String(sw.order||""))} · ID ${escHtml_(sw.swimmer_id || "-")}</small>${swolfSummary}
        </div>
        <div style="min-width:120px; text-align:right;"><b>${escHtml_(tt)}</b></div>
      </div>`;
    });

    elList.innerHTML = html || "<i>Sin datos</i>";

    // listeners: actualizar payload + JSON preview
    Array.from(elList.querySelectorAll("input.mig-check")).forEach(cb => {
      cb.addEventListener("change", () => {
        const i = Number(cb.getAttribute("data-idx")||"");
        if (!lastPayload || !Array.isArray(lastPayload.swimmers) || !lastPayload.swimmers[i]) return;
        lastPayload.swimmers[i].migrate_to_marks = !!cb.checked;
        try { elJson.value = JSON.stringify(lastPayload, null, 2); } catch(e){}
        renderList_(ccState, lastPayload);
      });
    });

    // listeners: editar nadador (solo vinculados)
    Array.from(elList.querySelectorAll(".mig-edit")).forEach(el => {
      el.addEventListener("click", (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        const i = Number(el.getAttribute("data-idx")||"");
        if (!isFinite(i)) return;
        openMigEdit_(i);
      });
    });

  }

  function escHtml_(s){
    return String(s||"").replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[ch]));
  }

  
  function readList_(key){
    try{
      const raw = localStorage.getItem(key);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    }catch(e){ return []; }
  }
  function writeList_(key, arr){
    try{ localStorage.setItem(key, JSON.stringify(Array.isArray(arr)?arr:[])); }catch(e){}
  }
  function ensureLocalId_(entry){
    if (!entry) entry = {};
    if (!entry.local_id){
      entry.local_id = "loc_" + Date.now().toString(36) + "_" + Math.random().toString(16).slice(2,8);
    }
    return entry.local_id;
  }
  function addPending_(entry){
    try{
      const cur = readList_(LS_PENDING);
      const id = ensureLocalId_(entry);
      // reflejar id dentro del payload para poder “mover” al sincronizar
      try{
        if (entry && entry.payload && entry.payload.meta){
          entry.payload.meta.chrono_local_id = id;
        }
      }catch(e){}
      cur.unshift(entry);
      writeList_(LS_PENDING, cur.slice(0, 60));
    }catch(e){}
  }
  function addSynced_(entry){
    try{
      const cur = readList_(LS_SYNCED);
      const id = ensureLocalId_(entry);
      try{
        if (entry && entry.payload && entry.payload.meta){
          entry.payload.meta.chrono_local_id = id;
        }
      }catch(e){}
      cur.unshift(entry);
      writeList_(LS_SYNCED, cur.slice(0, 80));
    }catch(e){}
  }
  function removePendingById_(local_id){
    if (!local_id) return;
    try{
      const cur = readList_(LS_PENDING);
      const next = cur.filter(x => String((x && (x.local_id||""))).trim() !== String(local_id).trim());
      writeList_(LS_PENDING, next);
    }catch(e){}
  }


  async function postWebApp_(baseUrl, data){
    const url = (baseUrl||"").trim();
    if (!url) return {status:"error", ok:false, message:"URL WebApp vacía."};
    const controller = new AbortController();
    const to = setTimeout(() => controller.abort(), 35000);
    try{
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify(data),
        signal: controller.signal
      });
      const txt = await res.text();
      let j = null;
      try { j = JSON.parse(txt); } catch(e) { j = {status:"error", ok:false, message:"Respuesta no-JSON", raw: txt}; }
      return j;
    }catch(err){
      return {status:"error", ok:false, message:String(err)};
    }finally{
      clearTimeout(to);
    }
  }

  async function doUpload_(mode){
    const cc = getCCState_();
    const url = (elCoachUrl && elCoachUrl.value ? String(elCoachUrl.value).trim() : (cc.url||"").trim());
    // persistir url si el usuario la editó
    try{
      if (url){
        const next = Object.assign({}, cc, { url });
        localStorage.setItem(LS_CC, JSON.stringify(next));
      }
    }catch(e){}

    const coach_id = (elCoachId && elCoachId.value ? String(elCoachId.value).trim() : (cc.coach_id||"").trim());
    if (!url || !coach_id) { setStatus_("Faltan datos de conexión (URL / Coach ID).", false); return; }

    btnSend.disabled = true;
    btnPending.disabled = true;

    const spRow = document.getElementById("migSpinnerRow");
    if (spRow) spRow.style.display = "none";

    try{
      const tipo_toma = (elTipo.value || "COMPETENCIA").trim();
      const lugar_evento = (elLugar.value || "").trim();
      const note = (elNota.value || "").trim();

      // payload base
      let payloadFull = JSON.parse(JSON.stringify(lastPayload || buildSeriesPayload_()));
      payloadFull.meta.type = tipo_toma;
      payloadFull.meta.place = lugar_evento;
      payloadFull.meta.note = note;

      const style = (elStyle && elStyle.value ? String(elStyle.value).trim() : "");
      const styleCustom = (elStyleCustom && elStyleCustom.value ? String(elStyleCustom.value).trim() : "");
      if (style) payloadFull.meta.style = style;
      if (style === "PERSONALIZADO" && styleCustom){
        payloadFull.meta.style_custom = styleCustom;
        payloadFull.meta.note = payloadFull.meta.note ? (payloadFull.meta.note + " | Estilo personalizado: " + styleCustom) : ("Estilo personalizado: " + styleCustom);
      }

      // Guardar prefs livianas
      try{
        const prefs = loadMigPrefs_();
        prefs.tipo_toma = tipo_toma;
        prefs.lugar_evento = lugar_evento;
        prefs.note = note;
        prefs.style = style;
        prefs.style_custom = styleCustom;
        prefs.coach_url = coach_url;
        saveMigPrefs_(prefs);
      }catch(e){}

      lastPayload = payloadFull;

      if (mode === "pending"){
        // Solo guardado local
        addPending_({ import_id:"", coach_id, tipo_toma, lugar_evento, note, payload: payloadFull, status:"local_pending", ts: new Date().toISOString() });
        setStatus_("Guardado local (pendiente).", true);
        if (typeof showToastBanner === "function") showToastBanner("Guardado local (pendiente)");
        close_();
        if (typeof showFinalModal === "function") showFinalModal();
        return;
      }

      // Filtrar a SOLO nadadores vinculados seleccionados
      let payloadToSend = JSON.parse(JSON.stringify(payloadFull));
      payloadToSend.swimmers = (payloadToSend.swimmers||[]).filter(sw => {
        if (!sw) return false;
        const hasId = !!String(sw.swimmer_id||"").trim();
        const want = (sw.migrate_to_marks === true || sw.migrate_to_marks == 1 || String(sw.migrate_to_marks||"").toLowerCase()==="true");
        return hasId && want;
      });

      if (!payloadToSend.swimmers.length){
        setStatus_("No hay nadadores vinculados seleccionados para enviar.", false);
        if (typeof showToastBanner === "function") showToastBanner("No hay nadadores seleccionados para sincronizar.");
        return;
      }

      // Preview JSON efectivo (lo que efectivamente se enviará)
      try { elJson.value = JSON.stringify(payloadToSend, null, 2); } catch(e){}


      // 1) Ensure bandeja CHRONO IMPORTS (no bloqueante: si falla, igual intentamos enviar)
      const ccState = (typeof getCCState_ === "function") ? (getCCState_()||{}) : {};
      const instId = String(ccState.institution_id || "").trim();
      const instKey = String(ccState.institution_key || "").trim();

      const common = { coach_id };
      if (instId) common.institution_id = instId;
      if (instKey) common.institution_key = instKey;

      setStatus_("Verificando bandeja CHRONO IMPORTS…", true);
      let r0 = null;
      let ensureOk = false;

      async function tryEnsure_(actionName){
        try{
          const rr = await postWebApp_(url, Object.assign({ action: actionName }, common));
          const ok = !!(rr && ((rr.status && String(rr.status).toLowerCase()==="ok") || rr.ok===true));
          return { rr, ok };
        }catch(e){
          return { rr: {status:"error", ok:false, message:String(e)}, ok:false };
        }
      }

      // Intentar acciones posibles (compat con scripts viejos)
      const ensureActions = ["ensure_chrono_imports_sheet", "ensure_chrono_imports", "ensure_imports_sheet", "ensure_chrono_imports_tab"];
      for (const actName of ensureActions){
        const out = await tryEnsure_(actName);
        r0 = out.rr;
        ensureOk = out.ok;
        if (ensureOk) break;
      }

      if (!ensureOk){
        // No frenamos: avisamos y seguimos (muchos scripts crean la hoja dentro de chrono_import)
        const detail = (r0 && (r0.message||r0.error)) ? String(r0.message||r0.error) : "";
        setStatus_("No se pudo verificar/crear CHRONO IMPORTS. Intentando enviar igualmente… " + (detail?("("+detail+")"):""), true);
        if (typeof showToastBanner === "function") showToastBanner("No se pudo verificar/crear CHRONO IMPORTS. Intentando enviar…");
        if (spRow) spRow.style.display = "none";
      } else {
        const created = !!(r0 && (r0.created || r0.sheet_created || r0.created_sheet));
        if (created){
          if (spRow) spRow.style.display = "flex";
          setStatus_("No se encontró CHRONO IMPORTS. Creando bandeja…", true);
          if (typeof showToastBanner === "function") showToastBanner("No se encontró CHRONO IMPORTS: creando bandeja…");
          await sleep_(650);
          if (spRow) spRow.style.display = "none";
        } else {
          if (spRow) spRow.style.display = "none";
        }
      }

// 2) Enviar a bandeja (Chrono Imports)
      setStatus_("Enviando a CHRONO IMPORTS…", true);
      const r1 = await postWebApp_(url, Object.assign({ action:"chrono_import", series_json: JSON.stringify(payloadToSend) }, common));

      
      if (!r1 || !(((r1.status && String(r1.status).toLowerCase()==="ok")) || r1.ok===true)){

        setStatus_("Error en chrono_import: " + (r1 && (r1.message||r1.error) ? (r1.message||r1.error) : JSON.stringify(r1)), false);
        if (typeof showToastBanner === "function"){ const d = shortErr_(r1); showToastBanner("Error enviando a CHRONO IMPORTS" + (d? (": " + d) : ".")); }
        return;
      }

      const import_id = r1.import_id || "";
      setStatus_("Enviado a bandeja. import_id: " + (import_id||"(sin id)"), true);

      // Registrar como "sincronizado" en este dispositivo
      try{
        const entry = {
          import_id: import_id,
          coach_id,
          tipo_toma,
          lugar_evento,
          note,
          payload: payloadFull,
          status: "sent_to_imports",
          ts: new Date().toISOString()
        };
        // Si venimos de un pendiente, intentamos “mover” (quitar de pendientes)
        const local_id = (payloadFull && payloadFull.meta && payloadFull.meta.chrono_local_id) ? String(payloadFull.meta.chrono_local_id) : (currentSavedRef && currentSavedRef.local_id ? String(currentSavedRef.local_id) : "");
        if (local_id) entry.local_id = local_id;
        addSynced_(entry);
        if (currentSavedRef && currentSavedRef.kind === "pending"){
          removePendingById_(local_id || currentSavedRef.local_id);
        }
      }catch(e){}

      if (typeof showToastBanner === "function") showToastBanner("Enviado a bandeja (CHRONO IMPORTS)");
      close_();
      if (typeof showFinalModal === "function") showFinalModal();

    }catch(err){
      setStatus_("Error: " + (err && err.message ? err.message : String(err)), false);
      if (typeof showToastBanner === "function") showToastBanner("Error en envío a bandeja.");
    }finally{
      btnSend.disabled = false;
      btnPending.disabled = false;
      const spRow2 = document.getElementById("migSpinnerRow");
      if (spRow2) spRow2.style.display = "none";
    }
  }

  function openWithPayload_(payload){
    const cc = getCCState_();
    lastPayload = payload || buildSeriesPayload_();
    try { elJson.value = JSON.stringify(lastPayload, null, 2); } catch(e) { elJson.value = ""; }

    elCoachId.textContent = (cc.coach_id || "-");
    elSerieName.textContent = (lastPayload.meta && (lastPayload.meta.series_name || lastPayload.meta.name) ? (lastPayload.meta.series_name || lastPayload.meta.name) : (config.name || "Serie"));
    elDate.textContent = (lastPayload.meta && lastPayload.meta.date) ? lastPayload.meta.date : (new Date().toISOString().slice(0,10));

    // Nuevos campos
    if (elCoachUrl) elCoachUrl.value = (cc.url || (elCoachUrl.value||"") || "").trim();
    if (elDistance) {
      const dist = (lastPayload && lastPayload.meta && (lastPayload.meta.distance_total || lastPayload.meta.distance_m || lastPayload.meta.distance)) ? (lastPayload.meta.distance_total || lastPayload.meta.distance_m || lastPayload.meta.distance) : (config.total || "");
      elDistance.textContent = dist ? String(dist) + " m" : "-";
    }


    // Preferencias del modal (últimos valores usados)
    const prefs = loadMigPrefs_();
    const applyPrefs = !currentSavedRef;
    if (applyPrefs){
      if (prefs.tipo_toma && Array.from(elTipo.options).some(o => o.value === prefs.tipo_toma)) elTipo.value = prefs.tipo_toma;
      if (typeof prefs.lugar_evento === "string" && !elLugar.value) elLugar.value = prefs.lugar_evento;
      if (typeof prefs.note === "string" && !elNota.value) elNota.value = prefs.note;

      if (elStyle && prefs.style && Array.from(elStyle.options).some(o => o.value === prefs.style)) {
        elStyle.value = prefs.style;
        const show = (prefs.style === "PERSONALIZADO");
        if (elStyleCustomWrap) elStyleCustomWrap.style.display = show ? "block" : "none";
        if (show && elStyleCustom && typeof prefs.style_custom === "string") elStyleCustom.value = prefs.style_custom;
      }
      if (elCoachUrl && prefs.coach_url && !elCoachUrl.value) elCoachUrl.value = prefs.coach_url;
    }

    renderList_(cc, lastPayload);
    setStatus_("", true);
    open_();
  }

  
  // Abrir el modal de migración reusando un registro guardado (pendiente o sincronizado)
  function openFromSaved_(entry, kind){
    try{
      const cc = getCCState_();
      const payload0 = (entry && entry.payload) ? JSON.parse(JSON.stringify(entry.payload)) : null;

      // Asegurar local_id
      const local_id = (entry && entry.local_id) ? String(entry.local_id) : (payload0 && payload0.meta && payload0.meta.chrono_local_id ? String(payload0.meta.chrono_local_id) : "");
      currentSavedRef = { kind: (kind === "synced" ? "synced" : "pending"), local_id: local_id || "" };

      // Prefill campos (si están en el entry)
      if (elTipo && entry && entry.tipo_toma && Array.from(elTipo.options).some(o => o.value === entry.tipo_toma)) elTipo.value = entry.tipo_toma;
      if (elLugar && entry && typeof entry.lugar_evento === "string") elLugar.value = entry.lugar_evento;
      if (elNota && entry && typeof entry.note === "string") elNota.value = entry.note;

      // URL (preferimos la del conector; si no, la guardada)
      if (elCoachUrl){
        const u = (cc && cc.url ? String(cc.url).trim() : "") || (entry && entry.coach_url ? String(entry.coach_url).trim() : "") || (elCoachUrl.value||"");
        elCoachUrl.value = u;
      }

      // Estilo desde payload (si existe)
      try{
        const meta = payload0 && payload0.meta ? payload0.meta : {};
        if (elStyle && meta.style && Array.from(elStyle.options).some(o => o.value === meta.style)) {
          elStyle.value = meta.style;
          const show = (meta.style === "PERSONALIZADO");
          if (elStyleCustomWrap) elStyleCustomWrap.style.display = show ? "block" : "none";
          if (show && elStyleCustom && meta.style_custom) elStyleCustom.value = String(meta.style_custom);
        }
      }catch(e){}

      openWithPayload_(payload0 || buildSeriesPayload_());
    }catch(err){
      if (typeof showToastBanner === "function") showToastBanner("No se pudo abrir el registro guardado.");
      console.error(err);
    }
  }

  // Exponer una API mínima para otras UI (ej: pestaña Migración dentro del Conector)
  window.__mdvOpenMigrationFromSaved = function(entry, kind){
    // Close connector modal first to avoid stacked modals / overflow on mobile
    try{
      const ccModal = document.getElementById("coachConnectorModal");
      if (ccModal) ccModal.style.display = "none";
    }catch(e){}
    openFromSaved_(entry, kind);
  };


  // No permitir cerrar tocando el overlay (para evitar cierres accidentales en móvil)
  migOverlay.addEventListener("click", () => {
    if (typeof showToastBanner === "function") showToastBanner("Usá 'Ahora no' si querés cerrar este modal.");
  });

  if (elStyle){
    elStyle.addEventListener("change", () => {
      const v = (elStyle.value||"").trim();
      const show = (v === "PERSONALIZADO");
      if (elStyleCustomWrap) elStyleCustomWrap.style.display = show ? "block" : "none";
      if (!show && elStyleCustom) elStyleCustom.value = "";
    });
  }


  // Guardar preferencias al vuelo
  function snapshotPrefs_(){
    return {
      tipo_toma: (elTipo.value || "").trim(),
      lugar_evento: (elLugar.value || "").trim(),
      note: (elNota.value || "").trim(),
      style: (elStyle && elStyle.value ? String(elStyle.value).trim() : ""),
      style_custom: (elStyleCustom && elStyleCustom.value ? String(elStyleCustom.value).trim() : ""),
      coach_url: (elCoachUrl && elCoachUrl.value ? String(elCoachUrl.value).trim() : "")
    };
  }
  ["change","input"].forEach(evt => {
    elTipo.addEventListener(evt, () => saveMigPrefs_(snapshotPrefs_()));
    elLugar.addEventListener(evt, () => saveMigPrefs_(snapshotPrefs_()));
    elNota.addEventListener(evt, () => saveMigPrefs_(snapshotPrefs_()));
  });


  btnClose.addEventListener("click", () => { close_(); if (typeof showFinalModal === "function") showFinalModal(); });
  btnLater.addEventListener("click", () => { close_(); if (typeof showFinalModal === "function") showFinalModal(); });
  btnPending.addEventListener("click", () => doUpload_("pending"));
  btnSend.addEventListener("click", () => doUpload_("send"));

  // Exponer handler global usado al finalizar la serie
  window.onSeriesAllFinished_ = function(){
    try{
      if (!canUseConnector_()) { if (typeof showFinalModal === "function") showFinalModal(); return; }
      const cc = getCCState_();
      // Si el conector está ON, mostramos el modal de migración; si no, modal final estándar
      if (cc && cc.enabled){
        openWithPayload_(buildSeriesPayload_());
      } else {
        if (typeof showFinalModal === "function") showFinalModal();
      }
    }catch(err){
      if (typeof showToastBanner === "function") showToastBanner("Error preparando migración: " + String(err));
      if (typeof showFinalModal === "function") showFinalModal();
    }
  };
})();



});</script>

<div id="toastBanner" style="display:none;position:fixed;top:25px;left:50%;transform:translateX(-50%);background:#1b6e3c;color:#fff;padding:1rem 2rem;border-radius:10px;box-shadow:0 2px 12px rgba(0,0,0,.2);font-size:1.1rem;z-index:2000;transition:opacity .3s;"></div>

  <!-- MDV COACH 360º · CONECTOR MODAL -->
  <div class="modal" id="coachConnectorModal" style="display:none;">
    <div class="modal-content" style="max-width:760px;">
      <h2 style="margin-bottom:2px;">MDV COACH 360º · CONECTOR</h2>
      <p style="margin-top:0; opacity:.8; font-size:13px;">
        Guardado local en este dispositivo. Requiere licencia con permiso de conector.
      </p>

      <div class="cc-tabs">
        <button type="button" class="cc-tabbtn active" data-cc-tab="connect">Conexión</button>
        <button type="button" class="cc-tabbtn" data-cc-tab="migrations">Migración de datos <span id="ccMigBadge" style="display:none; margin-left:6px;" class="cc-badge pending">0</span></button>
      </div>

      <!-- TAB: Conexión -->
      <div id="ccTabConnect" class="cc-tabpanel active">
        <div class="form-group">
          <label>URL WebApp (Google Apps Script) del COACH</label>
          <input id="cc_url" type="text" placeholder="https://script.google.com/macros/s/XXXXX/exec">
        </div>

        <div class="grid2">
          <div class="form-group">
            <label>Coach ID</label>
            <input id="cc_coachId" type="text" placeholder="COACH_MAURO">
          </div>
          <div class="form-group">
            <label>Institution ID (opcional)</label>
            <input id="cc_instId" type="text" placeholder="INST_XXXX">
          </div>
        </div>

        <div class="grid2">
          <div class="form-group">
            <label>Institution Key (si corresponde)</label>
            <input id="cc_instKey" type="password" placeholder="Clave de institución">
          </div>
          <div class="form-group">
            <label>Estado</label>
            <div id="cc_status" style="padding:10px 12px; border:1px solid rgba(0,0,0,.12); border-radius:10px; font-size:13px; min-height:18px;">Sin probar</div>
          </div>
        </div>

        <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
          <button id="cc_test" class="primary">Probar conexión</button>
          <button id="cc_save">Guardar</button>
          <button id="cc_disable" class="danger" title="Desactiva el conector y vuelve a modo manual">Desactivar</button>
          <div style="flex:1"></div>
          <button id="cc_close">Cerrar</button>
        </div>

        <div style="margin-top:10px; font-size:13px; opacity:.85;">
          Al activar el conector, en <b>Configurar serie → Nadadores</b> el nombre se transforma en lista desplegable con los nadadores del coach.
        </div>
      </div>

      <!-- TAB: Migración -->
      <div id="ccTabMigrations" class="cc-tabpanel">
        <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:6px 0 10px;">
          <div style="color:#6b7280; font-size:13px;">
            Acá podés ver migraciones <b>pendientes</b> (guardadas localmente) y <b>ya sincronizadas</b> (enviadas a CHRONO IMPORTS).
            Tocá un registro para reabrir el mismo <b>modal de migración</b> y editarlo / reenviarlo.
          </div>
          <div style="flex:1"></div>
          <button id="ccMigRefreshBtn" type="button">Refrescar</button>
          <button id="ccMigSelectAllBtn" type="button" title="Selecciona todos los pendientes">Seleccionar todos</button>
          <button id="ccMigClearSelBtn" type="button" title="Limpia la selección">Limpiar selección</button>
          <button id="ccMigSendSelectedBtn" type="button" class="primary" title="Envía a CHRONO IMPORTS los pendientes seleccionados">Migrar seleccionados</button>
          
          <button id="ccMigClearSyncedBtn" type="button" class="danger" title="Borra el historial de sincronizados del dispositivo">Borrar sincronizados</button>
        </div>

        <div style="margin-top:8px;">
          <div style="font-weight:700; margin:10px 0 6px;">Pendientes</div>
          <div id="ccMigPendingList" class="cc-mig-list"></div>
        </div>

        <div style="margin-top:14px;">
          <div style="font-weight:700; margin:10px 0 6px;">Sincronizados</div>
          <div id="ccMigSyncedList" class="cc-mig-list"></div>
        </div>

        <div style="margin-top:12px; color:#6b7280; font-size:12.5px;">
          Nota: “Sincronizado” significa “enviado a bandeja CHRONO IMPORTS”. La migración a <i>Marks</i> ocurre en el dashboard del coach.
        </div>

        <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:12px;">
          <button id="cc_close2" type="button">Cerrar</button>
        </div>
      </div>
    </div>
  </div>


<!-- =========================================================
       MIGRACIÓN A MDV COACH 360º (CHRONO -> DASHBOARDS)
       ========================================================= -->
  <div id="migOverlay" class="overlay" style="display:none"></div>
  <div id="migrationModal" class="modal" style="display:none; max-width: 760px;">
    <div class="modal-header">
      <h2>Enviar resultados a MDV COACH 360º</h2>
      <button class="close-btn" id="closeMigration">&times;</button>
    </div>
    <div class="modal-body">
      <div style="display:flex; flex-wrap:wrap; gap:12px; margin-bottom:10px;">
        <div style="min-width:220px;"><b>Coach ID:</b> <span id="migCoachId">-</span></div>
        <div style="min-width:220px;"><b>Serie:</b> <span id="migSerieName">-</span></div>
        <div style="min-width:220px;"><b>Fecha:</b> <span id="migDate">-</span></div>
      </div>

      <div class="form-group">
        <label>WebApp del Coach (script del cliente) · Se usa para importar y migrar</label>
        <input id="migCoachUrl" type="text" placeholder="https://script.google.com/macros/s/.../exec">
      </div>

      <div style="display:flex; flex-wrap:wrap; gap:12px; margin:10px 0 6px;">
        <div style="min-width:220px;"><b>Distancia:</b> <span id="migDistance">-</span></div>
      </div>

      <div class="form-group">
        <label>Estilo</label>
        <select id="migStyle">
          <option value="">(Sin especificar)</option>
          <option value="LIBRE">Libre</option>
          <option value="ESPALDA">Espalda</option>
          <option value="PECHO">Pecho</option>
          <option value="MARIPOSA">Mariposa</option>
          <option value="PERSONALIZADO">Personalizado (drill / aletas / manoplas…)</option>
        </select>
      </div>

      <div class="form-group" id="migStyleCustomWrap" style="display:none">
        <label>Notas de estilo personalizado</label>
        <input id="migStyleCustom" type="text" placeholder="Ej: 6 patadas + 1 brazada / aletas / palas…">
      </div>

      <div class="form-group">
        <label>Tipo de toma (se reflejará en Marks)</label>
        <select id="migTipoToma">
          <option value="COMPETENCIA">Competencia</option>
          <option value="TEST">Test</option>
          <option value="ENTRENAMIENTO">Entrenamiento</option>
        </select>
      </div>

      <div class="form-group">
        <label>Lugar / Evento (opcional)</label>
        <input type="text" id="migLugar" placeholder="Ej: Torneo Club X / Entrenamiento AVL">
      </div>

      <div class="form-group">
        <label>Nota (opcional)</label>
        <input type="text" id="migNota" placeholder="Ej: serie fuerte, salida desde agua, etc.">
      </div>

      <div class="form-group">
        <label>Resumen de nadadores</label>
        <div id="migSwimmerList" style="border:1px solid #e5e7eb; border-radius:10px; padding:10px; max-height:260px; overflow:auto;"></div>
        <small style="display:block; margin-top:6px; color:#6b7280;">
          Tocá el <b>nombre</b> para editar distancias parciales, brazadas y <b>SWOLF</b> <button class="info-btn" data-info="swolf" title="¿Qué es SWOLF?">i</button>.<br>Los nadadores vinculados (con <b>swimmer_id</b>) migran directo a Marks. Los no vinculados se guardan igual en Chrono Imports como referencia.
        </small>
      </div>

      <details style="margin-top:10px;">
        <summary style="cursor:pointer;">Ver JSON que se enviará</summary>
        <textarea id="migJson" style="width:100%; min-height:160px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size:12px; margin-top:8px;"></textarea>
      </details>

      <div id="migStatus" style="margin-top:10px; color:#111827;"></div>
      <div id="migSpinnerRow" style="display:none; margin-top:8px; display:flex; align-items:center; gap:8px;">
        <span class="mini-spinner"></span>
        <span style="color:#6b7280;">Creando bandeja…</span>
      </div>
    </div>
    <div class="modal-footer">
      <button id="migLater">Ahora no</button>
      <button id="migPending">Guardar local</button>
      <button id="migSend" class="primary">Enviar a bandeja</button>
    </div>
  </div>

  <!-- =========================================================
       Editor rápido por nadador (antes de enviar a bandeja)
       ========================================================= -->
  <div id="migEditModal" class="modal" style="display:none; max-width: 720px; z-index: 130;">
    <div class="modal-header">
      <h2>Editar envío (nadador)</h2>
      <button class="close-btn" id="closeMigEdit">&times;</button>
    </div>
    <div class="modal-body">
      <div style="display:flex; flex-wrap:wrap; gap:12px;">
        <div style="min-width:220px; flex:1;">
          <label><b>Nombre</b></label>
          <input id="migEditName" type="text" style="width:100%;">
        </div>
        <div style="min-width:180px;">
          <label><b>Swimmer ID</b></label>
          <input id="migEditId" type="text" style="width:100%;" disabled>
        </div>
        <div style="min-width:120px;">
          <label><b>Carril</b></label>
          <input id="migEditLane" type="text" style="width:100%;">
        </div>
        <div style="min-width:120px;">
          <label><b>Orden</b></label>
          <input id="migEditOrder" type="text" style="width:100%;">
        </div>
        <div style="min-width:180px;">
          <label><b>Tiempo total</b> <small style="color:#6b7280;">(mm:ss.cc)</small></label>
          <input id="migEditTotal" type="text" style="width:100%;" placeholder="Ej: 01:12.34">
        </div>
      </div>

      <div style="margin-top:12px;">
        <label><b>Parciales</b> <small style="color:#6b7280;">(solo D editable)</small></label>
        <div style="border:1px solid #e5e7eb; border-radius:10px; overflow:auto; -webkit-overflow-scrolling:touch;">
          <table style="width:100%; min-width:680px; border-collapse:collapse;">
            <thead>
              <tr style="background:#f9fafb;">
                <th style="text-align:left; padding:8px;">Parcial</th>
                <th style="text-align:left; padding:8px;">Distancias</th>
                <th style="text-align:left; padding:8px;">Acum (mm:ss.cc)</th>
                <th style="text-align:left; padding:8px;">Tramo</th>
                <th style="text-align:left; padding:8px;">Brazadas</th>
                <th style="text-align:left; padding:8px;">SWOLF <button class="info-btn" data-info="swolf" title="¿Qué es SWOLF?">i</button></th>
              </tr>
            </thead>
            <tbody id="migEditSplitsBody"></tbody>
          </table>
        </div>
        <small style="display:block; margin-top:8px; color:#6b7280;">
          Al guardar, se recalculan automáticamente los tiempos por tramo (split) y la velocidad.
        </small>
      </div>

      <div id="migEditMsg" style="margin-top:10px; color:#991b1b;"></div>
    </div>
    <div class="modal-footer">
      <button id="migEditCancel">Cancelar</button>
      <button id="migEditSave" class="primary">Guardar cambios</button>
    </div>
  </div>


<script>
/* =========================================================
   MDV SWIM CHRONO · V38B · ETAPA B
   Parciales con distancia opcional + colores consistentes en gráficos
   ========================================================= */

(function(){
  // ---------- Helpers ----------
  function parseOptionalUnits_(v){
    if (v == null) return null;
    const s = String(v).trim();
    if (!s) return null;
    const n = parseFloat(s.replace(',', '.'));
    return Number.isFinite(n) ? n : null;
  }
  function escHtml_(s){
    return String(s ?? '').replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[ch]));
  }
  function getPartialLabel_(j){
    try{
      if (typeof ensurePartialLabels_ === 'function') ensurePartialLabels_();
    }catch(e){}
    const lbl = (window.config && Array.isArray(config.partialLabels) && config.partialLabels[j]) ? String(config.partialLabels[j]).trim() : '';
    return lbl || ('P' + (j+1));
  }
  function getAccUnitsForSwimmer_(swIdx, j){
    if (!window.config || !Array.isArray(config.partials)) return null;
    const base = config.partials[j];
    if (base != null && Number.isFinite(Number(base))) return Number(base);
    const sw = (config.swimmers && config.swimmers[swIdx]) ? config.swimmers[swIdx] : null;
    const ov = sw && Array.isArray(sw.partialAccOverrides) ? sw.partialAccOverrides[j] : null;
    return (ov != null && Number.isFinite(Number(ov))) ? Number(ov) : null;
  }
  function getPrevKnownAccIdx_(swIdx, j){
    for (let k=j-1;k>=0;k--){
      const a = getAccUnitsForSwimmer_(swIdx, k);
      if (a != null && Number.isFinite(Number(a))) return k;
    }
    return -1;
  }
  function getPrevKnownAccUnits_(swIdx, j){
    const k = getPrevKnownAccIdx_(swIdx, j);
    if (k < 0) return 0;
    const a = getAccUnitsForSwimmer_(swIdx, k);
    return (a != null && Number.isFinite(Number(a))) ? Number(a) : 0;
  }
  function getPrevKnownAccTimeMs_(swIdx, j){
    const k = getPrevKnownAccIdx_(swIdx, j);
    const laps = (window.lapTimes && lapTimes[swIdx]) ? lapTimes[swIdx] : [];
    const t = (k >= 0 && laps && laps[k] != null) ? Number(laps[k]) : 0;
    return Number.isFinite(t) ? t : 0;
  }
  function getSplitUnitsForSwimmer_(swIdx, j){
    const acc = getAccUnitsForSwimmer_(swIdx, j);
    if (acc == null) return null;
    const prevAcc = getPrevKnownAccUnits_(swIdx, j);
    const d = Number(acc) - Number(prevAcc);
    return Number.isFinite(d) ? d : null;
  }
  function getFinalSplitUnitsForSwimmer_(swIdx){
    const total = Number(config.total || 0);
    if (!Number.isFinite(total)) return null;

    const n = Array.isArray(config.partials) ? config.partials.length : 0;
    let lastKnown = 0;
    for (let k=n-1;k>=0;k--){
      const a = getAccUnitsForSwimmer_(swIdx, k);
      if (a != null && Number.isFinite(Number(a))) { lastKnown = Number(a); break; }
    }
    const d = total - lastKnown;
    return Number.isFinite(d) ? d : null;
  }
  function fmtTime_(ms){
    if (typeof format === 'function') return format(ms);
    if (typeof fmt_ === 'function') return fmt_(ms);
    return (ms==null?'-':String(ms));
  }
  function mps_(units, ms){
    try{
      if (units == null || ms == null || ms <= 0) return null;
      const m = (typeof toMeters_ === 'function') ? toMeters_(units) : Number(units);
      if (!(m > 0)) return null;
      return m / (ms/1000);
    }catch(e){ return null; }
  }

  // ---------- 1) Config: parciales con distancia opcional ----------
  window.validateConfig = function(){
    try{
      const total = Number(config.total || 0);
      if (!(total > 0)) return false;
      let last = 0;
      for (const p of (config.partials || [])){
        if (p == null) continue;
        const s = String(p).trim();
        if (!s) continue;
        const v = Number(s.replace(',', '.'));
        if (!Number.isFinite(v)) return false;
        if (!(v > last && v < total)) return false;
        last = v;
      }
      return true;
    }catch(e){
      return false;
    }
  };

  // Captura robusta desde modal (reemplaza solo parciales/distancias)
  (function(){
    const _orig = window.captureConfigFromModal_;
    window.captureConfigFromModal_ = function(){
      const cfg = _orig ? _orig() : JSON.parse(JSON.stringify(window.config || {}));
      try{
        const nP = (window.numPartialsInput ? (+numPartialsInput.value || 0) : (Array.isArray(cfg.partials) ? cfg.partials.length : 0));
        cfg.partials = new Array(Math.max(0, nP)).fill(null);

        document.querySelectorAll('.pt-dist').forEach(inp => {
          const i = +inp.dataset.i;
          if (i >= 0 && i < cfg.partials.length) cfg.partials[i] = parseOptionalUnits_(inp.value);
        });

        if (!Array.isArray(cfg.partialLabels)) cfg.partialLabels = [];
        document.querySelectorAll('.pt-label').forEach(inp => {
          const i = +inp.dataset.i;
          cfg.partialLabels[i] = (inp.value || '').trim();
        });
        cfg.partialLabels = cfg.partialLabels.map(v => (v==null ? '' : String(v))).slice(0, cfg.partials.length);
        while (cfg.partialLabels.length < cfg.partials.length) cfg.partialLabels.push('');

        // Mantener overrides por nadador si existen
        if (Array.isArray(cfg.swimmers)){
          cfg.swimmers.forEach(sw => {
            if (!sw) return;
            if (!Array.isArray(sw.partialAccOverrides)) sw.partialAccOverrides = [];
            sw.partialAccOverrides = sw.partialAccOverrides.slice(0, cfg.partials.length);
            while (sw.partialAccOverrides.length < cfg.partials.length) sw.partialAccOverrides.push(null);
          });
        }
      }catch(err){
        console.error('captureConfigFromModal_ patch error', err);
      }
      return cfg;
    };
  })();

  // Render de parciales en modal: permite input vacío (null)
  (function(){
    const _orig = window.renderPartials;
    window.renderPartials = function(){
      if (!_orig) return;
      _orig();
      // Ajuste post-render: si value quedó "null"/"NaN"/0 forzado, limpiar si el config dice null
      try{
        document.querySelectorAll('.pt-dist').forEach(inp => {
          const i = +inp.dataset.i;
          const v = (window.config && Array.isArray(config.partials)) ? config.partials[i] : null;
          if (v == null) inp.value = '';
        });
      }catch(e){}
    };
  })();

  // getAllPartialsArr: split distances (units) incluyendo nulls
  window.getAllPartialsArr = function(){
    const total = Number(config.total || 0);
    const parts = Array.isArray(config.partials) ? config.partials : [];
    const arr = [];
    let prevAcc = 0;
    let prevKnown = true;
    for (let i=0; i<parts.length; i++){
      const p = parts[i];
      if (p == null || p === '' || !Number.isFinite(Number(p))){
        arr.push(null);
        prevKnown = false;
        prevAcc = null;
        continue;
      }
      const acc = Number(p);
      if (prevKnown && prevAcc != null){
        arr.push(acc - prevAcc);
      } else {
        arr.push(null);
      }
      prevAcc = acc;
      prevKnown = true;
    }
    // FINAL
    if (parts.length === 0){
      arr.push(total);
    } else {
      if (prevKnown && prevAcc != null && Number.isFinite(prevAcc)){
        arr.push(total - prevAcc);
      } else {
        arr.push(null);
      }
    }
    return arr;
  };

  // ---------- 1B) Ejecución: lap/fin registran tiempo aunque no haya distancia ----------
  // spawn: botón muestra distancia si existe, si no muestra etiqueta
  window.spawn = function(sw, i){
    startTimes[i] = Date.now();
    lapTimes[i] = [];
    finishTimes[i] = null;

    const unit = (typeof distUnitShort_ === 'function') ? distUnitShort_() : '';
    const tr = document.createElement('tr');
    tr.id = `row${i}`;

    const buttons = (config.partials || []).map((p, j) => {
      const lbl = getPartialLabel_(j);
      const txt = (p != null && Number.isFinite(Number(p))) ? `${Number(p)} ${unit}` : `${escHtml_(lbl)}`;
      return `<td><button data-i='${i}' data-j='${j}' class="btn-parcial">${txt}</button></td>`;
    }).join('');

    tr.innerHTML = `<td>${escHtml_(sw.name)}</td><td>${escHtml_(sw.lane)}</td><td>${escHtml_(sw.order)}</td><td class='lane-timer'>00:00.00</td>` +
      buttons +
      `<td><button data-i='${i}' class='fin'>Fin</button></td>`;

    laneBody.appendChild(tr);
    tr.querySelectorAll('button[data-j]').forEach(b => b.addEventListener('click', window.lap));
    tr.querySelector('.fin').addEventListener('click', window.fin);
  };

  window.lap = function(e){
    const i = +e.target.dataset.i;
    const j = +e.target.dataset.j;
    const now = Date.now();
    if (!startTimes || !startTimes[i]) return;

    lapTimes[i] = lapTimes[i] || [];

    // Secuencia: no permitir saltar parciales
    if (j > 0 && lapTimes[i][j-1] == null) return;

    const tAcum = now - startTimes[i];
    const prevEvent = (j === 0) ? 0 : Number(lapTimes[i][j-1] || 0);
    const tSplitEvent = tAcum - prevEvent;

    // Guardar acumulado real
    lapTimes[i][j] = tAcum;

    // Distancias (A) pueden ser nulas. Velocidad del tramo se calcula desde la ÚLTIMA distancia conocida.
    const accUnits = getAccUnitsForSwimmer_(i, j);
    const segUnits = getSplitUnitsForSwimmer_(i, j);

    const prevKnownTime = getPrevKnownAccTimeMs_(i, j);
    const tSegForSpeed = tAcum - prevKnownTime;

    const vSeg = mps_(segUnits, tSegForSpeed);
    const vAvg = mps_(accUnits, tAcum);

    // Mostrar: acumulado + velocidad del tramo (si aplica) y debajo: parcial (Δt entre toques) + AVG
    const line1 = `${fmtTime_(tAcum)}` + (vSeg != null ? ` (${vSeg.toFixed(2)} m/s)` : '');
    const line2 = `P ${fmtTime_(tSplitEvent)}` + (vAvg != null ? ` · AVG ${vAvg.toFixed(2)} m/s` : '');

    e.target.innerHTML = `<div>${line1}</div><div style="font-size:12px; opacity:.85">${line2}</div>`;
    e.target.disabled = true;
    e.target.classList.add('parcial-fixed');
  };

  window.fin = function(e){
    const i = +e.target.dataset.i;
    const now = Date.now();
    if (!startTimes || !startTimes[i]) return;

    const totalTime = now - startTimes[i];
    finishTimes[i] = totalTime;

    const laps = (lapTimes[i] || []);
    const lastEventIdx = laps.length ? (laps.length - 1) : -1;
    const lastEventTime = (lastEventIdx >= 0 && laps[lastEventIdx] != null) ? Number(laps[lastEventIdx]) : 0;
    const tSplitEvent = totalTime - lastEventTime;

    const total_units = Number(config.total || 0);
    const total_m = (typeof toMeters_ === 'function') ? toMeters_(total_units) : total_units;

    // Velocidad FINAL: desde la última distancia conocida (ignora parciales sin A)
    const remainUnits = getFinalSplitUnitsForSwimmer_(i);

    // Buscar la última marca con A conocida y tiempo registrado
    const n = Array.isArray(config.partials) ? config.partials.length : 0;
    let lastKnownIdx = -1;
    for (let k=n-1;k>=0;k--){
      const a = getAccUnitsForSwimmer_(i, k);
      if (a != null && Number.isFinite(Number(a)) && laps[k] != null) { lastKnownIdx = k; break; }
    }
    const prevKnownTime = (lastKnownIdx >= 0) ? Number(laps[lastKnownIdx]) : 0;
    const tSegForSpeed = totalTime - prevKnownTime;

    const vSplitFinal = mps_(remainUnits, tSegForSpeed);
    const vAvgTotal = (totalTime>0 && total_m>0) ? (total_m/(totalTime/1000)) : null;

    const line1 = `${fmtTime_(totalTime)}` + (vSplitFinal != null ? ` (${vSplitFinal.toFixed(2)} m/s)` : '');
    const line2 = `P ${fmtTime_(tSplitEvent)}` + (vAvgTotal != null ? ` · AVG ${vAvgTotal.toFixed(2)} m/s` : '');

    e.target.innerHTML = `<div><b>FINAL</b> ${line1}</div><div style="font-size:12px; opacity:.85">${line2}</div>`;
    e.target.disabled = true;
    e.target.classList.add('parcial-fixed');

    finishedCount++;
    if (finishedCount === (config.swimmers||[]).length) {
      clearInterval(masterTimer);
      clearSpawnTimeouts && clearSpawnTimeouts();
      stopBtn.disabled = true;
      (window.onSeriesAllFinishedUnified_ ? window.onSeriesAllFinishedUnified_()
        : (window.onSeriesAllFinished_ ? window.onSeriesAllFinished_() : (typeof showFinalModal==='function'?showFinalModal():null)));
    }
  };

// ---------- 1C) Modales post-serie: completar distancias opcionales ----------
  function getPendingUndefMap_(){
    const pending = [];
    const parts = Array.isArray(config.partials) ? config.partials : [];
    for (let j=0; j<parts.length; j++){
      if (parts[j] != null && Number.isFinite(Number(parts[j]))) continue;
      // si algún nadador marcó este parcial, lo consideramos "pendiente útil"
      let used = false;
      for (let i=0; i<(config.swimmers||[]).length; i++){
        const laps = lapTimes[i] || [];
        if (laps[j] != null){ used = true; break; }
      }
      if (used) pending.push(j);
    }
    return pending; // indexes
  }

  function ensureUndefDistUI_(){
    if (document.getElementById('undefDistOverlay')) return;

    const style = document.createElement('style');
    style.textContent = `
      #undefDistModal .cards{ display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); gap:12px; }
      #undefDistModal .card{ border:1px solid #e5e7eb; border-radius:12px; padding:12px; background:#fff; }
      #undefDistModal table{ width:100%; border-collapse:collapse; }
      #undefDistModal th, #undefDistModal td{ padding:6px 4px; border-bottom:1px solid #f3f4f6; font-size:.92rem; }
      #undefDistModal th{ text-align:left; background:#f9fafb; font-weight:600; }
      #undefDistModal input[type="text"], #undefDistModal input[type="number"]{ width:92px; padding:.35rem .4rem; }
      #undefDistModal .hint{ color:#6b7280; font-size:.85rem; margin-top:6px; }
      #undefDistAskModal p{ margin:0; color:#374151; }
      #undefDistAskModal .pill{ display:inline-block; padding:2px 8px; border-radius:999px; background:#f3f4f6; font-size:12px; }
      #undefDistAskModal .modal-body{ max-height:70vh; overflow:auto; }
      #undefDistModal .modal-body{ max-height:70vh; overflow:auto; }
    `;
    document.head.appendChild(style);

    const overlay = document.createElement('div');
    overlay.id = 'undefDistOverlay';
    overlay.className = 'overlay';
    overlay.style.zIndex = '1200';
    document.body.appendChild(overlay);

    const ask = document.createElement('div');
    ask.id = 'undefDistAskModal';
    ask.className = 'modal';
    ask.style.display = 'none';
    ask.style.maxWidth = '520px';
    ask.style.zIndex = '1210';
    ask.innerHTML = `
      <div class="modal-header">
        <h2>¿Completar distancias opcionales?</h2>
        <button class="close-btn" id="closeUndefAsk">&times;</button>
      </div>
      <div class="modal-body">
        <p>Se registraron tiempos en parciales cuya distancia no estaba definida (por ejemplo: <i>vuelo de la partida</i> o <i>subacuático</i>).</p>
        <p style="margin-top:10px;">¿Querés cargar la <b>distancia acumulada (A)</b> para esos parciales, por nadador?</p>
        <div style="margin-top:10px;"><span class="pill">Tip: podés omitir y quedarte solo con los tiempos</span></div>
      </div>
      <div class="modal-footer" style="display:flex; justify-content:flex-end; gap:10px;">
        <button class="secondary" id="undefAskNo">No, continuar</button>
        <button class="primary" id="undefAskYes">Sí, completar</button>
      </div>
    `;
    document.body.appendChild(ask);

    const modal = document.createElement('div');
    modal.id = 'undefDistModal';
    modal.className = 'modal';
    modal.style.display = 'none';
    modal.style.maxWidth = '980px';
    modal.style.zIndex = '1210';
    modal.innerHTML = `
      <div class="modal-header">
        <h2>Completar distancias (A) de parciales opcionales</h2>
        <button class="close-btn" id="closeUndefModal">&times;</button>
      </div>
      <div class="modal-body">
        <div style="color:#6b7280; font-size:.95rem;">
          Ingresá <b>A (acumulado)</b> en <b>${escHtml_((typeof distUnitShort_==='function') ? distUnitShort_() : '')}</b>.
          Si dejás un campo vacío, se mantiene como “sin distancia” (solo tiempo).
        </div>
        <div id="undefDistCards" class="cards" style="margin-top:12px;"></div>
      </div>
      <div class="modal-footer" style="display:flex; justify-content:flex-end; gap:10px;">
        <button class="secondary" id="undefCancel">Cancelar</button>
        <button class="primary" id="undefApply">Aplicar</button>
      </div>
    `;
    document.body.appendChild(modal);

    // Close handlers
    const closeAll = () => {
      overlay.style.display = 'none';
      ask.style.display = 'none';
      modal.style.display = 'none';
      // limpiar handlers de callbacks
      overlay.onclick = null;
    };

    document.getElementById('closeUndefAsk').onclick = closeAll;
    document.getElementById('closeUndefModal').onclick = closeAll;
    document.getElementById('undefCancel').onclick = closeAll;
    overlay.addEventListener('click', closeAll);

    // store closeAll
    overlay._closeAll = closeAll;
  }

  function openUndefAsk_(onNo, onYes){
    ensureUndefDistUI_();
    const overlay = document.getElementById('undefDistOverlay');
    const ask = document.getElementById('undefDistAskModal');
    const modal = document.getElementById('undefDistModal');

    overlay.style.display = 'block';
    ask.style.display = 'block';
    modal.style.display = 'none';

    document.getElementById('undefAskNo').onclick = () => { overlay._closeAll && overlay._closeAll(); onNo && onNo(); };
    document.getElementById('undefAskYes').onclick = () => { ask.style.display='none'; onYes && onYes(); };
  }

  function openUndefEditor_(pendingIdxs, doneCb){
    ensureUndefDistUI_();
    const overlay = document.getElementById('undefDistOverlay');
    const ask = document.getElementById('undefDistAskModal');
    const modal = document.getElementById('undefDistModal');
    const cards = document.getElementById('undefDistCards');

    ask.style.display = 'none';
    overlay.style.display = 'block';
    modal.style.display = 'block';

    const unit = (typeof distUnitShort_ === 'function') ? distUnitShort_() : '';
    const total_units = Number(config.total || 0);

    // build cards
    let htmlCards = '';
    (config.swimmers||[]).forEach((sw, i) => {
      const laps = lapTimes[i] || [];
      // only show swimmer if any pending index was used
      const used = pendingIdxs.some(j => laps[j] != null);
      if (!used) return;

      // ensure overrides array
      if (!Array.isArray(sw.partialAccOverrides)) sw.partialAccOverrides = [];
      while (sw.partialAccOverrides.length < (config.partials||[]).length) sw.partialAccOverrides.push(null);

      htmlCards += `<div class="card">
        <div style="display:flex; justify-content:space-between; gap:10px; align-items:flex-start;">
          <div>
            <div style="font-weight:700;">${escHtml_(sw.name || ('Nadador '+(i+1)))}</div>
            <div class="hint">Carril ${escHtml_(sw.lane)} · Orden ${escHtml_(sw.order)}</div>
          </div>
          <div class="hint">Total ${escHtml_(total_units)} ${escHtml_(unit)}</div>
        </div>
        <table style="margin-top:8px;">
          <thead><tr>
            <th>Parcial</th>
            <th>Tiempo</th>
            <th>A (${escHtml_(unit)})</th>
          </tr></thead>
          <tbody>
            ${pendingIdxs.map(j => {
              if (laps[j] == null) return '';
              const lbl = getPartialLabel_(j);
              const t = laps[j];
              const prevT = (function(){ for (let k=j-1;k>=0;k--){ if (laps[k]!=null) return laps[k]; } return 0; })();
              const tSplit = (t!=null && prevT!=null) ? (t - prevT) : null;
              const existing = (sw.partialAccOverrides[j] != null && Number.isFinite(Number(sw.partialAccOverrides[j])))
                ? String(sw.partialAccOverrides[j]) : '';
              // hints: prev/next bounds
              const bounds = (function(){
                // build temporary acc list: base config + existing overrides
                const accList = (config.partials||[]).map((p,k) => (p!=null && Number.isFinite(Number(p))) ? Number(p) : (sw.partialAccOverrides[k]!=null && Number.isFinite(Number(sw.partialAccOverrides[k])) ? Number(sw.partialAccOverrides[k]) : null));
                const prev = (function(){
                  for (let k=j-1;k>=0;k--){
                    if (accList[k]!=null) return accList[k];
                  }
                  return 0;
                })();
                const next = (function(){
                  for (let k=j+1;k<accList.length;k++){
                    if (accList[k]!=null) return accList[k];
                  }
                  return total_units;
                })();
                return {prev,next};
              })();
              return `<tr>
                <td><div style="font-weight:700; line-height:1.1;">${escHtml_(lbl)}</div></td>
                <td><div>${escHtml_(fmtTime_(tSplit))}</div><div style="font-size:12px; opacity:.75">A ${escHtml_(fmtTime_(t))}</div></td>
                <td>
                  <input type="text" inputmode="decimal" class="undef-acc" data-i="${i}" data-j="${j}" placeholder="" value="${escHtml_(existing)}">
                  <div class="hint">(${escHtml_(bounds.prev)}–${escHtml_(bounds.next)})</div>
                </td>
              </tr>`;
            }).join('')}
          </tbody>
        </table>
      </div>`;
    });

    cards.innerHTML = htmlCards || '<div class="hint">No hay parciales pendientes para completar.</div>';

    document.getElementById('undefApply').onclick = () => {
      try{
        // Build per-swimmer overrides from inputs
        const bySwimmer = new Map();
        document.querySelectorAll('#undefDistModal .undef-acc').forEach(inp => {
          const i = +inp.dataset.i, j = +inp.dataset.j;
          const v = parseOptionalUnits_(inp.value);
          if (!bySwimmer.has(i)) bySwimmer.set(i, new Map());
          bySwimmer.get(i).set(j, v);
        });

        // validate and apply
        for (const [i, mp] of bySwimmer.entries()){
          const sw = config.swimmers[i];
          if (!sw) continue;
          if (!Array.isArray(sw.partialAccOverrides)) sw.partialAccOverrides = [];
          while (sw.partialAccOverrides.length < (config.partials||[]).length) sw.partialAccOverrides.push(null);

          // temporary acc list with overrides-to-apply
          const accList = (config.partials||[]).map((p,k) => (p!=null && Number.isFinite(Number(p))) ? Number(p) : null);
          // prefill with existing overrides
          for (let k=0;k<accList.length;k++){
            if (accList[k]==null){
              const ex = (sw.partialAccOverrides[k]!=null && Number.isFinite(Number(sw.partialAccOverrides[k]))) ? Number(sw.partialAccOverrides[k]) : null;
              if (ex!=null) accList[k]=ex;
            }
          }
          // apply new inputs into accList
          for (const [j, v] of mp.entries()){
            if (v==null) continue; // allow keep null
            accList[j]=v;
          }

          // validate each newly provided
          for (const [j, v] of mp.entries()){
            if (v==null) continue;
            const vv = Number(v);
            if (!(vv > 0 && vv < total_units)){
              throw new Error(`A inválido para ${sw.name||('Nadador '+(i+1))} · ${getPartialLabel_(j)}: debe estar entre 0 y ${total_units}`);
            }
            // prev/next nearest known
            let prev = 0;
            for (let k=j-1;k>=0;k--){ if (accList[k]!=null){ prev = accList[k]; break; } }
            let next = total_units;
            for (let k=j+1;k<accList.length;k++){ if (accList[k]!=null){ next = accList[k]; break; } }
            if (!(vv > prev && vv < next)){
              throw new Error(`A fuera de rango para ${sw.name||('Nadador '+(i+1))} · ${getPartialLabel_(j)}: debe ser >${prev} y <${next}`);
            }
          }

          // apply into swimmer overrides (only where config.partial is null)
          for (const [j, v] of mp.entries()){
            if (config.partials[j] != null && Number.isFinite(Number(config.partials[j]))) continue;
            sw.partialAccOverrides[j] = (v==null ? null : Number(v));
          }
        }

        // re-render
        try { if (typeof renderResultsTables === 'function') renderResultsTables(); } catch(e){}
        try { if (typeof showMainChart === 'function') showMainChart(); } catch(e){}
        try { if (typeof showAdvancedCharts === 'function') showAdvancedCharts(); } catch(e){}
        try { if (typeof showAdvancedTables === 'function') showAdvancedTables(); } catch(e){}

        overlay._closeAll && overlay._closeAll();
        if (typeof showToastBanner === 'function') showToastBanner('Distancias aplicadas');
        doneCb && doneCb();
      }catch(err){
        console.error(err);
        if (typeof showToastBanner === 'function') showToastBanner(err.message || 'Error al aplicar distancias');
      }
    };

    // cancel behavior: close and continue
    document.getElementById('undefCancel').onclick = () => { overlay._closeAll && overlay._closeAll(); doneCb && doneCb(); };
    document.getElementById('closeUndefModal').onclick = () => { overlay._closeAll && overlay._closeAll(); doneCb && doneCb(); };
  }

  function openUndefDistanceFlowIfNeeded_(doneCb){
    try{
      const pendingIdxs = getPendingUndefMap_();
      if (!pendingIdxs.length){ doneCb && doneCb(); return; }
      openUndefAsk_(
        () => { doneCb && doneCb(); },
        () => { openUndefEditor_(pendingIdxs, doneCb); }
      );
    }catch(e){
      console.error(e);
      doneCb && doneCb();
    }
  }

  // ---------- 2) Gráficos: color consistente + robustez ante distancias null ----------
  // Paleta única (misma que gráfico principal)
  const PALETTE = (typeof palette !== 'undefined' && Array.isArray(palette)) ? palette
    : ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#a65628','#f781bf','#999999'];

  // showMainChart override (soporta distancias null y usa overrides por nadador)
  window.showMainChart = function(){
    // asegurar canvas
    if (!window.partialsChartCanvas || !document.body.contains(window.partialsChartCanvas)) {
      const cd = document.getElementById('charts');
      if (cd) { cd.innerHTML = '<canvas id="partialsChart"></canvas>'; window.partialsChartCanvas = document.getElementById('partialsChart'); }
    }
    if (!window.partialsChartCanvas) return;
    if (typeof Chart === 'undefined') return;

    const n = (config.partials || []).length;
    const segCount = n + 1;
    const unit = (typeof distUnitShort_ === 'function') ? distUnitShort_() : '';
    const totalUnits = Number(config.total || 0);

    // decidir eje X (si hay total, usar distancia)
    const useDistanceX = Number.isFinite(totalUnits) && totalUnits > 0;

    // detectar segmentos con distancia conocida (config o overrides por nadador)
    const segHasDist = new Array(segCount).fill(false);
    for (let j=0;j<n;j++){
      const cfg = parseNumOpt_(config.partials[j]);
      if (cfg != null){
        segHasDist[j] = true;
        continue;
      }
      for (let i=0;i<(config.swimmers||[]).length;i++){
        const splitUnits = getSplitUnitsForSwimmer_(i, j);
        if (splitUnits != null && Number.isFinite(Number(splitUnits))){
          segHasDist[j] = true;
          break;
        }
      }
    }
    segHasDist[n] = Number.isFinite(totalUnits) && totalUnits > 0;

    const includedSegIdxs = segHasDist.map((v, idx) => v ? idx : null).filter(v => v != null);
    const segIndexToX = new Map();
    if (!useDistanceX){
      let seq = 1;
      includedSegIdxs.forEach(idx => { segIndexToX.set(idx, seq); seq += 1; });
    }

    const tickVals = [];
    const tickLabels = [];
    if (useDistanceX){
      tickVals.push(0);
      tickLabels.push('');
      for (let j=0;j<n;j++){
        const acc = parseNumOpt_(config.partials[j]);
        if (acc != null && segHasDist[j]){
          tickVals.push(Number(acc));
          tickLabels.push(`P${j+1} (${Number(acc)}${unit})`);
        }
      }
      if (segHasDist[n]){
        tickVals.push(Number(totalUnits));
        tickLabels.push('FINAL');
      }
    } else {
      includedSegIdxs.forEach(idx => {
        tickVals.push(segIndexToX.get(idx));
        tickLabels.push(idx < n ? `P${idx+1}` : 'FINAL');
      });
    }

    let maxVel = 0;
    const datasets = [];
    (config.swimmers||[]).forEach((sw, i) => {
      const points = [];
      let prevTime = 0;
      for (let j=0;j<segCount;j++){
        const tAcum = (j < n) ? ((lapTimes[i]||[])[j] ?? null) : (finishTimes[i] ?? null);
        if (tAcum == null) break;
        const tSplit = tAcum - prevTime;

        const splitUnits = (j < n) ? getSplitUnitsForSwimmer_(i, j) : getFinalSplitUnitsForSwimmer_(i);
        const v = mps_(splitUnits, tSplit);
        if (splitUnits != null && v != null && segHasDist[j]){
          let x = null;
          if (useDistanceX){
            const accUnits = (j < n) ? getAccUnitsForSwimmer_(i, j) : totalUnits;
            x = (accUnits != null && Number.isFinite(Number(accUnits))) ? Number(accUnits) : null;
          } else {
            x = segIndexToX.get(j);
          }
          if (x != null){
            points.push({ x, y: v });
            if (v > maxVel) maxVel = v;
          }
        }
        prevTime = tAcum;
      }
      if (points.length > 1){
        datasets.push({
          label: sw.name,
          data: points,
          borderColor: PALETTE[i % PALETTE.length],
          backgroundColor: PALETTE[i % PALETTE.length] + '33',
          tension: 0.15,
          fill: false,
          spanGaps: true
        });
      }
    });

    if (window.chartInstance) window.chartInstance.destroy();
    window.chartInstance = new Chart(partialsChartCanvas.getContext('2d'), {
      type: 'line',
      data: { datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { title: { display: true, text: 'Velocidad por tramo (comparativo)' } },
        interaction: { mode: 'nearest', axis: 'xy', intersect: false },
        scales: {
          x: {
            type: 'linear',
            title: { display: true, text: useDistanceX ? ('Distancia ('+unit+')') : 'Tramo' },
            ticks: { callback: (v, idx) => tickLabels[idx] },
            afterBuildTicks: scale => { scale.ticks = tickVals.map((v,i)=>({ value:v, label: tickLabels[i] })); }
          },
          y: {
            beginAtZero: true,
            max: Math.max(0.5, (Number.isFinite(maxVel) ? Math.ceil(maxVel/0.5)*0.5 : 0.5)),
            title: { display: true, text: 'Velocidad (m/s)' },
            ticks: { stepSize: 0.5 }
          }
        }
      }
    });
  };

  // getAdvancedMetrics override: usa distancias por nadador (incluye overrides) y tolera null
  window.getAdvancedMetrics = function(idx, includePartials = false){
    const n = (config.partials || []).length;
    const segCount = n + 1;
    const laps = lapTimes[idx] || [];
    const finish = finishTimes[idx];
    const res = { parciales: [], mejorParcial: null };
    let prevTime = 0;

    for (let j=0;j<segCount;j++){
      const acumulado = (j < n) ? (laps[j] ?? null) : (finish ?? null);
      if (acumulado == null) break;
      const tiempo = acumulado - prevTime;

      const split_units = (j < n) ? getSplitUnitsForSwimmer_(idx, j) : getFinalSplitUnitsForSwimmer_(idx);
      const cum_units = (j < n) ? getAccUnitsForSwimmer_(idx, j) : Number(config.total || 0);

      const vel = mps_(split_units, tiempo);
      const velAvg = mps_(cum_units, acumulado);

      const obj = {
        n: j+1,
        dist: split_units,
        dist_m: (split_units!=null && typeof toMeters_==='function') ? toMeters_(split_units) : (split_units!=null ? Number(split_units) : null),
        tiempo,
        vel: (vel!=null ? vel : null),
        velAvg: (velAvg!=null ? velAvg : null),
        cum_units: (cum_units!=null ? cum_units : null)
      };

      // mejor tramo = mayor velocidad (si existe), si no existe, menor tiempo
      if (includePartials) res.parciales.push(obj);

      if (vel != null && tiempo > 0){
        if (!res.mejorParcial || (res.mejorParcial.vel!=null ? vel > res.mejorParcial.vel : true)){
          res.mejorParcial = { ...obj };
        }
      } else if (tiempo > 0 && (!res.mejorParcial || res.mejorParcial.vel==null && tiempo < res.mejorParcial.tiempo)){
        res.mejorParcial = { ...obj };
      }

      prevTime = acumulado;
    }
    return res;
  };

  // showAdvancedCharts override: usa color de paleta global del gráfico principal
  (function(){
    const _orig = window.showAdvancedCharts;
    window.showAdvancedCharts = function(){
      // Largamente basado en la versión original, pero sin paleta local
      if (!window.advancedChartsDiv) return _orig ? _orig() : null;
      advancedChartsDiv.innerHTML = '';
      (window.advChartInstances||[]).forEach(c => c.destroy && c.destroy());
      window.advChartInstances = [];
      const swAdv = (config.swimmers||[]).map((sw, i) => ({ sw, i })).filter(o => o.sw && o.sw.advanced);
      if (!swAdv.length) { advancedChartsDiv.style.display = 'none'; return; }
      advancedChartsDiv.style.display = 'block';

      swAdv.forEach(({ sw, i }) => {
        const _color = PALETTE[i % PALETTE.length];
        const metrics = window.getAdvancedMetrics(i, true);
        if (!metrics || !metrics.parciales || !metrics.parciales.length || typeof Chart === 'undefined') return;

        const filtered = metrics.parciales.filter(p => {
          if (!p) return false;
          if (p.dist == null || !Number.isFinite(Number(p.dist))) return false;
          return p.tiempo != null && Number.isFinite(Number(p.tiempo)) && Number(p.tiempo) > 0;
        });
        if (!filtered.length) return;

        // decidir eje X por nadador: si todas las cum_units existen, usamos distancia; si no, index
        const n = (config.partials||[]).length;
        const segCount = n+1;
        let useDistX = true;
        const xVals = [];
        for (let j=0;j<filtered.length;j++){
          const segIdx = filtered[j].n - 1;
          const cum = (segIdx < n) ? getAccUnitsForSwimmer_(i, segIdx) : Number(config.total||0);
          if (cum == null || !Number.isFinite(Number(cum))) { useDistX = false; break; }
          xVals.push(Number(cum));
        }

        const points = filtered.map((p, idx2) => ({
          x: useDistX ? xVals[idx2] : (idx2 + 1),
          y: (p.vel!=null ? p.vel : null)
        }));

        const finiteV = points.map(pt => pt.y).filter(v => v!=null && Number.isFinite(v));
        const maxVel = finiteV.length ? Math.max(...finiteV) : 0.5;
        const yMax = Math.max(0.5, Math.ceil(maxVel/0.5)*0.5);

        const canvas = document.createElement('canvas');
        canvas.className = 'adv-chart-canvas';
        advancedChartsDiv.appendChild(canvas);

        const tickVals = [];
        const tickLabels = [];
        if (useDistX){
          tickVals.push(0);
          tickLabels.push('');
          filtered.forEach((p, idx2) => {
            const segIdx = p.n - 1;
            const cum = (segIdx < n) ? getAccUnitsForSwimmer_(i, segIdx) : Number(config.total||0);
            if (cum == null || !Number.isFinite(Number(cum))) return;
            tickVals.push(Number(cum));
            tickLabels.push(segIdx < n ? `P${segIdx+1}` : 'FINAL');
          });
        } else {
          for (let k=0;k<points.length;k++){
            const segIdx = filtered[k].n - 1;
            tickVals.push(k + 1);
            tickLabels.push(segIdx < n ? `P${segIdx+1}` : 'FINAL');
          }
        }

        const data = {
          datasets: [{
            label: sw.name,
            data: points,
            borderColor: _color,
            backgroundColor: _color + '33',
            tension: 0.15,
            fill: false,
            spanGaps: true
          }]
        };

        const opts = {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { title: { display: true, text: 'Velocidad por tramo - ' + sw.name } },
          scales: {
            x: {
              type: 'linear',
              title: { display: true, text: useDistX ? ('Distancia (' + ((typeof distUnitShort_==='function')?distUnitShort_():'') + ')') : 'Tramo' },
              ticks: { callback: (v, idx) => tickLabels[idx] },
              afterBuildTicks: scale => { scale.ticks = tickVals.map((v,i)=>({ value:v, label: tickLabels[i] })); }
            },
            y: { beginAtZero: true, max: yMax, title: { display: true, text: 'Velocidad (m/s)' }, ticks: { stepSize: 0.5 } }
          }
        };

        const inst = new Chart(canvas.getContext('2d'), { type: 'line', data, options: opts });
        window.advChartInstances.push(inst);
      });

      advancedChartsDiv.style.display = (window.advChartInstances && window.advChartInstances.length) ? 'block' : 'none';
    };
  })();

  // ---------- 3) Tablas: soportar null + mostrar tiempos aunque falte distancia ----------
  window.finalLabelHtml_ = function(dist, acc){
    const unit = (typeof distUnitShort_==='function') ? distUnitShort_() : '';
    const dTxt = (dist!=null && Number.isFinite(Number(dist))) ? String(Number(dist)) : '-';
    const aTxt = (acc!=null && Number.isFinite(Number(acc))) ? String(Number(acc)) : '-';
    return `<div style="line-height:1.1;"><b>FINAL</b><br><small style="color:#6b7280;">D:${escHtml_(dTxt)} ${escHtml_(unit)} · A:${escHtml_(aTxt)} ${escHtml_(unit)}</small></div>`;
  };

  window.partialLabelHtml_ = function(iOrN, distMaybe, accMaybe){
    let n = +iOrN;
    let dist = null, acc = null;
    if (accMaybe == null && distMaybe != null) { acc = distMaybe; dist = null; }
    else { dist = distMaybe; acc = accMaybe; }

    try{ if (typeof ensurePartialLabels_==='function') ensurePartialLabels_(); }catch(e){}
    const unit = (typeof distUnitShort_==='function') ? distUnitShort_() : '';
    const isFinal = (n === ((config.partials||[]).length + 1));
    if (isFinal) return window.finalLabelHtml_(dist, acc);

    const rawLbl = (config.partialLabels && config.partialLabels[n-1]) ? String(config.partialLabels[n-1]).trim() : '';
    const lbl = rawLbl ? ` (${escHtml_(rawLbl)})` : '';
    const dTxt = (dist!=null && Number.isFinite(Number(dist))) ? String(Number(dist)) : '-';
    const aTxt = (acc!=null && Number.isFinite(Number(acc))) ? String(Number(acc)) : '-';

    return `<div style="font-weight:700; line-height:1.1">P${n}${lbl}</div><div style="font-size:12px; opacity:.75">D:${escHtml_(dTxt)}${escHtml_(unit)} · A:${escHtml_(aTxt)}${escHtml_(unit)}</div>`;
  };

  // renderResultsTables override (usa distancias por nadador + null-safe)
  window.renderResultsTables = function(){
    const n = (config.partials||[]).length;
    const unit = (typeof distUnitShort_==='function') ? distUnitShort_() : '';
    const total_units = Number(config.total || 0);
    const total_m = (typeof toMeters_==='function') ? toMeters_(total_units) : total_units;

    const swimmersOrd = (config.swimmers||[])
      .map((sw, i) => ({...sw, i, t: finishTimes[i]}))
      .sort((a, b) => (a.t ?? Infinity) - (b.t ?? Infinity));

    // Header labels (config-based)
    const headerCells = [];
    for (let j=0;j<n;j++){
      const acc = (config.partials[j]!=null && Number.isFinite(Number(config.partials[j]))) ? Number(config.partials[j]) : null;
      const prevAcc = (j===0) ? 0 : ((config.partials[j-1]!=null && Number.isFinite(Number(config.partials[j-1]))) ? Number(config.partials[j-1]) : null);
      const dist = (acc!=null && prevAcc!=null) ? (acc - prevAcc) : null;
      headerCells.push(`<th>${window.partialLabelHtml_(j+1, dist, acc)}</th>`);
    }
    // FINAL header
    const lastAccCfg = (n>0 && config.partials[n-1]!=null && Number.isFinite(Number(config.partials[n-1]))) ? Number(config.partials[n-1]) : null;
    const finalDist = (lastAccCfg!=null) ? (total_units - lastAccCfg) : null;
    headerCells.push(`<th>${window.partialLabelHtml_(n+1, finalDist, total_units)}</th>`);

    let html = `<div class="res-title">Resultados principales (orden de llegada)</div>
    <div class="res-wrap"><table class="res-table res-table-main">
    <thead><tr>
      <th>Puesto</th>
      <th>Nombre</th>
      <th>Carril</th>
      <th>Orden</th>
      ${headerCells.join('')}
    </tr></thead><tbody>`;

    swimmersOrd.forEach((sw, idx) => {
      html += `<tr><td>${idx+1}</td><td>${escHtml_(sw.name)}</td><td>${escHtml_(sw.lane)}</td><td>${escHtml_(sw.order)}</td>`;

      const laps = lapTimes[sw.i] || [];
      for (let j=0;j<n;j++){
        const tAcum = laps[j];
        if (tAcum == null){
          html += `<td>-</td>`;
          continue;
        }
        const prevTime = (j===0) ? 0 : laps[j-1];
        const tSplit = tAcum - prevTime;

        const splitUnits = getSplitUnitsForSwimmer_(sw.i, j);
        const accUnits = getAccUnitsForSwimmer_(sw.i, j);
        const vSplit = mps_(splitUnits, tSplit);
        const vAvg = mps_(accUnits, tAcum);

        let cell = `${fmtTime_(tAcum)}`;
        if (vSplit != null) cell += ` (${vSplit.toFixed(2)} m/s)`;
        if (vAvg != null) cell += `<span class="avg-line">AVG ${vAvg.toFixed(2)} m/s</span>`;
        html += `<td>${cell}</td>`;
      }

      // FINAL
      let finalVal = '-';
      if (sw.t != null){
        const lastIdx = laps.length ? (laps.length-1) : -1;
        const lastCumTime = lastIdx>=0 ? laps[lastIdx] : 0;
        const tSplit = sw.t - lastCumTime;

        const remainUnits = getFinalSplitUnitsForSwimmer_(sw.i);
        const vSplitFinal = mps_(remainUnits, tSplit);
        const vAvgTotal = (sw.t>0 && total_m>0) ? (total_m/(sw.t/1000)) : null;

        finalVal = `${fmtTime_(sw.t)}`;
        if (vSplitFinal != null) finalVal += ` (${vSplitFinal.toFixed(2)} m/s)`;
        if (vAvgTotal != null) finalVal += `<span class="avg-line">AVG ${vAvgTotal.toFixed(2)} m/s</span>`;
      }
      html += `<td>${finalVal}</td></tr>`;
    });

    html += `</tbody></table></div>`;

    // Mejor tramo por nadador (máxima velocidad disponible)
    html += `<div class="res-title">Mejor tramo por nadador</div>
    <div class="res-wrap"><table class="res-table res-table-bestby">
    <thead><tr>
      <th>Nombre</th>
      <th>Tramo más rápido</th>
      <th>Distancia (${escHtml_(unit)})</th>
      <th>Tiempo</th>
      <th>Vel (m/s)</th>
    </tr></thead><tbody>`;

    (config.swimmers||[]).forEach((sw, i) => {
      const n = (config.partials||[]).length;
      const laps = lapTimes[i] || [];
      const totalT = finishTimes[i];

      let best = null; // {segIndex, time, dist, vel}
      let prevTime = 0;
      for (let j=0;j<n+1;j++){
        const tAcum = (j<n) ? laps[j] : totalT;
        if (tAcum == null) break;
        const tSplit = tAcum - prevTime;
        const distUnits = (j<n) ? getSplitUnitsForSwimmer_(i, j) : getFinalSplitUnitsForSwimmer_(i);
        const vel = mps_(distUnits, tSplit);

        const cand = { j, tSplit, distUnits, vel };
        if (vel != null){
          if (!best || (best.vel==null) || vel > best.vel) best = cand;
        } else if (tSplit>0 && (!best || best.vel==null && tSplit < best.tSplit)){
          best = cand;
        }
        prevTime = tAcum;
      }

      const segLabel = (best ? (best.j < n ? getPartialLabel_(best.j) : 'FINAL') : '-');
      const distTxt = (best && best.distUnits!=null) ? String(Number(best.distUnits)) : '-';
      const tTxt = (best && best.tSplit!=null) ? fmtTime_(best.tSplit) : '-';
      const vTxt = (best && best.vel!=null) ? best.vel.toFixed(2) : '-';

      html += `<tr>
        <td>${escHtml_(sw.name)}</td>
        <td>${escHtml_(segLabel)}</td>
        <td>${escHtml_(distTxt)}</td>
        <td>${escHtml_(tTxt)}</td>
        <td>${escHtml_(vTxt)}</td>
      </tr>`;
    });

    html += `</tbody></table></div>`;

    // Mejores tramos por segmento (máxima velocidad)
    html += `<div class="res-title">Mejores tramos generales (por segmento)</div>
    <div class="res-wrap"><table class="res-table res-table-best">
    <thead><tr>
      <th>Segmento</th>
      <th>Nadador</th>
      <th>Distancia (${escHtml_(unit)})</th>
      <th>Tiempo</th>
      <th>Vel (m/s)</th>
    </tr></thead><tbody>`;

    for (let j=0;j<n+1;j++){
      let best = null;
      (config.swimmers||[]).forEach((sw, i) => {
        const laps = lapTimes[i] || [];
        const tAcum = (j<n) ? laps[j] : finishTimes[i];
        if (tAcum == null) return;
        const prevTime = (j===0) ? 0 : (j<n ? laps[j-1] : (laps.length ? laps[laps.length-1] : 0));
        const tSplit = tAcum - prevTime;
        const distUnits = (j<n) ? getSplitUnitsForSwimmer_(i, j) : getFinalSplitUnitsForSwimmer_(i);
        const vel = mps_(distUnits, tSplit);
        if (vel == null) return;
        if (!best || vel > best.vel){
          best = { i, name: sw.name, distUnits, tSplit, vel };
        }
      });

      const segName = (j<n) ? getPartialLabel_(j) : 'FINAL';
      const distTxt = (best && best.distUnits!=null) ? String(Number(best.distUnits)) : '-';
      const tTxt = (best && best.tSplit!=null) ? fmtTime_(best.tSplit) : '-';
      const vTxt = (best && best.vel!=null) ? best.vel.toFixed(2) : '-';
      const who = best ? best.name : '-';

      html += `<tr>
        <td>${escHtml_(segName)}</td>
        <td>${escHtml_(who)}</td>
        <td>${escHtml_(distTxt)}</td>
        <td>${escHtml_(tTxt)}</td>
        <td>${escHtml_(vTxt)}</td>
      </tr>`;
    }

    html += `</tbody></table></div>`;

    if (window.resultsTables){
      resultsTables.innerHTML = html;
      resultsTables.style.display = '';
    }
  };

  
  // showAdvancedTables override: tolera distancias null (evita 'null' en tabla)
  (function(){
    const _orig = window.showAdvancedTables;
    window.showAdvancedTables = function(){
      if (!window.advancedTablesDiv) return _orig ? _orig() : null;
      advancedTablesDiv.innerHTML = '';
      const swAdv = (config.swimmers||[]).map((sw, i) => ({ sw, i })).filter(o => o.sw && o.sw.advanced);
      if (!swAdv.length) { advancedTablesDiv.style.display = 'none'; return; }

      const unit = (typeof distUnitShort_==='function') ? distUnitShort_() : '';

      swAdv.forEach(({ sw, i }) => {
        const metrics = window.getAdvancedMetrics(i, true);
        if (!metrics || !metrics.parciales || !metrics.parciales.length) return;

        let html = `<div class="adv-title">${escHtml_(sw.name)}</div>`;
        html += `<table class="adv-table"><thead><tr>
          <th>Parcial</th>
          <th>D (${escHtml_(unit)})</th>
          <th>Tiempo</th>
          <th>Vel (m/s)</th>
          <th>AVG (m/s)</th>
        </tr></thead><tbody>`;

        metrics.parciales.forEach((p, idx2) => {
          const distTxt = (p.dist!=null && Number.isFinite(Number(p.dist))) ? Number(p.dist) : '-';
          const cumUnits = (p.cum_units!=null && Number.isFinite(Number(p.cum_units))) ? Number(p.cum_units) : null;
          html += `<tr>
            <td>${window.partialLabelHtml_(p.n, p.dist, cumUnits)}</td>
            <td>${escHtml_(distTxt)}</td>
            <td>${escHtml_(fmtTime_(p.tiempo))}</td>
            <td>${(p.vel!=null && Number.isFinite(Number(p.vel))) ? Number(p.vel).toFixed(2) : '-'}</td>
            <td>${(p.velAvg!=null && Number.isFinite(Number(p.velAvg))) ? Number(p.velAvg).toFixed(2) : '-'}</td>
          </tr>`;
        });

        html += '</tbody></table>';
        advancedTablesDiv.insertAdjacentHTML('beforeend', html);
      });

      advancedTablesDiv.style.display = 'block';
    };
  })();

// ---------- 4) Payload: parciales con distancia null + overrides por nadador ----------
  window.buildSeriesPayload_ = function(){
    const now = new Date();
    try{ if (typeof ensurePoolCourse_==='function') ensurePoolCourse_(); }catch(e){}

    const pool_course = String(config.pool_course || "SCM");
    const pool_m = (pool_course === "LCM") ? 50 : 25;

    const distance_total_units = Number(config.total || 0);
    const distance_unit = (typeof distUnitShort_==='function') ? distUnitShort_() : '';
    const distance_m = (typeof toMeters_==='function') ? toMeters_(distance_total_units) : distance_total_units;

    const segSplit_units = window.getAllPartialsArr ? getAllPartialsArr() : [];
    const segSplit_m = (segSplit_units||[]).map(d => (d==null ? null : Number(((typeof toMeters_==='function')?toMeters_(d):Number(d)).toFixed(4))));

    const n = (config.partials||[]).length;
    const segCount = n + 1;

    const swimmers = (config.swimmers||[]).map((sw, i) => {
      const totalMs = (finishTimes && finishTimes[i]!=null) ? Number(finishTimes[i]) : null;
      const laps = (lapTimes && lapTimes[i]) ? lapTimes[i] : [];
      const includeStrokes = !!(sw && sw.strokesEnabled);
      const strokeCounts = (sw && Array.isArray(sw.strokeCounts)) ? sw.strokeCounts : [];
      const partials = [];
      const swolfVals = [];

      // parciales marcados
      let prevTime = 0;
      let lastKnownAccUnits = 0;
      let lastKnownAccMs = 0;
      for (let j=0; j<n; j++){
        const tAcum = laps[j];
        if (tAcum == null) break;

        const tSplit = tAcum - prevTime;

        const label = getPartialLabel_(j);
        const tag = label;

        const cumUnits = getAccUnitsForSwimmer_(i, j);
        // split_distance: desde la última distancia conocida (ignora parciales sin A)
        let splitUnits = null;
        let tSpeedForV = null;
        if (cumUnits != null && Number.isFinite(Number(cumUnits))){
          const d = Number(cumUnits) - Number(lastKnownAccUnits || 0);
          splitUnits = (Number.isFinite(d) && d > 0) ? d : null;
          const dt = Number(tAcum) - Number(lastKnownAccMs || 0);
          tSpeedForV = (Number.isFinite(dt) && dt > 0) ? dt : null;
        }

        const strokes = includeStrokes ? (strokeCounts[j] != null ? Number(strokeCounts[j]) : null) : null;
        const swolf = (includeStrokes && typeof calcSwolf_==='function') ? calcSwolf_(tSplit, strokes) : null;
        if (swolf!=null) swolfVals.push(swolf);

        const split_m = (splitUnits!=null && typeof toMeters_==='function') ? toMeters_(splitUnits) : (splitUnits!=null ? Number(splitUnits) : null);
        const cum_m = (cumUnits!=null && typeof toMeters_==='function') ? toMeters_(cumUnits) : (cumUnits!=null ? Number(cumUnits) : null);

        partials.push({
          idx: j+1,
          label,
          tag,
          distance_units: (cumUnits!=null ? cumUnits : null),
          distance_m: (cum_m!=null && Number.isFinite(Number(cum_m))) ? Number(Number(cum_m).toFixed(4)) : null,
          split_distance_units: (splitUnits!=null ? splitUnits : null),
          split_distance_m: (split_m!=null && Number.isFinite(Number(split_m))) ? Number(Number(split_m).toFixed(4)) : null,
          t_acum_ms: tAcum,
          t_split_ms: (tSplit!=null && Number.isFinite(tSplit)) ? tSplit : null,
          v_mps: (tSpeedForV!=null && split_m!=null && split_m>0) ? Number((split_m / (tSpeedForV/1000)).toFixed(3)) : null,
          v_avg_mps: (tAcum>0 && cum_m!=null && cum_m>0) ? Number((cum_m / (tAcum/1000)).toFixed(3)) : null,
          t_acum_str: (typeof fmt_==="function") ? fmt_(tAcum) : fmtTime_(tAcum),
          strokes: includeStrokes ? strokes : null,
          swolf: swolf
        });

        if (cumUnits != null && Number.isFinite(Number(cumUnits))){
          lastKnownAccUnits = Number(cumUnits);
          lastKnownAccMs = Number(tAcum);
        }
        prevTime = tAcum;
      }

      // FINAL (si terminó)
      if (totalMs != null){
        const lastCumTime = (laps && laps.length) ? Number(laps[laps.length-1]||0) : 0;
        const tSplit = totalMs - lastCumTime;

        const label = 'FINAL';
        const tag = 'FINAL';

        // FINAL: desde última distancia conocida (ignora parciales sin A)
        const dFinal = Number(distance_total_units) - Number(lastKnownAccUnits || 0);
        const splitUnits = (Number.isFinite(dFinal) && dFinal > 0) ? dFinal : null;
        const cumUnits = distance_total_units;
        const tSpeedForV = (Number.isFinite(totalMs) && Number.isFinite(Number(lastKnownAccMs))) ? (Number(totalMs) - Number(lastKnownAccMs || 0)) : null;

        const strokesFinalIdx = n; // en SWOLF se incluye FINAL como tramo n+1
        const strokes = includeStrokes ? (strokeCounts[strokesFinalIdx] != null ? Number(strokeCounts[strokesFinalIdx]) : null) : null;
        const swolf = (includeStrokes && typeof calcSwolf_==='function') ? calcSwolf_(tSplit, strokes) : null;
        if (swolf!=null) swolfVals.push(swolf);

        const split_m = (splitUnits!=null && typeof toMeters_==='function') ? toMeters_(splitUnits) : (splitUnits!=null ? Number(splitUnits) : null);
        const cum_m = (typeof toMeters_==='function') ? toMeters_(cumUnits) : cumUnits;

        partials.push({
          idx: segCount,
          label,
          tag,
          distance_units: cumUnits,
          distance_m: (cum_m!=null && Number.isFinite(Number(cum_m))) ? Number(Number(cum_m).toFixed(4)) : null,
          split_distance_units: (splitUnits!=null ? splitUnits : null),
          split_distance_m: (split_m!=null && Number.isFinite(Number(split_m))) ? Number(Number(split_m).toFixed(4)) : null,
          t_acum_ms: totalMs,
          t_split_ms: (tSplit!=null && Number.isFinite(tSplit)) ? tSplit : null,
          v_mps: (tSpeedForV!=null && split_m!=null && split_m>0) ? Number((split_m / (tSpeedForV/1000)).toFixed(3)) : null,
          v_avg_mps: (totalMs>0 && cum_m!=null && cum_m>0) ? Number((cum_m / (totalMs/1000)).toFixed(3)) : null,
          t_acum_str: (typeof fmt_==="function") ? fmt_(totalMs) : fmtTime_(totalMs),
          strokes: includeStrokes ? strokes : null,
          swolf: swolf
        });
      }

      const swolfBest = swolfVals.length ? Math.min(...swolfVals) : null;
      const swolfAvg = swolfVals.length ? Number((swolfVals.reduce((a,b)=>a+b,0)/swolfVals.length).toFixed(1)) : null;

      return {
        lane: (sw && sw.lane!=null) ? sw.lane : "",
        order: (sw && sw.order!=null) ? sw.order : "",
        name: (sw && sw.name!=null) ? sw.name : "",
        swimmer_id: (sw && sw.swimmer_id!=null) ? sw.swimmer_id : "",
        total_time_ms: totalMs,
        total_time_str: (totalMs!=null) ? ((typeof fmt_==='function') ? fmt_(totalMs) : fmtTime_(totalMs)) : "",
        partials: partials,
        swolf_best: swolfBest,
        swolf_avg: swolfAvg,
        partial_acc_overrides_units: (sw && Array.isArray(sw.partialAccOverrides)) ? sw.partialAccOverrides : null
      };
    });

    return {
      session: {
        name: String(config.name || "Serie"),
        pool_course,
        pool_m,
        distance_unit,
        distance_total_units,
        distance_total: distance_total_units,
        distance_m: Number(Number(distance_m).toFixed(4)),
        partials: segSplit_units,
        partials_m: segSplit_m,
        partial_labels: Array.isArray(config.partialLabels) ? config.partialLabels : [],
        date: now.toISOString().slice(0,10),
        created_at: now.toISOString(),
        source: "MDV_CHRONO"
      },
      swimmers
    };
  };

  // ---------- 5) Hook final serie: brazadas -> distancias opcionales -> autosave -> final/conector ----------
  window.onSeriesAllFinishedUnified_ = function(){
    const afterStrokes = () => {
      openUndefDistanceFlowIfNeeded_(() => {
        // Auto-save: guardar sesión completa al finalizar (con overrides si se aplicaron)
        try { if (typeof saveExecutedSessionToLocal_ === 'function') saveExecutedSessionToLocal_(null); } catch(e){ console.error('autosave results error', e); }
        if (window.onSeriesAllFinished_) window.onSeriesAllFinished_();
        else if (typeof showFinalModal === 'function') showFinalModal();
      });
    };

    if (typeof openStrokesModalIfNeeded_ === 'function'){
      openStrokesModalIfNeeded_(afterStrokes);
    } else {
      afterStrokes();
    }
  };

  // ---------- Small refresh on load ----------
  try{ if (typeof renderPartials==='function') renderPartials(); }catch(e){}
  try{ if (typeof renderResultsTables==='function') renderResultsTables(); }catch(e){}
})();
</script>

<!-- ===== v38E PATCH: Optional distances (D editable, A readonly) + TP/TA display + final flow ===== -->
<script>
(()=>{

  // --- helpers ---
  const parseNumOpt_ = (v) => {
    if (v == null) return null;
    const s = String(v).trim();
    if (!s) return null;
    const n = Number(s.replace(',', '.'));
    return Number.isFinite(n) ? n : null;
  };
  const esc_ = (s)=> String(s||"").replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[ch]));
  const toMetersOrNull_ = (u)=> {
    const n = (u==null ? null : Number(u));
    if (n==null || !Number.isFinite(n)) return null;
    try{ return (typeof toMeters_==='function') ? toMeters_(n) : n; }catch(e){ return n; }
  };

  const getTPEventMs_ = (i,j, tAcum)=> {
    const laps = (window.lapTimes && lapTimes[i]) ? lapTimes[i] : [];
    let prev = 0;
    for (let k=j-1;k>=0;k--){
      if (laps[k]!=null && isFinite(Number(laps[k]))){ prev = Number(laps[k]); break; }
    }
    return (tAcum!=null && isFinite(tAcum)) ? (Number(tAcum) - prev) : null;
  };

  const getPrevKnownAccUnitsSafe_ = (i,j)=>{
    try{ return (typeof getPrevKnownAccUnits_==='function') ? getPrevKnownAccUnits_(i,j) : 0; }catch(e){ return 0; }
  };
  const getPrevKnownAccTimeSafe_ = (i,j)=>{
    try{ return (typeof getPrevKnownAccTimeMs_==='function') ? getPrevKnownAccTimeMs_(i,j) : 0; }catch(e){ return 0; }
  };

  // --- Recalc A overrides from D overrides for ALL swimmers (safe full recompute) ---
  function recalcAllAccOverridesFromSplits_(){
    const total = Number((window.config && config.total) || 0);
    const n = Array.isArray(config.partials) ? config.partials.length : 0;

    const isAnchor = (v)=> (v!=null && Number.isFinite(Number(v)));

    for (let i=0;i<(config.swimmers||[]).length;i++){
      const sw = config.swimmers[i];
      if (!sw) continue;

      if (!Array.isArray(sw.partialSplitOverrides)) sw.partialSplitOverrides = [];
      if (!Array.isArray(sw.partialAccOverrides)) sw.partialAccOverrides = [];

      while (sw.partialSplitOverrides.length < n) sw.partialSplitOverrides.push(null);
      while (sw.partialAccOverrides.length < n) sw.partialAccOverrides.push(null);

      let lastKnownA = 0;

      for (let j=0;j<n;j++){
        const anchorA = isAnchor(config.partials[j]) ? Number(config.partials[j]) : null;

        if (anchorA != null){
          // Validación: no permitir que D previas superen el ancla
          if (lastKnownA > anchorA + 1e-9){
            return { ok:false, msg:`Distancias inconsistentes en ${sw.name||('Nadador '+(i+1))}: antes de ${getPartialLabel_?getPartialLabel_(j):('P'+(j+1))} superan A=${anchorA}.` };
          }
          sw.partialAccOverrides[j] = null; // usa base config
          lastKnownA = anchorA;
          continue;
        }

        const d = parseNumOpt_(sw.partialSplitOverrides[j]);

        if (d != null){
          const nextA = lastKnownA + d;
          if (Number.isFinite(total) && total>0 && nextA > total + 1e-9){
            return { ok:false, msg:`Distancia excede total en ${sw.name||('Nadador '+(i+1))} (${getPartialLabel_?getPartialLabel_(j):('P'+(j+1))}).` };
          }
          lastKnownA = nextA;
          sw.partialAccOverrides[j] = lastKnownA;
        } else {
          // marcador temporal sin distancia: no avanza A
          sw.partialAccOverrides[j] = null;
        }
      }
    }
    return { ok:true };
  }

  // --- UI: ensure optional distance modals (D editable) ---
  function ensureUndefDistUI_(){
    if (document.getElementById('undefDistOverlay')) return;

    const style = document.createElement('style');
    style.textContent = `
      #undefDistOverlay{ position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; }
      #undefDistAskModal, #undefDistModal{ position:fixed; inset:0; margin:auto; background:#fff; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.22); width:min(980px, calc(100vw - 24px)); height:auto; max-height:86vh; overflow:hidden; display:none; }
      #undefDistAskModal{ width:min(520px, calc(100vw - 24px)); }
      #undefDistAskModal .modal-header, #undefDistModal .modal-header{ display:flex; align-items:center; justify-content:space-between; padding:12px 14px; border-bottom:1px solid #e5e7eb; }
      #undefDistAskModal .modal-body, #undefDistModal .modal-body{ padding:12px 14px; overflow:auto; max-height:70vh; }
      #undefDistModal .cards{ display:grid; grid-template-columns:repeat(auto-fit,minmax(280px,1fr)); gap:12px; }
      #undefDistModal .card{ border:1px solid #e5e7eb; border-radius:12px; padding:12px; background:#fff; }
      #undefDistModal table{ width:100%; border-collapse:collapse; }
      #undefDistModal th, #undefDistModal td{ padding:6px 4px; border-bottom:1px solid #f3f4f6; font-size:.92rem; vertical-align:top; }
      #undefDistModal th{ text-align:left; background:#f9fafb; font-weight:600; }
      #undefDistModal input[type="text"], #undefDistModal input[type="number"]{ width:92px; padding:.35rem .4rem; }
      #undefDistModal .hint{ color:#6b7280; font-size:.85rem; margin-top:6px; }
      .close-btn{ background:transparent; border:0; font-size:22px; line-height:1; cursor:pointer; }
      .btn-row{ display:flex; gap:10px; justify-content:flex-end; padding:12px 14px; border-top:1px solid #e5e7eb; background:#fff; }
      .btn-soft{ padding:.55rem .75rem; border-radius:10px; border:1px solid #e5e7eb; background:#f9fafb; cursor:pointer; }
      .btn-primary{ padding:.55rem .75rem; border-radius:10px; border:1px solid #111827; background:#111827; color:#fff; cursor:pointer; }
      .pill{ display:inline-block; padding:2px 8px; border-radius:999px; background:#f3f4f6; font-size:12px; }
    `;
    document.head.appendChild(style);

    const overlay = document.createElement('div');
    overlay.id = 'undefDistOverlay';
    overlay.style.zIndex = '1200';
    document.body.appendChild(overlay);

    const ask = document.createElement('div');
    ask.id = 'undefDistAskModal';
    ask.style.zIndex = '1210';
    ask.innerHTML = `
      <div class="modal-header">
        <h2 style="margin:0; font-size:18px;">¿Completar distancias opcionales?</h2>
        <button class="close-btn" id="closeUndefAsk">&times;</button>
      </div>
      <div class="modal-body">
        <p style="margin:0 0 10px 0; color:#374151;">
          Se detectaron parciales con <span class="pill">distancia no definida</span>.
          Podés completar <b>D (distancia del tramo)</b> para esos parciales. Si no, quedarán registrados solo con <b>TP</b> y <b>TA</b>.
        </p>
        <p style="margin:0; color:#6b7280; font-size:.92rem;">Podés dejar campos vacíos para mantenerlos sin distancia.</p>
      </div>
      <div class="btn-row">
        <button class="btn-soft" id="undefAskNo">No, continuar</button>
        <button class="btn-primary" id="undefAskYes">Sí, completar D</button>
      </div>
    `;
    document.body.appendChild(ask);

    const modal = document.createElement('div');
    modal.id = 'undefDistModal';
    modal.style.zIndex = '1210';
    modal.innerHTML = `
      <div class="modal-header">
        <h2 style="margin:0; font-size:18px;">Completar distancias (D) de parciales opcionales</h2>
        <button class="close-btn" id="closeUndefModal">&times;</button>
      </div>
      <div class="modal-body">
        <div style="color:#6b7280; font-size:.95rem; margin-bottom:10px;">
          Ingresá <b>D (distancia del tramo)</b> para cada parcial opcional.
          La <b>A (acumulada)</b> se recalcula automáticamente y se muestra en modo lectura.
        </div>
        <div class="cards" id="undefDistCards"></div>
      </div>
      <div class="btn-row">
        <button class="btn-soft" id="undefDistSkip">Omitir</button>
        <button class="btn-primary" id="undefDistApply">Aplicar distancias</button>
      </div>
    `;
    document.body.appendChild(modal);

    const showOverlay = (on)=>{ overlay.style.display = on ? 'block' : 'none'; };
    const hideAll = ()=>{ showOverlay(false); ask.style.display='none'; modal.style.display='none'; try{ document.body.classList.remove('modal-open'); }catch(e){} };
    overlay.addEventListener('click', hideAll);
    ask.querySelector('#closeUndefAsk').addEventListener('click', hideAll);
    modal.querySelector('#closeUndefModal').addEventListener('click', hideAll);

    // expose helpers
    window.__undefDistUI__ = { overlay, ask, modal, showOverlay, hideAll };
  }

  // --- Optional distance flow ---
  function openOptionalDistanceFlow_(pendingIdxs, done){
    ensureUndefDistUI_();
    const ui = window.__undefDistUI__;
    if (!ui) { done && done(); return; }

    ui.showOverlay(true);
    ui.ask.style.display = 'block';
    ui.modal.style.display = 'none';
    try{ document.body.classList.add('modal-open'); }catch(e){}

    const btnNo = ui.ask.querySelector('#undefAskNo');
    const btnYes = ui.ask.querySelector('#undefAskYes');

    const cleanupAskHandlers_ = ()=>{
      btnNo.onclick = null;
      btnYes.onclick = null;
    };

    btnNo.onclick = ()=>{
      cleanupAskHandlers_();
      ui.hideAll();
      done && done();
    };

    btnYes.onclick = ()=>{
      cleanupAskHandlers_();
      openUndefEditor_(pendingIdxs, done);
    };
  }

  // --- D-only editor ---
  function buildAccPreviewForSwimmer_(swIdx, dMap){
    const n = Array.isArray(config.partials) ? config.partials.length : 0;
    const isAnchor = (v)=> (v!=null && Number.isFinite(Number(v)));
    let lastKnownA = 0;
    const A = Array(n).fill(null);

    for (let j=0;j<n;j++){
      const anchorA = isAnchor(config.partials[j]) ? Number(config.partials[j]) : null;
      if (anchorA != null){
        lastKnownA = anchorA;
        A[j] = anchorA;
        continue;
      }
      const d = (dMap && dMap.has(j)) ? dMap.get(j) : null;
      if (d != null){
        lastKnownA = lastKnownA + d;
        A[j] = lastKnownA;
      } else {
        A[j] = null;
      }
    }
    return A;
  }

  function openUndefEditor_(pendingIdxs, doneCb){
    ensureUndefDistUI_();
    const ui = window.__undefDistUI__;
    const cards = document.getElementById('undefDistCards');
    if (!ui || !cards) { doneCb && doneCb(); return; }

    ui.ask.style.display = 'none';
    ui.modal.style.display = 'block';
    ui.showOverlay(true);
    try{ document.body.classList.add('modal-open'); }catch(e){}

    const unit = (typeof distUnitShort_ === 'function') ? distUnitShort_() : '';
    cards.innerHTML = '';

    // Build cards per swimmer
    (config.swimmers||[]).forEach((sw, i)=>{
      const laps = (window.lapTimes && lapTimes[i]) ? lapTimes[i] : [];
      const used = pendingIdxs.some(j => laps[j]!=null);
      if (!used) return;

      // initial d map from sw.partialSplitOverrides
      const dMap = new Map();
      const arr = (sw && Array.isArray(sw.partialSplitOverrides)) ? sw.partialSplitOverrides : [];
      pendingIdxs.forEach(j=>{
        const v = parseNumOpt_(arr[j]);
        if (v!=null) dMap.set(j, v);
      });

      const Aprev = buildAccPreviewForSwimmer_(i, dMap);

      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:10px;">
          <div>
            <div style="font-weight:700; color:#111827;">${esc_(sw.name||('Nadador '+(i+1)))}</div>
            <div style="color:#6b7280; font-size:.85rem;">Carril ${esc_(sw.lane||'-')} · Orden ${esc_(sw.order||'-')}</div>
          </div>
          <div class="pill">${esc_(unit||'m')}</div>
        </div>
        <div style="margin-top:10px;">
          <table>
            <thead>
              <tr>
                <th>Parcial</th>
                <th>TP</th>
                <th>TA</th>
                <th>D (${esc_(unit)})</th>
                <th>A (${esc_(unit)})</th>
              </tr>
            </thead>
            <tbody>
              ${pendingIdxs.map(j=>{
                if (laps[j]==null) return '';
                const lbl = (typeof getPartialLabel_==='function') ? getPartialLabel_(j) : ('P'+(j+1));
                const tA = Number(laps[j]);
                const tP = getTPEventMs_(i,j,tA);
                const dVal = (dMap.has(j) ? dMap.get(j) : null);
                const aVal = (Aprev[j]!=null ? Aprev[j] : null);
                return `
                  <tr>
                    <td><b>${esc_(lbl)}</b></td>
                    <td>${tP!=null ? esc_(fmtTime_(tP)) : '-'}</td>
                    <td>${tA!=null ? esc_(fmtTime_(tA)) : '-'}</td>
                    <td><input type="text" inputmode="decimal" class="undef-d" data-i="${i}" data-j="${j}" value="${dVal!=null ? esc_(dVal) : ''}" placeholder="(opcional)"></td>
                    <td><span class="undef-a" data-i="${i}" data-j="${j}">${aVal!=null ? esc_(String(aVal)) : '-'}</span></td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
          <div class="hint">Solo se completan <b>D</b>. La <b>A</b> se recalcula. Campos vacíos ⇒ parcial queda sin distancia.</div>
        </div>
      `;
      cards.appendChild(card);

      // live recalc for card
      const inputs = card.querySelectorAll('input.undef-d');
      const update = ()=>{
        const map = new Map();
        inputs.forEach(inp=>{
          const j = +inp.dataset.j;
          const v = parseNumOpt_(inp.value);
          if (v!=null) map.set(j, v);
        });
        const A = buildAccPreviewForSwimmer_(i, map);
        card.querySelectorAll('.undef-a').forEach(span=>{
          const j = +span.dataset.j;
          const v = A[j];
          span.textContent = (v!=null ? String(Number(v).toFixed(2)).replace(/\.00$/,'') : '-');
        });
      };
      inputs.forEach(inp=> inp.addEventListener('input', update));
    });

    const btnSkip = document.getElementById('undefDistSkip');
    const btnApply = document.getElementById('undefDistApply');

    btnSkip.onclick = ()=>{
      ui.hideAll();
      doneCb && doneCb();
    };

    btnApply.onclick = ()=>{
      // Save D overrides per swimmer
      (config.swimmers||[]).forEach((sw, i)=>{
        if (!sw) return;
        if (!Array.isArray(sw.partialSplitOverrides)) sw.partialSplitOverrides = [];
        const n = Array.isArray(config.partials) ? config.partials.length : 0;
        while (sw.partialSplitOverrides.length < n) sw.partialSplitOverrides.push(null);

        const inputs = cards.querySelectorAll(`input.undef-d[data-i="${i}"]`);
        if (!inputs.length) return;
        inputs.forEach(inp=>{
          const j = +inp.dataset.j;
          const v = parseNumOpt_(inp.value);
          sw.partialSplitOverrides[j] = (v!=null ? v : null);
        });
      });

      const r = recalcAllAccOverridesFromSplits_();
      if (!r.ok){
        if (typeof showToastBanner==='function') showToastBanner(r.msg || 'Distancias inválidas');
        else alert(r.msg || 'Distancias inválidas');
        return;
      }

      ui.hideAll();
      doneCb && doneCb();
    };
  }

  // --- Button display: undefined distance => show only TP/TA ---
  window.lap = function(e){
    const i = +e.target.dataset.i;
    const j = +e.target.dataset.j;
    const now = Date.now();
    if (!window.startTimes || !startTimes[i]) return;

    window.lapTimes[i] = lapTimes[i] || [];

    // No permitir saltar parciales (secuencia)
    if (j > 0 && lapTimes[i][j-1] == null) return;

    const tAcum = now - startTimes[i];
    const prevEvent = (j === 0) ? 0 : Number(lapTimes[i][j-1] || 0);
    const tSplitEvent = tAcum - prevEvent;

    // Guardar acumulado real
    lapTimes[i][j] = tAcum;

    const accUnits = (typeof getAccUnitsForSwimmer_==='function') ? getAccUnitsForSwimmer_(i,j) : null;

    // Caso: parcial sin distancia => SOLO TP / TA
    if (accUnits == null){
      const line1 = `TA ${fmtTime_(tAcum)}`;
      const line2 = `TP ${fmtTime_(tSplitEvent)}`;
      e.target.innerHTML = `<div>${line1}</div><div style="font-size:12px; opacity:.85">${line2}</div>`;
      e.target.disabled = true;
      e.target.classList.add('parcial-fixed');
      return;
    }

    const segUnits = (typeof getSplitUnitsForSwimmer_==='function') ? getSplitUnitsForSwimmer_(i,j) : null;

    const prevKnownTime = getPrevKnownAccTimeSafe_(i,j);
    const tSegForSpeed = tAcum - prevKnownTime;

    const vSeg = (typeof mps_==='function') ? mps_(segUnits, tSegForSpeed) : null;
    const vAvg = (typeof mps_==='function') ? mps_(accUnits, tAcum) : null;

    const line1 = `${fmtTime_(tAcum)}` + (vSeg != null ? ` (${vSeg.toFixed(2)} m/s)` : '');
    const line2 = `P ${fmtTime_(tSegForSpeed)}` + (vAvg != null ? ` · AVG ${vAvg.toFixed(2)} m/s` : '');

    e.target.innerHTML = `<div>${line1}</div><div style="font-size:12px; opacity:.85">${line2}</div>`;
    e.target.disabled = true;
    e.target.classList.add('parcial-fixed');
  };

  // FINAL: mismo criterio (si no hay D restante, mostrar solo TP/TA)
  window.fin = function(e){
    const i = +e.target.dataset.i;
    const now = Date.now();
    if (!window.startTimes || !startTimes[i]) return;

    const totalTime = now - startTimes[i];
    finishTimes[i] = totalTime;

    const laps = (lapTimes[i] || []);
    const lastEventIdx = laps.length ? (laps.length - 1) : -1;
    const lastEventTime = (lastEventIdx >= 0 && laps[lastEventIdx] != null) ? Number(laps[lastEventIdx]) : 0;
    const tSplitEvent = totalTime - lastEventTime;

    const total_units = Number((config && config.total) || 0);
    const prevKnownUnits = getPrevKnownAccUnitsSafe_(i, (Array.isArray(config.partials)?config.partials.length:0));
    // distance remaining (D final)
    const dFinal_units = (Number.isFinite(total_units) ? (total_units - Number(prevKnownUnits||0)) : null);
    const dFinal_m = toMetersOrNull_(dFinal_units);

    const prevKnownTime = getPrevKnownAccTimeSafe_(i, (Array.isArray(config.partials)?config.partials.length:0));
    const tSeg = totalTime - prevKnownTime;

    const vSeg = (typeof mps_==='function') ? mps_(dFinal_units, tSeg) : null;
    const vAvgTotal = (typeof mps_==='function') ? mps_(total_units, totalTime) : null;

    if (dFinal_m == null){
      const line1 = `<b>FINAL</b> TA ${fmtTime_(totalTime)}`;
      const line2 = `TP ${fmtTime_(tSplitEvent)}`;
      e.target.innerHTML = `<div>${line1}</div><div style="font-size:12px; opacity:.85">${line2}</div>`;
    } else {
      const line1 = `${fmtTime_(totalTime)}` + (vSeg != null ? ` (${vSeg.toFixed(2)} m/s)` : '');
      const line2 = `P ${fmtTime_(tSeg)}` + (vAvgTotal != null ? ` · AVG ${vAvgTotal.toFixed(2)} m/s` : '');
      e.target.innerHTML = `<div><b>FINAL</b> ${line1}</div><div style="font-size:12px; opacity:.85">${line2}</div>`;
    }

    e.target.disabled = true;
    e.target.classList.add('parcial-fixed');

    // finishedCount
    try{ window.finishedCount = (window.finishedCount||0) + 1; }catch(err){}

    if ((window.finishedCount||0) === (config.swimmers||[]).length) {
      try{ clearInterval(masterTimer); }catch(e){}
      try{ clearSpawnTimeouts && clearSpawnTimeouts(); }catch(e){}
      try{ stopBtn.disabled = true; }catch(e){}
      if (window.onSeriesAllFinishedUnified_) window.onSeriesAllFinishedUnified_();
      else if (window.onSeriesAllFinished_) window.onSeriesAllFinished_();
      else if (typeof showFinalModal==='function') showFinalModal();
    }
  };

  // --- Stop button: finalize all active swimmers and trigger unified flow ---
  try{
    const stopBtnEl = document.getElementById('stopBtn');
    if (stopBtnEl){
      stopBtnEl.addEventListener('click', (ev)=>{
        try{ ev.stopImmediatePropagation(); ev.preventDefault(); }catch(e){}
        try{ clearInterval(masterTimer); }catch(e){}
        try{ clearSpawnTimeouts && clearSpawnTimeouts(); }catch(e){}
        try{ stopBtnEl.disabled = true; }catch(e){}

        const n = (config.swimmers||[]).length;
        for (let i=0;i<n;i++){
          if (!startTimes || !startTimes[i]) continue;
          if (finishTimes && finishTimes[i]!=null) continue;
          const finBtn = document.querySelector(`#row${i} .fin`);
          if (finBtn){
            try{ window.fin({ target: finBtn }); }catch(e){}
          } else {
            // fallback
            finishTimes[i] = Date.now() - startTimes[i];
            window.finishedCount = (window.finishedCount||0) + 1;
          }
        }

        // if none were active, just show final modal
        if ((window.finishedCount||0) >= n){
          if (window.onSeriesAllFinishedUnified_) window.onSeriesAllFinishedUnified_();
          else if (window.onSeriesAllFinished_) window.onSeriesAllFinished_();
          else if (typeof showFinalModal==='function') showFinalModal();
        }
      }, true);
    }
  }catch(e){ console.error(e); }

  // --- Final unified flow: ask to complete D if there are pending undefined distances ---
  window.onSeriesAllFinishedUnified_ = function(){
    const afterStrokes = ()=>{
      const pending = (typeof getPendingUndefMap_==='function') ? getPendingUndefMap_() : [];
      const proceed = ()=>{
        try { if (typeof recalcAllAccOverridesFromSplits_==='function') { /* already */ } }catch(e){}
        try { saveExecutedSessionToLocal_ && saveExecutedSessionToLocal_(null); } catch(e){ console.error('autosave results error', e); }
        if (window.onSeriesAllFinished_) window.onSeriesAllFinished_();
        else if (typeof showFinalModal === 'function') showFinalModal();
      };
      if (pending && pending.length){
        openOptionalDistanceFlow_(pending, proceed);
      } else {
        proceed();
      }
    };

    if (typeof openStrokesModalIfNeeded_ === 'function'){
      openStrokesModalIfNeeded_(afterStrokes);
    } else {
      afterStrokes();
    }
  };

  // --- Build payload (preserve null distances; TP/TA always) ---
  window.buildSeriesPayload_ = function(){
    const now = new Date();
    try{ ensurePoolCourse_ && ensurePoolCourse_(); }catch(e){}

    const pool_course = String((config && config.pool_course) || "SCM");
    const pool_m = (pool_course === "LCM") ? 50 : 25;

    const distance_total_units = Number((config && config.total) || 0);
    const distance_unit = (typeof distUnitShort_==='function') ? distUnitShort_() : '';
    const distance_m = toMetersOrNull_(distance_total_units);

    // D por evento (incluye null) + FINAL
    const segSplit_units = (typeof getAllPartialsArr === "function") ? getAllPartialsArr() : [];
    const segSplit_m = (segSplit_units||[]).map(u => toMetersOrNull_(u));

    const swimmers = (config.swimmers||[]).map((sw, i)=>{
      const totalMs = (finishTimes && finishTimes[i]!=null) ? Number(finishTimes[i]) : null;
      const cumArr = (lapTimes && lapTimes[i]) ? lapTimes[i] : [];

      const strokesMode = !!(sw && sw.strokesEnabled);
      const strokeCounts = (sw && Array.isArray(sw.strokeCounts)) ? sw.strokeCounts : [];
      const hasCounts = Array.isArray(strokeCounts) && strokeCounts.some(v => v!=null && isFinite(Number(v)));
      const includeStrokes = strokesMode || hasCounts;

      const partials = [];
      const swolfVals = [];

      const nParts = Array.isArray(config.partials) ? config.partials.length : 0;

      // Parciales P1..Pn
      for (let j=0;j<nParts;j++){
        const tAcum = (cumArr && cumArr[j]!=null) ? Number(cumArr[j]) : null;
        if (tAcum==null || !isFinite(tAcum)) continue;

        const tP_event = getTPEventMs_(i,j,tAcum);
        const prevKnownTime = getPrevKnownAccTimeSafe_(i,j);
        const tSeg = tAcum - prevKnownTime;

        const A_units = (typeof getAccUnitsForSwimmer_==='function') ? getAccUnitsForSwimmer_(i,j) : null;
        const D_units = (typeof getSplitUnitsForSwimmer_==='function') ? getSplitUnitsForSwimmer_(i,j) : null;

        const A_m = toMetersOrNull_(A_units);
        const D_m = toMetersOrNull_(D_units);

        // tiempo para velocidad: si hay D -> tSeg, si no -> tP_event
        const tSplitForSpeed = (D_m!=null ? tSeg : tP_event);

        const v_mps = (D_m!=null && tSeg>0) ? Number((D_m / (tSeg/1000)).toFixed(3)) : null;
        const v_avg_mps = (A_m!=null && tAcum>0) ? Number((A_m / (tAcum/1000)).toFixed(3)) : null;

        const strokes = includeStrokes ? (strokeCounts[j] != null ? Number(strokeCounts[j]) : null) : null;
        const swolf = (includeStrokes && typeof calcSwolf_==='function') ? calcSwolf_(tSplitForSpeed, strokes) : null;
        if (swolf!=null) swolfVals.push(swolf);

        const label = (typeof getPartialLabel_==='function') ? getPartialLabel_(j) : ('P'+(j+1));
        const tag = (config.partialLabels && config.partialLabels[j]) ? String(config.partialLabels[j]) : '';

        partials.push({
          idx: j+1,
          label,
          tag,
          distance_units: (A_units!=null ? Number(A_units) : null),         // A (puede ser null)
          distance_m: (A_m!=null ? Number(A_m.toFixed(4)) : null),
          split_distance_units: (D_units!=null ? Number(D_units) : null),   // D (puede ser null)
          split_distance_m: (D_m!=null ? Number(D_m.toFixed(4)) : null),
          t_acum_ms: tAcum,
          t_split_ms: (tSplitForSpeed!=null && isFinite(tSplitForSpeed)) ? Number(tSplitForSpeed) : null,
          t_event_ms: (tP_event!=null && isFinite(tP_event)) ? Number(tP_event) : null,
          v_mps,
          v_avg_mps,
          t_acum_str: (typeof fmt_==="function") ? fmt_(tAcum) : (tAcum!=null ? String(tAcum) : ""),
          t_split_str: (typeof fmt_==="function" && tSplitForSpeed!=null) ? fmt_(tSplitForSpeed) : "",
          strokes: includeStrokes ? strokes : null,
          swolf
        });
      }

      // FINAL
      if (totalMs!=null && isFinite(totalMs)){
        const prevKnownTimeEnd = getPrevKnownAccTimeSafe_(i, nParts);
        const tSegEnd = totalMs - prevKnownTimeEnd;

        // last known A at end:
        let lastKnownA = 0;
        for (let k=nParts-1;k>=0;k--){
          const a = (typeof getAccUnitsForSwimmer_==='function') ? getAccUnitsForSwimmer_(i,k) : null;
          if (a!=null && isFinite(Number(a))){ lastKnownA = Number(a); break; }
        }
        const D_end_units = (Number.isFinite(distance_total_units) ? (distance_total_units - lastKnownA) : null);
        const D_end_m = toMetersOrNull_(D_end_units);
        const v_end = (D_end_m!=null && tSegEnd>0) ? Number((D_end_m / (tSegEnd/1000)).toFixed(3)) : null;
        const v_avg_total = (distance_m!=null && totalMs>0) ? Number((distance_m / (totalMs/1000)).toFixed(3)) : null;

        const tP_event_end = (nParts>0 && cumArr && cumArr[nParts-1]!=null) ? (totalMs - Number(cumArr[nParts-1]||0)) : totalMs;

        partials.push({
          idx: nParts+1,
          label: "FINAL",
          tag: "FINAL",
          distance_units: Number.isFinite(distance_total_units) ? distance_total_units : null,
          distance_m: (distance_m!=null ? Number(distance_m.toFixed(4)) : null),
          split_distance_units: (D_end_units!=null && isFinite(D_end_units)) ? Number(D_end_units) : null,
          split_distance_m: (D_end_m!=null ? Number(D_end_m.toFixed(4)) : null),
          t_acum_ms: totalMs,
          t_split_ms: (D_end_m!=null ? tSegEnd : tP_event_end),
          t_event_ms: tP_event_end,
          v_mps: v_end,
          v_avg_mps: v_avg_total,
          t_acum_str: (typeof fmt_==="function") ? fmt_(totalMs) : String(totalMs),
          t_split_str: (typeof fmt_==="function") ? fmt_((D_end_m!=null ? tSegEnd : tP_event_end)) : "",
          strokes: null,
          swolf: null
        });
      }

      const swolfBest = swolfVals.length ? Math.min(...swolfVals) : null;
      const swolfAvg = swolfVals.length ? Number((swolfVals.reduce((a,b)=>a+b,0)/swolfVals.length).toFixed(1)) : null;

      return {
        lane: (sw && sw.lane!=null) ? sw.lane : "",
        order: (sw && sw.order!=null) ? sw.order : "",
        name: (sw && sw.name) ? sw.name : ("Nadador "+(i+1)),
        swimmer_id: (sw && sw.swimmer_id) ? sw.swimmer_id : "",
        migrate_to_marks: !!(sw && sw.swimmer_id),
        strokes_enabled: strokesMode,
        stroke_counts: strokeCounts,
        swolf_best: swolfBest,
        swolf_avg: swolfAvg,
        total_time_ms: totalMs,
        total_time_str: (totalMs!=null && typeof fmt_==="function") ? fmt_(totalMs) : (totalMs!=null ? String(totalMs) : ""),
        partials,
        distance_overrides_units: (sw && Array.isArray(sw.partialAccOverrides)) ? sw.partialAccOverrides : null,
        split_overrides_units: (sw && Array.isArray(sw.partialSplitOverrides)) ? sw.partialSplitOverrides : null
      };
    });

    return {
      session: {
        name: String((config && config.name) || "Serie"),
        pool_course,
        pool_m,
        distance_unit,
        distance_total_units,
        distance_total: distance_total_units,
        distance_m: (distance_m!=null ? Number(distance_m.toFixed(4)) : null),
        partials: segSplit_units,
        partials_m: segSplit_m,
        partial_labels: Array.isArray(config.partialLabels) ? config.partialLabels : [],
        date: now.toISOString().slice(0,10),
        created_at: now.toISOString(),
        source: "MDV_CHRONO"
      },
      swimmers
    };
  };

  // --- Migration swimmer editor: make time readonly; allow editing D only; A readonly + full recalc ---
  window.openMigEdit_ = function(idx){
    if (!window.migEditModal) return;
    if (!window.lastPayload || !Array.isArray(lastPayload.swimmers) || !lastPayload.swimmers[idx]) return;

    const swP = lastPayload.swimmers[idx];
    window.migEditingIdx = idx;

    if (window.migEditMsg) migEditMsg.textContent = "";
    if (window.migEditName) migEditName.value = swP.name || "";
    if (window.migEditId) migEditId.value = swP.swimmer_id || "";
    if (window.migEditLane) migEditLane.value = swP.lane || "";
    if (window.migEditOrder) migEditOrder.value = swP.order || "";

    // Total time: readonly in editor (do not allow)
    if (window.migEditTotal){
      migEditTotal.value = (swP.total_time_ms!=null && typeof fmt_==="function") ? fmt_(swP.total_time_ms) : (swP.total_time_str||"");
      migEditTotal.setAttribute('readonly','readonly');
      migEditTotal.style.background = '#f9fafb';
    }

    const swIdx = idx;
    const laps = (window.lapTimes && lapTimes[swIdx]) ? lapTimes[swIdx] : [];
    const nParts = Array.isArray(config.partials) ? config.partials.length : 0;

    // Render rows
    if (window.migEditSplitsBody){
      let rows = "";
      for (let j=0;j<nParts;j++){
        if (laps[j]==null) continue;

        const label = (typeof getPartialLabel_==='function') ? getPartialLabel_(j) : ('P'+(j+1));
        const tA = Number(laps[j]);
        const tP = getTPEventMs_(swIdx,j,tA);

        const A_units = (typeof getAccUnitsForSwimmer_==='function') ? getAccUnitsForSwimmer_(swIdx,j) : null;
        const D_units = (typeof getSplitUnitsForSwimmer_==='function') ? getSplitUnitsForSwimmer_(swIdx,j) : null;

        const canEditD = !(config.partials[j]!=null && Number.isFinite(Number(config.partials[j]))); // solo si era opcional
        const dExisting = (config.swimmers && config.swimmers[swIdx] && Array.isArray(config.swimmers[swIdx].partialSplitOverrides))
          ? parseNumOpt_(config.swimmers[swIdx].partialSplitOverrides[j]) : null;

        rows += `<tr style="border-bottom:1px solid #f3f4f6;">
          <td style="padding:8px;"><b>${esc_(label)}</b></td>
          <td style="padding:8px;"><small style="color:#6b7280;">TP ${esc_(fmtTime_(tP))}<br>TA ${esc_(fmtTime_(tA))}</small></td>
          <td style="padding:8px;">
            <input class="mig-edit-d" data-j="${j}" type="text" inputmode="decimal" style="width:110px; ${canEditD?'':'opacity:.55;'}" ${canEditD?'':'readonly'} value="${dExisting!=null ? esc_(dExisting) : ''}" placeholder="${canEditD?'D':''}">
            <div style="font-size:12px; color:#6b7280; margin-top:4px;">A: <span class="mig-a" data-j="${j}">${A_units!=null ? esc_(String(A_units)) : '-'}</span></div>
          </td>
          <td style="padding:8px;"><small style="color:#6b7280;">D: <span class="mig-dcalc" data-j="${j}">${D_units!=null ? esc_(String(D_units)) : '-'}</span></small></td>
        </tr>`;
      }
      migEditSplitsBody.innerHTML = rows || `<tr><td colspan="4" style="padding:10px; color:#6b7280;"><i>Sin parciales</i></td></tr>`;

      // live recalc preview for this swimmer
      const inputs = migEditSplitsBody.querySelectorAll('input.mig-edit-d');
      const recompute = ()=>{
        const sw = config.swimmers[swIdx];
        if (!sw) return;
        // update split overrides from inputs (only optional)
        if (!Array.isArray(sw.partialSplitOverrides)) sw.partialSplitOverrides = [];
        while (sw.partialSplitOverrides.length < nParts) sw.partialSplitOverrides.push(null);
        inputs.forEach(inp=>{
          const j = +inp.dataset.j;
          const canEditD = !(config.partials[j]!=null && Number.isFinite(Number(config.partials[j])));
          if (!canEditD) return;
          const v = parseNumOpt_(inp.value);
          sw.partialSplitOverrides[j] = (v!=null ? v : null);
        });
        const r = recalcAllAccOverridesFromSplits_();
        if (!r.ok){
          if (window.migEditMsg) { migEditMsg.textContent = r.msg || 'Distancias inválidas'; migEditMsg.style.color = '#b91c1c'; }
          return;
        } else {
          if (window.migEditMsg) { migEditMsg.textContent = ''; }
        }
        // refresh A/D cells
        migEditSplitsBody.querySelectorAll('.mig-a').forEach(span=>{
          const j = +span.dataset.j;
          const A = (typeof getAccUnitsForSwimmer_==='function') ? getAccUnitsForSwimmer_(swIdx,j) : null;
          span.textContent = (A!=null ? String(A) : '-');
        });
        migEditSplitsBody.querySelectorAll('.mig-dcalc').forEach(span=>{
          const j = +span.dataset.j;
          const D = (typeof getSplitUnitsForSwimmer_==='function') ? getSplitUnitsForSwimmer_(swIdx,j) : null;
          span.textContent = (D!=null ? String(D) : '-');
        });
      };
      inputs.forEach(inp=> inp.addEventListener('input', recompute));
    }

    migEditModal.style.display = "flex";
    try{ document.body.classList.add("modal-open"); }catch(e){}
  };

  window.applyMigEditSave_ = function(){
    if (window.migEditingIdx==null) return;
    if (!window.lastPayload || !Array.isArray(lastPayload.swimmers) || !lastPayload.swimmers[migEditingIdx]) return;

    const swP = lastPayload.swimmers[migEditingIdx];
    const sw = (config.swimmers||[])[migEditingIdx];

    // Save basic fields
    swP.name = migEditName ? String(migEditName.value||"").trim() : (swP.name||"");
    swP.lane = migEditLane ? String(migEditLane.value||"").trim() : (swP.lane||"");
    swP.order = migEditOrder ? String(migEditOrder.value||"").trim() : (swP.order||"");
    swP.swimmer_id = migEditId ? String(migEditId.value||"").trim() : (swP.swimmer_id||"");
    swP.migrate_to_marks = !!swP.swimmer_id;

    // Mirror to config.swimmers so local persists
    if (sw){
      sw.name = swP.name;
      sw.lane = swP.lane;
      sw.order = swP.order;
      sw.swimmer_id = swP.swimmer_id;
    }

    // Distances already captured via live recompute (split overrides + acc overrides)
    const r = recalcAllAccOverridesFromSplits_();
    if (!r.ok){
      if (window.migEditMsg){ migEditMsg.textContent = r.msg || 'Distancias inválidas'; migEditMsg.style.color = '#b91c1c'; }
      return;
    }

    // Rebuild payload so editor/JSON shows definitive values
    try{
      window.lastPayload = buildSeriesPayload_();
      if (window.elJson) elJson.value = JSON.stringify(lastPayload, null, 2);
    }catch(e){ console.error(e); }

    // refresh migration UI if exists
    try{ if (typeof renderMigrationModal_==='function') renderMigrationModal_(); }catch(e){}
    try{ if (typeof showToastBanner==='function') showToastBanner('Distancias actualizadas'); }catch(e){}

    // close
    try{
      if (window.migEditModal) migEditModal.style.display = 'none';
      document.body.classList.remove('modal-open');
    }catch(e){}
  };

})();
</script>
<!-- ===== END v38E PATCH ===== -->

<!-- ===== v38F PATCH: Optional distances effective (TP/TA in-run, D editable & times readonly, stop triggers flow) ===== -->
<script>
(()=> {
  if (window.__v38F_applied__) return;
  window.__v38F_applied__ = true;

  const $ = (id)=>document.getElementById(id);

  const parseNumOpt_ = (v)=>{
    if (v==null) return null;
    const s = String(v).trim();
    if (!s) return null;
    const n = Number(s.replace(',', '.'));
    return Number.isFinite(n) ? n : null;
  };

  const fmtMs_ = (ms)=>{
    try{ return (typeof format==='function') ? format(ms) : (typeof fmt_==='function' ? fmt_(ms) : String(ms)); }
    catch(e){ return String(ms); }
  };

  const distUnit_ = ()=>{
    try{ return (typeof distUnitShort_==='function') ? distUnitShort_() : ''; }catch(e){ return ''; }
  };

  const toMetersOrNull_ = (n)=>{
    if (n==null || !Number.isFinite(Number(n))) return null;
    try{ return (typeof toMeters_==='function') ? toMeters_(Number(n)) : Number(n); }catch(e){ return Number(n); }
  };

  const getPrevLapMs_ = (i,j)=>{
    const laps = (window.lapTimes && lapTimes[i]) ? lapTimes[i] : [];
    for (let k=j-1;k>=0;k--){
      if (laps[k]!=null && isFinite(Number(laps[k]))) return Number(laps[k]);
    }
    return 0;
  };

  const getTPMs_ = (i,j,tAcum)=> {
    const prev = getPrevLapMs_(i,j);
    return (tAcum!=null && isFinite(Number(tAcum))) ? (Number(tAcum) - prev) : null;
  };

  const isOptDistIdx_ = (j)=>{
    try{
      const parts = (window.config && Array.isArray(config.partials)) ? config.partials : [];
      return (j>=0 && j<parts.length && (parts[j]==null || String(parts[j]).trim()===''));
    }catch(e){ return false; }
  };

  const getAUnits_ = (i,j)=>{
    if (typeof getAccUnitsForSwimmer_ === 'function'){
      return getAccUnitsForSwimmer_(i,j);
    }
    try{
      const parts = (config && Array.isArray(config.partials)) ? config.partials : [];
      const v = parts[j];
      return (v==null || String(v).trim()==='') ? null : Number(v);
    }catch(e){ return null; }
  };

  const getDUnitsFallback_ = (j)=>{
    try{
      const parts = (config && Array.isArray(config.partials)) ? config.partials : [];
      const Aj = parts[j];
      if (Aj==null || String(Aj).trim()==='') return null;
      let prevA = 0;
      for (let k=j-1;k>=0;k--){
        const Ak = parts[k];
        if (Ak!=null && String(Ak).trim()!==''){ prevA = Number(Ak); break; }
      }
      return Number(Aj) - Number(prevA);
    }catch(e){ return null; }
  };

  const getDUnits_ = (i,j)=>{
    if (typeof getSplitUnitsForSwimmer_ === 'function'){
      return getSplitUnitsForSwimmer_(i,j);
    }
    return getDUnitsFallback_(j);
  };

  // --- patched lap/fin ---
  function lapV38F(e){
    try{
      const btn = (e && e.currentTarget && e.currentTarget.matches && e.currentTarget.matches('button')) 
        ? e.currentTarget 
        : (e && e.target && e.target.closest ? e.target.closest('button') : e.target);
      if (!btn || !btn.dataset) return;

      const i = Number(btn.dataset.i);
      const j = Number(btn.dataset.j);
      if (!Number.isFinite(i) || !Number.isFinite(j)) return;
      if (window.finishTimes && finishTimes[i] != null) return;
      if (!window.startTimes || startTimes[i] == null) return;

      const now = Date.now();
      const tAcum = now - Number(startTimes[i]);
      if (!window.lapTimes) window.lapTimes = {};
      if (!lapTimes[i]) lapTimes[i] = [];
      lapTimes[i][j] = tAcum;

      const tP = getTPMs_(i,j,tAcum);

      const A_units = getAUnits_(i,j);

      if (A_units == null){
        // optional distance: show TA/TP only
        btn.innerHTML = `
          <div style="font-weight:700;">TA ${fmtMs_(tAcum)}</div>
          <div style="margin-top:2px; font-size:0.92em; opacity:0.95;">TP ${fmtMs_(tP)}</div>
        `;
      } else {
        const D_units = getDUnits_(i,j);
        const D_m = toMetersOrNull_(D_units);
        const A_m = toMetersOrNull_(A_units);
        const tP_s = (tP!=null && tP>0) ? (tP/1000) : null;
        const tA_s = (tAcum>0) ? (tAcum/1000) : null;

        const vSplit = (D_m!=null && tP_s) ? (D_m / tP_s) : null;
        const vAvg = (A_m!=null && tA_s) ? (A_m / tA_s) : null;

        const vs = (vSplit!=null && isFinite(vSplit)) ? vSplit.toFixed(2) : "0.00";
        const va = (vAvg!=null && isFinite(vAvg)) ? vAvg.toFixed(2) : "0.00";
        btn.innerHTML = `
          <div style="font-weight:700;">${fmtMs_(tAcum)}</div>
          <div style="margin-top:2px;">(${vs} m/s)</div>
          <div style="margin-top:2px; font-size:0.92em;">AVG ${va} m/s</div>
        `;
      }

      btn.disabled = true;
      btn.classList.add('done');

      try{ if (typeof updateBestSplitsTable === 'function') updateBestSplitsTable(); }catch(_){}
    }catch(err){
      console.error('lapV38F error', err);
    }
  }

  function finV38F(e){
    try{
      const btn = (e && e.currentTarget && e.currentTarget.matches && e.currentTarget.matches('button')) 
        ? e.currentTarget 
        : (e && e.target && e.target.closest ? e.target.closest('button') : e.target);
      if (!btn || !btn.dataset) return;

      const i = Number(btn.dataset.i);
      if (!Number.isFinite(i)) return;
      if (!window.startTimes || startTimes[i]==null) return;
      if (!window.finishTimes) window.finishTimes = [];
      if (finishTimes[i] != null) return;

      const now = Date.now();
      const totalMs = now - Number(startTimes[i]);
      finishTimes[i] = totalMs;

      // Disable any remaining lap buttons in that row
      const row = btn.closest('tr');
      if (row){
        row.querySelectorAll('button[data-j]').forEach(b=>{ b.disabled = true; });
      }

      // Render FIN button: time + AVG
      const total_units = Number((config && config.total) || 0);
      const total_m = toMetersOrNull_(total_units);
      const vAvg = (total_m!=null && totalMs>0) ? (total_m / (totalMs/1000)) : 0;
      btn.innerHTML = `
        <div style="font-weight:700;">${fmtMs_(totalMs)}</div>
        <div style="margin-top:2px; font-size:0.92em;">AVG ${vAvg.toFixed(2)} m/s</div>
      `;
      btn.disabled = true;
      btn.classList.add('done');

      // update finished count
      try{
        window.finishedCount = (window.finishTimes||[]).filter(x=>x!=null).length;
      }catch(_){}

      // if all finished -> trigger unified end-of-series flow
      const totalSw = (config && Array.isArray(config.swimmers)) ? config.swimmers.length : 0;
      const doneSw = (window.finishTimes||[]).filter(x=>x!=null).length;
      if (totalSw && doneSw >= totalSw){
        // stop master timer if running
        try{ if (window.masterTimer) { clearInterval(masterTimer); masterTimer = null; } }catch(_){}
        try{
          const fn = window.onSeriesAllFinishedUnified_ || window.onSeriesAllFinishedUnified;
          if (typeof fn === 'function') fn();
          else if (typeof window.onSeriesAllFinished_ === 'function') window.onSeriesAllFinished_();
          else if (typeof showFinalModal === 'function') showFinalModal();
        }catch(err){ console.error(err); }
      }
    }catch(err){
      console.error('finV38F error', err);
    }
  }

  // Assign to the identifiers used when wiring events in spawn()
  try{ window.lap = lapV38F; }catch(_){}
  try{ lap = lapV38F; }catch(_){}
  try{ window.fin = finV38F; }catch(_){}
  try{ fin = finV38F; }catch(_){}

  // --- Stop button: finalize all active swimmers then run unified flow ---
  function stopFinalizeAll_(){
    try{
      const totalSw = (config && Array.isArray(config.swimmers)) ? config.swimmers.length : 0;
      if (!totalSw) return;
      if (!window.finishTimes) window.finishTimes = [];

      // ensure master timer stopped (existing handler may do it too)
      try{ if (window.masterTimer) { clearInterval(masterTimer); masterTimer = null; } }catch(_){}

      const now = Date.now();
      for (let i=0;i<totalSw;i++){
        if (finishTimes[i]!=null) continue;
        if (!window.startTimes || startTimes[i]==null) continue;

        const totalMs = now - Number(startTimes[i]);
        finishTimes[i] = totalMs;

        const finBtn = document.querySelector(`button.fin[data-i="${i}"]`);
        if (finBtn){
          const total_units = Number((config && config.total) || 0);
          const total_m = toMetersOrNull_(total_units);
          const vAvg = (total_m!=null && totalMs>0) ? (total_m / (totalMs/1000)) : 0;
          finBtn.innerHTML = `
            <div style="font-weight:700;">${fmtMs_(totalMs)}</div>
            <div style="margin-top:2px; font-size:0.92em;">AVG ${vAvg.toFixed(2)} m/s</div>
          `;
          finBtn.disabled = true;
          finBtn.classList.add('done');
          const row = finBtn.closest('tr');
          if (row) row.querySelectorAll('button[data-j]').forEach(b=>{ b.disabled = true; });
        }
      }

      window.finishedCount = totalSw;

      // trigger unified end-of-series flow
      const fn = window.onSeriesAllFinishedUnified_ || window.onSeriesAllFinishedUnified;
      if (typeof fn === 'function') fn();
      else if (typeof window.onSeriesAllFinished_ === 'function') window.onSeriesAllFinished_();
      else if (typeof showFinalModal === 'function') showFinalModal();
    }catch(err){
      console.error('stopFinalizeAll_ error', err);
    }
  }

  // add stop hook once
  try{
    const stopBtn = $('stopBtn');
    if (stopBtn && !stopBtn.__v38fStopHook){
      stopBtn.__v38fStopHook = true;
      stopBtn.addEventListener('click', ()=> stopFinalizeAll_());
    }
  }catch(e){ console.error(e); }

  // --- Optional distance UI: D editable, A readonly (override existing, used at series end) ---
  function ensureUndefDistUI_v38F_(){
    if ($('undefDistOverlay')) return;

    const style = document.createElement('style');
    style.textContent = `
      #undefDistModal .cards{ display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); gap:12px; }
      #undefDistModal .card{ border:1px solid #e5e7eb; border-radius:12px; padding:12px; background:#fff; }
      #undefDistModal .row{ display:grid; grid-template-columns: 1fr 90px 90px; gap:8px; align-items:center; margin:6px 0; }
      #undefDistModal .row .lab{ font-weight:600; }
      #undefDistModal input{ width:100%; padding:6px 8px; border:1px solid #d1d5db; border-radius:8px; }
      #undefDistModal .muted{ color:#6b7280; font-size:0.9em; }
      #undefDistModal .pill{ display:inline-block; padding:4px 10px; border-radius:999px; background:#eef2ff; font-size:0.86em; }
      #undefDistAskModal p{ margin:0 0 8px 0; }
    `;
    document.head.appendChild(style);

    const overlay = document.createElement('div');
    overlay.id = 'undefDistOverlay';
    overlay.className = 'modal-overlay';
    overlay.style.display = 'none';
    overlay.style.zIndex = '1200';
    document.body.appendChild(overlay);

    const ask = document.createElement('div');
    ask.id = 'undefDistAskModal';
    ask.className = 'modal';
    ask.style.display = 'none';
    ask.style.maxWidth = '520px';
    ask.style.zIndex = '1210';
    ask.innerHTML = `
      <div class="modal-header">
        <h2>¿Completar distancias opcionales?</h2>
        <button class="close-btn" id="closeUndefAsk">&times;</button>
      </div>
      <div class="modal-body">
        <p>Se registraron tiempos en parciales cuya <b>distancia no estaba definida</b> (por ejemplo: <i>vuelo de la partida</i> o <i>subacuático</i>).</p>
        <p>¿Querés cargar la <b>distancia parcial (D)</b> para esos parciales, por nadador?</p>
        <div style="margin-top:10px;"><span class="pill">Tip: podés omitir y quedarte solo con los tiempos</span></div>
      </div>
      <div class="modal-footer" style="display:flex; justify-content:flex-end; gap:10px;">
        <button class="secondary" id="undefAskNo">No, continuar</button>
        <button class="primary" id="undefAskYes">Sí, completar</button>
      </div>
    `;
    document.body.appendChild(ask);

    const modal = document.createElement('div');
    modal.id = 'undefDistModal';
    modal.className = 'modal';
    modal.style.display = 'none';
    modal.style.maxWidth = '980px';
    modal.style.zIndex = '1210';
    modal.innerHTML = `
      <div class="modal-header">
        <h2>Completar distancias (D) – por nadador</h2>
        <button class="close-btn" id="closeUndefModal">&times;</button>
      </div>
      <div class="modal-body">
        <div class="muted">Completá solo las distancias que te interesen. La <b>distancia acumulada (A)</b> se recalcula automáticamente.</div>
        <div id="undefCards" class="cards" style="margin-top:12px;"></div>
      </div>
      <div class="modal-footer" style="display:flex; justify-content:flex-end; gap:10px;">
        <button class="secondary" id="undefCancel">Cancelar</button>
        <button class="primary" id="undefSave">Guardar</button>
      </div>
    `;
    document.body.appendChild(modal);

    const showOverlay = (on)=>{ overlay.style.display = on ? 'block' : 'none'; };

    const hideAll = ()=>{
      showOverlay(false);
      ask.style.display = 'none';
      modal.style.display = 'none';
      try{ document.body.classList.remove('modal-open'); }catch(e){}
    };

    overlay.addEventListener('click', hideAll);
    ask.querySelector('#closeUndefAsk').addEventListener('click', hideAll);
    modal.querySelector('#closeUndefModal').addEventListener('click', hideAll);
    modal.querySelector('#undefCancel').addEventListener('click', hideAll);

    window.__undefDistUI__ = { overlay, ask, modal, showOverlay, hideAll };
  }

  try{ window.ensureUndefDistUI_ = ensureUndefDistUI_v38F_; }catch(_){}
  try{ ensureUndefDistUI_ = ensureUndefDistUI_v38F_; }catch(_){}

  function openUndefEditor_v38F_(pendingIdxs, done){
    ensureUndefDistUI_v38F_();
    const ui = window.__undefDistUI__;
    if (!ui) { done && done(); return; }

    ui.showOverlay(true);
    ui.ask.style.display = 'none';
    ui.modal.style.display = 'block';
    try{ document.body.classList.add('modal-open'); }catch(e){}

    const unit = distUnit_();
    const cards = $('undefCards');
    if (!cards) { done && done(); return; }

    let cardsHtml = '';
    (config.swimmers||[]).forEach((sw, i)=>{
      const laps = (window.lapTimes && lapTimes[i]) ? lapTimes[i] : [];
      const used = pendingIdxs.some(j => laps[j]!=null);
      if (!used) return;

      if (!Array.isArray(sw.partialSplitOverrides)) sw.partialSplitOverrides = [];
      if (!Array.isArray(sw.partialAccOverrides)) sw.partialAccOverrides = [];

      let rows = '';
      pendingIdxs.forEach(j=>{
        if (laps[j]==null) return;
        const label = (typeof getPartialLabel_==='function') ? getPartialLabel_(j) : ('P'+(j+1));
        const tA = Number(laps[j]);
        const tP = getTPMs_(i,j,tA);

        const dVal = (sw.partialSplitOverrides[j]!=null) ? sw.partialSplitOverrides[j] : '';

        const A_units = getAUnits_(i,j);
        const aTxt = (A_units==null) ? '—' : (String(A_units)+unit);

        rows += `
          <div class="row">
            <div>
              <div class="lab">${label}</div>
              <div class="muted">TA ${fmtMs_(tA)} • TP ${fmtMs_(tP)}</div>
            </div>
            <div>
              <input class="undefD" data-i="${i}" data-j="${j}" inputmode="decimal" placeholder="D ${unit}" value="${dVal}">
            </div>
            <div class="muted" id="undefA_${i}_${j}">A ${aTxt}</div>
          </div>
        `;
      });

      if (!rows) return;

      cardsHtml += `
        <div class="card" data-i="${i}">
          <div style="font-weight:700; margin-bottom:6px;">${(sw.name||('Swimmer '+(i+1)))}</div>
          ${rows}
        </div>
      `;
    });

    cards.innerHTML = cardsHtml || '<div class="muted">No hay parciales pendientes para completar.</div>';

    cards.querySelectorAll('input.undefD').forEach(inp=>{
      inp.addEventListener('input', ()=>{
        const i = Number(inp.dataset.i);
        const j = Number(inp.dataset.j);
        const v = parseNumOpt_(inp.value);
        const sw = (config.swimmers||[])[i];
        if (!sw) return;
        if (!Array.isArray(sw.partialSplitOverrides)) sw.partialSplitOverrides = [];
        sw.partialSplitOverrides[j] = v;

        try{ if (typeof recalcAllAccOverridesFromSplits_==='function') recalcAllAccOverridesFromSplits_(); }catch(e){}

        const A_units = getAUnits_(i,j);
        const unit = distUnit_();
        const aTxt = (A_units==null) ? '—' : (String(A_units)+unit);
        const el = $('undefA_'+i+'_'+j);
        if (el) el.textContent = 'A ' + aTxt;
      });
    });

    const saveBtn = $('undefSave');
    const cancelBtn = $('undefCancel');
    if (saveBtn){
      saveBtn.onclick = ()=>{
        try{ if (typeof recalcAllAccOverridesFromSplits_==='function') recalcAllAccOverridesFromSplits_(); }catch(e){}
        ui.hideAll();
        done && done();
      };
    }
    if (cancelBtn){
      cancelBtn.onclick = ()=>{ ui.hideAll(); done && done(); };
    }
  }

  try{ window.openUndefEditor_ = openUndefEditor_v38F_; }catch(_){}
  try{ openUndefEditor_ = openUndefEditor_v38F_; }catch(_){}

  // --- Migration editor: times readonly, D editable only, A readonly (only for optional-distance partials) ---
  function openMigEditV38F_(idx){
    const modal = $('migEditModal');
    if (!modal) return;

    modal.style.display = 'block';
    try{ document.body.classList.add('modal-open'); }catch(e){}

    const sw = (config.swimmers||[])[idx];
    if (!sw) return;

    const setVal = (id, val)=>{ const el=$(id); if (el) el.value = (val==null?'':String(val)); };

    setVal('migEditName', sw.name||'');
    setVal('migEditId', sw.swimmer_id||'');
    setVal('migEditLane', sw.lane||'');
    setVal('migEditOrder', sw.order||'');

    const totalMs = (window.finishTimes && finishTimes[idx]!=null) ? Number(finishTimes[idx]) : null;
    const totalEl = $('migEditTotal');
    if (totalEl){
      totalEl.value = (totalMs!=null && isFinite(totalMs)) ? fmtMs_(totalMs) : '';
      totalEl.readOnly = true;
    }

    const body = $('migEditSplitsBody');
    if (!body) return;

    const parts = Array.isArray(config.partials) ? config.partials : [];
    const nParts = parts.length;

    const laps = (window.lapTimes && lapTimes[idx]) ? lapTimes[idx] : [];

    if (!Array.isArray(sw.partialSplitOverrides)) sw.partialSplitOverrides = [];
    if (!Array.isArray(sw.partialAccOverrides)) sw.partialAccOverrides = [];

    const unit = distUnit_();

    let rows = '';
    for (let j=0;j<nParts;j++){
      if (laps[j]==null) continue;

      const label = (typeof getPartialLabel_==='function') ? getPartialLabel_(j) : ('P'+(j+1));
      const tA = Number(laps[j]);
      const tP = getTPMs_(idx,j,tA);

      const isOpt = isOptDistIdx_(j);
      const A_units = getAUnits_(idx,j);

      const dVal = (sw.partialSplitOverrides[j]!=null) ? sw.partialSplitOverrides[j] : '';
      const aTxt = (A_units==null) ? '—' : (String(A_units)+unit);

      rows += `
        <tr>
          <td>${label}</td>
          <td style="white-space:nowrap;">TA ${fmtMs_(tA)}<br>TP ${fmtMs_(tP)}</td>
          <td>
            <input class="migD" data-j="${j}" inputmode="decimal" ${isOpt ? '' : 'disabled'} placeholder="D ${unit}" value="${isOpt ? dVal : ''}">
          </td>
          <td id="migA_${j}">A ${aTxt}</td>
        </tr>
      `;
    }

    if (totalMs!=null && isFinite(totalMs)){
      const Df = (typeof getFinalSplitUnitsForSwimmer_==='function') ? getFinalSplitUnitsForSwimmer_(idx) : null;
      const Af = Number((config && config.total) || 0);
      const dTxt = (Df==null) ? '—' : (String(Df)+unit);
      const aTxt = (Af==null) ? '—' : (String(Af)+unit);
      rows += `
        <tr>
          <td><b>FINAL</b></td>
          <td>TA ${fmtMs_(totalMs)}</td>
          <td>D ${dTxt}</td>
          <td>A ${aTxt}</td>
        </tr>
      `;
    }

    body.innerHTML = rows || '';
    body.querySelectorAll('input.migD').forEach(inp=>{
      inp.addEventListener('input', ()=>{
        const j = Number(inp.dataset.j);
        const v = parseNumOpt_(inp.value);
        if (!Array.isArray(sw.partialSplitOverrides)) sw.partialSplitOverrides = [];
        sw.partialSplitOverrides[j] = v;

        try{ if (typeof recalcAllAccOverridesFromSplits_==='function') recalcAllAccOverridesFromSplits_(); }catch(e){}

        const A_units = getAUnits_(idx,j);
        const aTxt = (A_units==null) ? '—' : (String(A_units)+unit);
        const el = $('migA_'+j);
        if (el) el.textContent = 'A ' + aTxt;
      });
    });

    window.migEditingIdx = idx;
  }

  function applyMigSaveV38F_(){
    try{
      const idx = Number(window.migEditingIdx);
      const sw = (config.swimmers||[])[idx];
      if (!sw) return;

      const body = $('migEditSplitsBody');
      if (body){
        body.querySelectorAll('input.migD').forEach(inp=>{
          const j = Number(inp.dataset.j);
          const v = parseNumOpt_(inp.value);
          if (!Array.isArray(sw.partialSplitOverrides)) sw.partialSplitOverrides = [];
          sw.partialSplitOverrides[j] = v;
        });
      }

      try{ if (typeof recalcAllAccOverridesFromSplits_==='function') recalcAllAccOverridesFromSplits_(); }catch(e){}

      try{
        if (typeof window.buildSeriesPayload_ === 'function'){
          window.lastPayload = window.buildSeriesPayload_();
        }
      }catch(e){ console.error(e); }

      const modal = $('migEditModal');
      if (modal) modal.style.display = 'none';
      try{ document.body.classList.remove('modal-open'); }catch(e){}
    }catch(err){
      console.error('applyMigSaveV38F_ error', err);
    }
  }

  try{ window.openMigEdit_ = openMigEditV38F_; }catch(_){}
  try{ openMigEdit_ = openMigEditV38F_; }catch(_){}

  // rewire save button to our handler (remove old listener by clone)
  try{
    const saveBtn = $('migEditSave');
    if (saveBtn && !saveBtn.__v38fRewired){
      saveBtn.__v38fRewired = true;
      const clone = saveBtn.cloneNode(true);
      saveBtn.parentNode.replaceChild(clone, saveBtn);
      clone.id = 'migEditSave';
      clone.addEventListener('click', applyMigSaveV38F_);
    }
  }catch(e){ console.error(e); }

})();
</script>

<!-- ===== v38F PATCH: Optional distances final override (TP/TA only, D-only editors, unified flow) ===== -->
<script>
(() => {
  if (window.__v38F_optionalDistancesFinal__) return;
  window.__v38F_optionalDistancesFinal__ = true;

  const parseNumOpt_ = (v) => {
    if (v == null) return null;
    const s = String(v).trim();
    if (!s) return null;
    const n = Number(s.replace(',', '.'));
    return Number.isFinite(n) ? n : null;
  };

  const isBlank_ = (v) => (v == null || String(v).trim() === '');

  const normalizeConfigPartials_ = () => {
    if (!window.config || !Array.isArray(config.partials)) return;
    config.partials = config.partials.map(v => (isBlank_(v) ? null : v));
  };

  const distUnit_ = () => {
    try { return (typeof distUnitShort_ === 'function') ? distUnitShort_() : ''; } catch (e) { return ''; }
  };

  const fmtMs_ = (ms) => {
    try { return (typeof format === 'function') ? format(ms) : (typeof fmt_ === 'function' ? fmt_(ms) : String(ms)); }
    catch (e) { return String(ms); }
  };

  const toMetersOrNull_ = (u) => {
    const n = parseNumOpt_(u);
    if (n == null) return null;
    try { return (typeof toMeters_ === 'function') ? toMeters_(n) : n; } catch (e) { return n; }
  };

  const mps_ = (units, ms) => {
    const d = toMetersOrNull_(units);
    if (d == null || !ms || ms <= 0) return null;
    return d / (ms / 1000);
  };

  window.getAccUnitsForSwimmer_ = function(swIdx, j){
    normalizeConfigPartials_();
    if (!window.config || !Array.isArray(config.partials)) return null;

    const baseRaw = config.partials[j];
    const base = parseNumOpt_(baseRaw);
    if (base != null) return base;

    const sw = (config.swimmers && config.swimmers[swIdx]) ? config.swimmers[swIdx] : null;
    const ov = sw && Array.isArray(sw.partialAccOverrides) ? sw.partialAccOverrides[j] : null;
    const acc = parseNumOpt_(ov);
    return (acc != null) ? acc : null;
  };

  window.getPrevKnownAccUnits_ = function(swIdx, j){
    for (let k = j - 1; k >= 0; k--){
      const a = window.getAccUnitsForSwimmer_(swIdx, k);
      if (a != null && Number.isFinite(Number(a))) return Number(a);
    }
    return 0;
  };

  window.getPrevKnownAccTimeMs_ = function(swIdx, j){
    const laps = (window.lapTimes && lapTimes[swIdx]) ? lapTimes[swIdx] : [];
    for (let k = j - 1; k >= 0; k--){
      if (laps[k] != null && Number.isFinite(Number(laps[k]))) return Number(laps[k]);
    }
    return 0;
  };

  window.getSplitUnitsForSwimmer_ = function(swIdx, j){
    const acc = window.getAccUnitsForSwimmer_(swIdx, j);
    if (acc == null) return null;
    const prevAcc = window.getPrevKnownAccUnits_(swIdx, j);
    const d = Number(acc) - Number(prevAcc);
    return Number.isFinite(d) ? d : null;
  };

  window.getFinalSplitUnitsForSwimmer_ = function(swIdx){
    const total = parseNumOpt_(config && config.total);
    if (total == null) return null;
    const n = Array.isArray(config.partials) ? config.partials.length : 0;
    let lastKnown = 0;
    for (let k = n - 1; k >= 0; k--){
      const a = window.getAccUnitsForSwimmer_(swIdx, k);
      if (a != null && Number.isFinite(Number(a))){ lastKnown = Number(a); break; }
    }
    const d = total - lastKnown;
    return Number.isFinite(d) ? d : null;
  };

  window.getPendingUndefMap_ = function(){
    normalizeConfigPartials_();
    const pending = [];
    const parts = Array.isArray(config.partials) ? config.partials : [];
    for (let j = 0; j < parts.length; j++){
      const v = parseNumOpt_(parts[j]);
      if (v != null) continue;
      let used = false;
      for (let i = 0; i < (config.swimmers || []).length; i++){
        const laps = lapTimes[i] || [];
        if (laps[j] != null){ used = true; break; }
      }
      if (used) pending.push(j);
    }
    return pending;
  };

  window.recalcAllAccOverridesFromSplits_ = function(){
    normalizeConfigPartials_();
    const total = parseNumOpt_(config && config.total);
    const n = Array.isArray(config.partials) ? config.partials.length : 0;
    const isAnchor = (v) => (parseNumOpt_(v) != null);

    for (let i = 0; i < (config.swimmers || []).length; i++){
      const sw = config.swimmers[i];
      if (!sw) continue;

      if (!Array.isArray(sw.partialSplitOverrides)) sw.partialSplitOverrides = [];
      if (!Array.isArray(sw.partialAccOverrides)) sw.partialAccOverrides = [];

      while (sw.partialSplitOverrides.length < n) sw.partialSplitOverrides.push(null);
      while (sw.partialAccOverrides.length < n) sw.partialAccOverrides.push(null);

      let lastKnownA = 0;

      for (let j = 0; j < n; j++){
        const anchorA = isAnchor(config.partials[j]) ? Number(parseNumOpt_(config.partials[j])) : null;

        if (anchorA != null){
          if (lastKnownA > anchorA + 1e-9){
            return { ok:false, msg:`Distancias inconsistentes en ${sw.name||('Nadador '+(i+1))}: antes de ${typeof getPartialLabel_==='function'?getPartialLabel_(j):('P'+(j+1))} superan A=${anchorA}.` };
          }
          sw.partialAccOverrides[j] = null;
          lastKnownA = anchorA;
          continue;
        }

        const d = parseNumOpt_(sw.partialSplitOverrides[j]);
        if (d != null){
          const nextA = lastKnownA + d;
          if (total != null && nextA > total + 1e-9){
            return { ok:false, msg:`Distancia excede total en ${sw.name||('Nadador '+(i+1))} (${typeof getPartialLabel_==='function'?getPartialLabel_(j):('P'+(j+1))}).` };
          }
          lastKnownA = nextA;
          sw.partialAccOverrides[j] = lastKnownA;
        } else {
          sw.partialAccOverrides[j] = null;
        }
      }
    }
    return { ok:true };
  };

  const getTPMs_ = (i, j, tAcum) => {
    const prev = window.getPrevKnownAccTimeMs_ ? window.getPrevKnownAccTimeMs_(i, j) : 0;
    return (tAcum != null && Number.isFinite(Number(tAcum))) ? (Number(tAcum) - prev) : null;
  };

  window.lap = function(e){
    try{
      const btn = (e && e.currentTarget && e.currentTarget.matches && e.currentTarget.matches('button'))
        ? e.currentTarget
        : (e && e.target && e.target.closest ? e.target.closest('button') : e.target);
      if (!btn || !btn.dataset) return;

      const i = Number(btn.dataset.i);
      const j = Number(btn.dataset.j);
      if (!Number.isFinite(i) || !Number.isFinite(j)) return;
      if (window.finishTimes && finishTimes[i] != null) return;
      if (!window.startTimes || startTimes[i] == null) return;

      const now = Date.now();
      const tAcum = now - Number(startTimes[i]);

      if (!window.lapTimes) window.lapTimes = [];
      if (!lapTimes[i]) lapTimes[i] = [];

      if (j > 0 && lapTimes[i][j - 1] == null) return;

      lapTimes[i][j] = tAcum;

      const tP = getTPMs_(i, j, tAcum);
      const accUnits = window.getAccUnitsForSwimmer_ ? window.getAccUnitsForSwimmer_(i, j) : null;

      if (accUnits == null){
        btn.innerHTML = `
          <div style="font-weight:700;">TA ${fmtMs_(tAcum)}</div>
          <div style="margin-top:2px; font-size:0.92em; opacity:0.95;">TP ${fmtMs_(tP)}</div>
        `;
      } else {
        const segUnits = window.getSplitUnitsForSwimmer_ ? window.getSplitUnitsForSwimmer_(i, j) : null;
        const prevKnownTime = window.getPrevKnownAccTimeMs_ ? window.getPrevKnownAccTimeMs_(i, j) : 0;
        const tSeg = tAcum - prevKnownTime;
        const vSeg = mps_(segUnits, tSeg);
        const vAvg = mps_(accUnits, tAcum);
        const line1 = `${fmtMs_(tAcum)}` + (vSeg != null ? ` (${vSeg.toFixed(2)} m/s)` : '');
        const line2 = `P ${fmtMs_(tSeg)}` + (vAvg != null ? ` · AVG ${vAvg.toFixed(2)} m/s` : '');
        btn.innerHTML = `<div>${line1}</div><div style="font-size:12px; opacity:.85">${line2}</div>`;
      }

      btn.disabled = true;
      btn.classList.add('parcial-fixed');
      try{ if (typeof updateBestSplitsTable === 'function') updateBestSplitsTable(); }catch(e){}
    }catch(err){
      console.error('lap override error', err);
    }
  };

  window.fin = function(e){
    try{
      const btn = (e && e.currentTarget && e.currentTarget.matches && e.currentTarget.matches('button'))
        ? e.currentTarget
        : (e && e.target && e.target.closest ? e.target.closest('button') : e.target);
      if (!btn || !btn.dataset) return;
      const i = Number(btn.dataset.i);
      if (!Number.isFinite(i)) return;
      if (!window.startTimes || startTimes[i] == null) return;
      if (!window.finishTimes) window.finishTimes = [];
      if (finishTimes[i] != null) return;

      const now = Date.now();
      const totalMs = now - Number(startTimes[i]);
      finishTimes[i] = totalMs;

      const laps = (window.lapTimes && lapTimes[i]) ? lapTimes[i] : [];
      const lastIdx = laps.length ? (laps.length - 1) : -1;
      const lastTime = (lastIdx >= 0 && laps[lastIdx] != null) ? Number(laps[lastIdx]) : 0;
      const tSplitEvent = totalMs - lastTime;

      const totalUnits = parseNumOpt_(config && config.total);
      const prevKnownUnits = window.getPrevKnownAccUnits_ ? window.getPrevKnownAccUnits_(i, (Array.isArray(config.partials)?config.partials.length:0)) : 0;
      const dFinalUnits = (totalUnits != null) ? (totalUnits - Number(prevKnownUnits || 0)) : null;

      const prevKnownTime = window.getPrevKnownAccTimeMs_ ? window.getPrevKnownAccTimeMs_(i, (Array.isArray(config.partials)?config.partials.length:0)) : 0;
      const tSeg = totalMs - prevKnownTime;

      const vSeg = mps_(dFinalUnits, tSeg);
      const vAvgTotal = mps_(totalUnits, totalMs);

      if (dFinalUnits == null){
        const line1 = `<b>FINAL</b> TA ${fmtMs_(totalMs)}`;
        const line2 = `TP ${fmtMs_(tSplitEvent)}`;
        btn.innerHTML = `<div>${line1}</div><div style="font-size:12px; opacity:.85">${line2}</div>`;
      } else {
        const line1 = `${fmtMs_(totalMs)}` + (vSeg != null ? ` (${vSeg.toFixed(2)} m/s)` : '');
        const line2 = `P ${fmtMs_(tSeg)}` + (vAvgTotal != null ? ` · AVG ${vAvgTotal.toFixed(2)} m/s` : '');
        btn.innerHTML = `<div><b>FINAL</b> ${line1}</div><div style="font-size:12px; opacity:.85">${line2}</div>`;
      }

      btn.disabled = true;
      btn.classList.add('parcial-fixed');

      try{ window.finishedCount = (window.finishedCount || 0) + 1; }catch(err){}

      if ((window.finishedCount || 0) === (config.swimmers || []).length){
        try{ clearInterval(masterTimer); }catch(e){}
        try{ clearSpawnTimeouts && clearSpawnTimeouts(); }catch(e){}
        try{ stopBtn.disabled = true; }catch(e){}
        if (window.onSeriesAllFinishedUnified_) window.onSeriesAllFinishedUnified_();
        else if (window.onSeriesAllFinished_) window.onSeriesAllFinished_();
        else if (typeof showFinalModal === 'function') showFinalModal();
      }
    }catch(err){
      console.error('fin override error', err);
    }
  };

  try { lap = window.lap; } catch (e) {}
  try { fin = window.fin; } catch (e) {}

  window.spawn = function(sw, i){
    startTimes[i] = Date.now();
    lapTimes[i] = [];
    finishTimes[i] = null;

    const unit = distUnit_();
    const tr = document.createElement('tr');
    tr.id = `row${i}`;

    const buttons = (config.partials || []).map((p, j) => {
      const label = (p == null || String(p).trim() === '') ? `P${j+1}` : `${p} ${unit}`;
      return `<td><button data-i='${i}' data-j='${j}' class="btn-parcial">${label}</button></td>`;
    }).join('');

    tr.innerHTML = `<td>${sw.name}</td><td>${sw.lane}</td><td>${sw.order}</td><td class='lane-timer'>00:00.00</td>` +
      buttons +
      `<td><button data-i='${i}' class='fin'>Fin</button></td>`;

    laneBody.appendChild(tr);
    tr.querySelectorAll('button[data-j]').forEach(b => b.addEventListener('click', (ev)=>{ if (window.lap) window.lap(ev); }));
    tr.querySelector('.fin').addEventListener('click', (ev)=>{ if (window.fin) window.fin(ev); });
  };

  const stopFinalizeAll_ = () => {
    try{
      const totalSw = (config && Array.isArray(config.swimmers)) ? config.swimmers.length : 0;
      if (!totalSw) return;
      if (!window.finishTimes) window.finishTimes = [];

      try{ if (window.masterTimer) { clearInterval(masterTimer); masterTimer = null; } }catch(e){}

      const now = Date.now();
      for (let i = 0; i < totalSw; i++){
        if (finishTimes[i] != null) continue;
        if (!window.startTimes || startTimes[i] == null) continue;

        const totalMs = now - Number(startTimes[i]);
        finishTimes[i] = totalMs;

        const finBtn = document.querySelector(`button.fin[data-i="${i}"]`);
        if (finBtn){
          const totalUnits = parseNumOpt_(config && config.total);
          const vAvg = mps_(totalUnits, totalMs);
          finBtn.innerHTML = `
            <div style="font-weight:700;">${fmtMs_(totalMs)}</div>
            <div style="margin-top:2px; font-size:0.92em;">AVG ${vAvg != null ? vAvg.toFixed(2) : '0.00'} m/s</div>
          `;
          finBtn.disabled = true;
          finBtn.classList.add('parcial-fixed');
          const row = finBtn.closest('tr');
          if (row) row.querySelectorAll('button[data-j]').forEach(b => { b.disabled = true; });
        }
      }

      window.finishedCount = totalSw;
      if (window.onSeriesAllFinishedUnified_) window.onSeriesAllFinishedUnified_();
      else if (window.onSeriesAllFinished_) window.onSeriesAllFinished_();
      else if (typeof showFinalModal === 'function') showFinalModal();
    }catch(err){
      console.error('stopFinalizeAll_ error', err);
    }
  };

  try{
    const stopBtnEl = document.getElementById('stopBtn');
    if (stopBtnEl && !stopBtnEl.__v38fStopOverride){
      stopBtnEl.__v38fStopOverride = true;
      stopBtnEl.addEventListener('click', (ev) => {
        try{ ev.stopImmediatePropagation(); ev.preventDefault(); }catch(e){}
        stopFinalizeAll_();
      }, true);
    }
  }catch(e){ console.error(e); }

  window.onSeriesAllFinishedUnified_ = function(){
    const afterStrokes = () => {
      const pending = (typeof window.getPendingUndefMap_ === 'function') ? window.getPendingUndefMap_() : [];
      const proceed = () => {
        try { if (typeof recalcAllAccOverridesFromSplits_ === 'function') { /* already */ } }catch(e){}
        try { saveExecutedSessionToLocal_ && saveExecutedSessionToLocal_(null); } catch(e){ console.error('autosave results error', e); }
        if (window.onSeriesAllFinished_) window.onSeriesAllFinished_();
        else if (typeof showFinalModal === 'function') showFinalModal();
      };
      if (pending && pending.length){
        if (typeof openOptionalDistanceFlow_ === 'function') openOptionalDistanceFlow_(pending, proceed);
        else if (typeof openUndefEditor_ === 'function') openUndefEditor_(pending, proceed);
        else proceed();
      } else {
        proceed();
      }
    };

    if (typeof openStrokesModalIfNeeded_ === 'function'){
      openStrokesModalIfNeeded_(afterStrokes);
    } else {
      afterStrokes();
    }
  };

  window.openMigEdit_ = function(idx){
    const modal = document.getElementById('migEditModal');
    if (!modal) return;

    modal.style.display = 'block';
    try{ document.body.classList.add('modal-open'); }catch(e){}

    const sw = (config.swimmers || [])[idx];
    if (!sw) return;

    const setVal = (id, val, ro = false) => {
      const el = document.getElementById(id);
      if (!el) return;
      el.value = (val == null ? '' : String(val));
      if (ro){
        el.readOnly = true;
        el.disabled = false;
        el.style.background = '#f9fafb';
      }
    };

    setVal('migEditName', sw.name || '');
    setVal('migEditId', sw.swimmer_id || '', true);
    setVal('migEditLane', sw.lane || '');
    setVal('migEditOrder', sw.order || '');

    const totalMs = (window.finishTimes && finishTimes[idx] != null) ? Number(finishTimes[idx]) : null;
    setVal('migEditTotal', (totalMs != null && isFinite(totalMs)) ? fmtMs_(totalMs) : '', true);

    const body = document.getElementById('migEditSplitsBody');
    if (!body) return;

    const parts = Array.isArray(config.partials) ? config.partials : [];
    const nParts = parts.length;
    const laps = (window.lapTimes && lapTimes[idx]) ? lapTimes[idx] : [];
    if (!Array.isArray(sw.partialSplitOverrides)) sw.partialSplitOverrides = [];
    if (!Array.isArray(sw.partialAccOverrides)) sw.partialAccOverrides = [];

    const unit = distUnit_();
    let rows = '';
    for (let j = 0; j < nParts; j++){
      if (laps[j] == null) continue;

      const label = (typeof getPartialLabel_ === 'function') ? getPartialLabel_(j) : ('P' + (j + 1));
      const tA = Number(laps[j]);
      const tP = getTPMs_(idx, j, tA);

      const base = parseNumOpt_(config.partials[j]);
      const isOpt = (base == null);
      const A_units = window.getAccUnitsForSwimmer_ ? window.getAccUnitsForSwimmer_(idx, j) : null;
      const dVal = (sw.partialSplitOverrides[j] != null) ? sw.partialSplitOverrides[j] : '';
      const aTxt = (A_units == null) ? '—' : (String(A_units) + unit);

      rows += `
        <tr>
          <td>${label}</td>
          <td style="white-space:nowrap;">TA ${fmtMs_(tA)}<br>TP ${fmtMs_(tP)}</td>
          <td>
            <input class="migD" data-j="${j}" inputmode="decimal" ${isOpt ? '' : 'disabled'} placeholder="D ${unit}" value="${isOpt ? dVal : ''}">
          </td>
          <td id="migA_${j}">A ${aTxt}</td>
        </tr>
      `;
    }

    if (totalMs != null && isFinite(totalMs)){
      const Df = (typeof getFinalSplitUnitsForSwimmer_ === 'function') ? getFinalSplitUnitsForSwimmer_(idx) : null;
      const Af = parseNumOpt_(config && config.total);
      const dTxt = (Df == null) ? '—' : (String(Df) + unit);
      const aTxt = (Af == null) ? '—' : (String(Af) + unit);
      rows += `
        <tr>
          <td><b>FINAL</b></td>
          <td>TA ${fmtMs_(totalMs)}</td>
          <td>D ${dTxt}</td>
          <td>A ${aTxt}</td>
        </tr>
      `;
    }

    body.innerHTML = rows || '';
    body.querySelectorAll('input.migD').forEach(inp => {
      inp.addEventListener('input', () => {
        const j = Number(inp.dataset.j);
        const v = parseNumOpt_(inp.value);
        if (!Array.isArray(sw.partialSplitOverrides)) sw.partialSplitOverrides = [];
        sw.partialSplitOverrides[j] = v;

        try{ if (typeof recalcAllAccOverridesFromSplits_ === 'function') recalcAllAccOverridesFromSplits_(); }catch(e){}

        const A_units = window.getAccUnitsForSwimmer_ ? window.getAccUnitsForSwimmer_(idx, j) : null;
        const aTxt = (A_units == null) ? '—' : (String(A_units) + unit);
        const el = document.getElementById('migA_' + j);
        if (el) el.textContent = 'A ' + aTxt;
      });
    });

    window.migEditingIdx = idx;
  };

  window.applyMigEditSave_ = function(){
    try{
      const idx = Number(window.migEditingIdx);
      const sw = (config.swimmers || [])[idx];
      if (!sw) return;

      const body = document.getElementById('migEditSplitsBody');
      if (body){
        body.querySelectorAll('input.migD').forEach(inp => {
          const j = Number(inp.dataset.j);
          const v = parseNumOpt_(inp.value);
          if (!Array.isArray(sw.partialSplitOverrides)) sw.partialSplitOverrides = [];
          sw.partialSplitOverrides[j] = v;
        });
      }

      const r = recalcAllAccOverridesFromSplits_();
      if (!r.ok){
        const msg = document.getElementById('migEditMsg');
        if (msg){ msg.textContent = r.msg || 'Distancias inválidas'; msg.style.color = '#b91c1c'; }
        return;
      }

      try{
        if (typeof window.buildSeriesPayload_ === 'function'){
          window.lastPayload = window.buildSeriesPayload_();
          if (window.elJson) elJson.value = JSON.stringify(lastPayload, null, 2);
        }
      }catch(e){ console.error(e); }

      try{ if (typeof renderMigrationModal_ === 'function') renderMigrationModal_(); }catch(e){}

      const modal = document.getElementById('migEditModal');
      if (modal) modal.style.display = 'none';
      try{ document.body.classList.remove('modal-open'); }catch(e){}
    }catch(err){
      console.error('applyMigEditSave_ override error', err);
    }
  };

  try{
    const saveBtn = document.getElementById('migEditSave');
    if (saveBtn && !saveBtn.__v38fFinalRewired){
      saveBtn.__v38fFinalRewired = true;
      const clone = saveBtn.cloneNode(true);
      saveBtn.parentNode.replaceChild(clone, saveBtn);
      clone.id = 'migEditSave';
      clone.addEventListener('click', window.applyMigEditSave_);
    }
  }catch(e){ console.error(e); }

})();
</script>

</body>
</html>
